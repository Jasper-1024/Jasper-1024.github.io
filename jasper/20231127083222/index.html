<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="M2t8cZr5nIzHmltyt7Utj3nWYxNyNkCzFyigXBHkGUs"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"jasper1024.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"vs2015","dark":"vs2015"},"prism":{"light":"prism-vsc-dark-plus","dark":"prism-vsc-dark-plus"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"disqus","order":-1},"utteranc":{"text":"utteranc","order":-2}}},"stickytabs":true,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/config.min.js" defer></script><meta name="description" content="Rust FFI 总结, 转载汇总自 rust 中文语言社区   资料来源:  &lt;&gt;    更新 12023.11.27 初始"><meta property="og:type" content="article"><meta property="og:title" content="Rust FFI 基础知识"><meta property="og:url" content="https://jasper1024.com/jasper/20231127083222/index.html"><meta property="og:site_name" content="默"><meta property="og:description" content="Rust FFI 总结, 转载汇总自 rust 中文语言社区   资料来源:  &lt;&gt;    更新 12023.11.27 初始"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-11-27T12:00:00.000Z"><meta property="article:modified_time" content="2023-11-27T08:42:00.000Z"><meta property="article:author" content="Jasper"><meta property="article:tag" content="rust"><meta property="article:tag" content="ffi"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jasper1024.com/jasper/20231127083222/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jasper1024.com/jasper/20231127083222/","path":"jasper/20231127083222/","title":"Rust FFI 基础知识"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Rust FFI 基础知识 | 默</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-207687331-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-207687331-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/analytics/google-analytics.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/comments.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/utils.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/motion.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/sidebar.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/next-boot.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/pjax.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/search/local-search.min.js" defer></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/pdf.min.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.10.1/dist/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/mermaid.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/fancybox.min.js" defer></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ItayEcWO7OsLFKF2Y8SsAYG1-MdYXbMMI","app_key":"18UBQFmJXXcOQFebLovT36lh","server_url":null,"security":false}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/statistics/lean-analytics.min.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/quicklink@3.0.1/dist/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://jasper1024.com/jasper/20231127083222/"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/quicklink.min.js" defer></script><link rel="stylesheet" href="source/_data/callout_blocks.css"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="默" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">默</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">生存是唯一的长路</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">45</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">330</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">65</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-comments fa-fw"></i>留言</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%AF%AD"><span class="nav-number">1.</span> <span class="nav-text">导语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ffi-%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">FFI 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ffi-%E7%9A%84%E5%8E%86%E5%8F%B2%E5%92%8C%E7%8E%B0%E7%8A%B6"><span class="nav-number">2.1.</span> <span class="nav-text">FFI 的历史和现状</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ffi-%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">FFI 调用原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ffi-%E7%9A%84%E5%9B%B0%E9%9A%BE%E4%B9%8B%E5%A4%84"><span class="nav-number">2.3.</span> <span class="nav-text">FFI 的困难之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E8%AF%AD%E8%A8%80%E5%8F%AF%E4%BB%A5%E6%96%B9%E4%BE%BF%E5%9C%B0%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B-ffi-%E5%BA%93%E6%94%AF%E6%8C%81"><span class="nav-number">2.4.</span> <span class="nav-text">哪些语言可以方便地对外提供 FFI 库支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%B7%E6%87%92%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98"><span class="nav-number">2.5.</span> <span class="nav-text">偷懒的程序员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#swig"><span class="nav-number">2.5.1.</span> <span class="nav-text">SWIG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gnome-%E7%A4%BE%E5%8C%BA%E5%85%B3%E4%BA%8E%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8-gi-%E8%A7%84%E8%8C%83%E7%9A%84%E7%90%86%E6%83%B3%E5%92%8C%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.5.2.</span> <span class="nav-text">Gnome 社区关于构建通用 GI 规范的理想和实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%80%9D%E8%B7%AF%E5%9F%BA%E4%BA%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%B9%B3%E5%8F%B0%E7%BA%A7%E8%B7%AF%E7%BA%BF"><span class="nav-number">2.6.</span> <span class="nav-text">另一种思路——基于字节码的平台级路线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jvm-%E5%B9%B3%E5%8F%B0%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E7%9A%84-ffi"><span class="nav-number">2.6.1.</span> <span class="nav-text">JVM 平台语言之间的 FFI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wasm-%E5%B9%B3%E5%8F%B0%E7%9A%84-ffi"><span class="nav-number">2.6.2.</span> <span class="nav-text">WASM 平台的 FFI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">2.7.</span> <span class="nav-text">结语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust-%E8%AF%AD%E8%A8%80%E5%B1%82%E9%9D%A2%E5%AF%B9-ffi-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">3.</span> <span class="nav-text">Rust 语言层面对 FFI 的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%B3%E9%94%AE%E5%AD%97-extern"><span class="nav-number">3.1.</span> <span class="nav-text">1. 关键字 extern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-extern-%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1 extern 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E5%B1%9E%E6%80%A7-no_mangle"><span class="nav-number">3.1.2.</span> <span class="nav-text">1.2 属性 #[no_mangle]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E5%A4%96%E9%83%A8%E5%9D%97-externblock"><span class="nav-number">3.1.3.</span> <span class="nav-text">1.3 外部块 ExternBlock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%9D%97%E7%9A%84%E5%B1%9E%E6%80%A7-link"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">外部块的属性 link</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%9D%97%E7%9A%84%E5%B1%9E%E6%80%A7-link_name"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">外部块的属性 link_name</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">3.2.</span> <span class="nav-text">2. 标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21-stdosraw-%E6%A8%A1%E5%9D%97"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 std::os::raw 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E6%A0%87%E5%87%86%E5%BA%93-stdffi-%E6%A8%A1%E5%9D%97"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 标准库 std::ffi 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cstr"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">CStr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cstring"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">CString</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-crate"><span class="nav-number">4.</span> <span class="nav-text">Libc Crate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.1.</span> <span class="nav-text">Libc 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="nav-number">4.2.</span> <span class="nav-text">Libc 的导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-%E7%9A%84%E5%86%85%E5%AE%B9%E5%88%86%E7%B1%BB"><span class="nav-number">4.3.</span> <span class="nav-text">Libc 的内容分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-%E7%9A%84%E7%95%8C%E9%99%90"><span class="nav-number">4.4.</span> <span class="nav-text">Libc 的界限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E4%BD%BF%E7%94%A8-libc-%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.5.</span> <span class="nav-text">举例：使用 Libc 创建子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%E6%98%AF-rust-std-%E4%B8%8D%E8%83%BD%E5%81%9A%E8%80%8C-libc-%E8%83%BD%E5%81%9A%E7%9A%84"><span class="nav-number">4.6.</span> <span class="nav-text">哪些事情是 Rust Std 不能做而 Libc 能做的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-%E4%B8%8E-stdosraw-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.7.</span> <span class="nav-text">Libc 与 std::os::*::raw 的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nix-crate"><span class="nav-number">5.</span> <span class="nav-text">Nix Crate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-unix-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">什么是 Unix 系统编程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nix-%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.2.</span> <span class="nav-text">Nix 库介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nix-%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.3.</span> <span class="nav-text">Nix 库使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-nix-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">用 Nix 如何创建一个子进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forkkill-%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">fork&#x2F;kill 示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">5.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Jasper" src="/images/avatar.jfif"><p class="site-author-name" itemprop="name">Jasper</p><div class="site-description" itemprop="description">微尘</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">330</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phc3Blci0xMDI0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jasper-1024"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><a href="/ljy087621@gmail.com" title="E-Mail → ljy087621@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly94LmNvbS9KYXNwZXJfMTAyNA==" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;Jasper_1024"><i class="fab fa-twitter fa-fw"></i>Twitter</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL2phc3BlcjEwMjQ=" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;jasper1024"><i class="fab fa-skype fa-fw"></i>Telegram</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fas fa-rss fa-fw"></i>RSS</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tLw==" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;">forecho</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tL2ZyaWVuZHNoaXAtbGlua3Mv" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;friendship-links&#x2F;">友链聚合</span></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jasper1024.com/jasper/20231127083222/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jfif"><meta itemprop="name" content="Jasper"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="默"><meta itemprop="description" content="微尘"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Rust FFI 基础知识 | 默"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Rust FFI 基础知识</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-11-27 12:00:00 / 修改时间：08:42:00" itemprop="dateCreated datePublished" datetime="2023-11-27T12:00:00Z">2023-11-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a> </span></span><span id="/jasper/20231127083222/" class="post-meta-item leancloud_visitors" data-flag-title="Rust FFI 基础知识" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/jasper/20231127083222/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="jasper/20231127083222/" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>14 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li><p>Rust FFI 总结, 转载汇总自 <span class="exturl" data-url="aHR0cHM6Ly9ydXN0Y2MuY24v">rust 中文语言社区<i class="fa fa-external-link-alt"></i></span></p></li><li><p>资料来源:</p><blockquote><p>&lt;&gt;</p></blockquote></li><li><p>更新</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023.11</span>.<span class="number">27</span> 初始</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h2 id="导语"><a class="markdownIt-Anchor" href="#导语"></a> 导语</h2><p>blog 断更了好久, 该总结的有点多… 先从 rust 开始,补上…</p><p>接下来会是 rust ffi 相关内容的总结, 汇总自 <span class="exturl" data-url="aHR0cHM6Ly9ydXN0Y2MuY24v">rust 中文语言社区<i class="fa fa-external-link-alt"></i></span> ,原来的教程比较零散.</p><h2 id="ffi-概述"><a class="markdownIt-Anchor" href="#ffi-概述"></a> FFI 概述</h2><p>FFI（Foreign Function Interface）是这样一种机制：用一种编程语言写的程序能调用另一种编程语言写的函数（routines）。</p><p>FFI 有两种内涵。一种是是在当前正在使用的语言（host）中，调用由其它语言（guest）提供的库。第二种内涵与第一种方向相反，即，使用当前语言（host）写库，供其它语言（guest）调用。不过，后者不是任何语言都能做到的，有些语言即使能做，也会非常吃力。</p><h3 id="ffi-的历史和现状"><a class="markdownIt-Anchor" href="#ffi-的历史和现状"></a> FFI 的历史和现状</h3><p>FFI 这个术语最早来自 Common Lisp 的 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm9yZWlnbl9mdW5jdGlvbl9pbnRlcmZhY2UjY2l0ZV9ub3RlLTE=">规范<i class="fa fa-external-link-alt"></i></span>。目前几乎所有严肃编程的语言都有提供 FFI 的支持，但大多数是单向功能。</p><p>不同语言称呼这种语言间调用的功能名字可能不同。Common Lisp、Haskell、Python、Rust 这些叫 FFI，Java 叫 JNI 或 JNA，还有一些其它语言叫 &quot; 绑定 &quot;。严格来说，FFI 与 绑定，意义并不相同，绑定可以理解为 FFI 中的一种实现。</p><p>不同语言实现 FFI 的方式不尽相同。有的语言，比如，要调用 C 库，必须用 C 语言，按那种语言的绑定规范，实现一个 C 项目，用 C 编译器编译并链接，生成库文件，再由这种语言调用（这种语言本身已经实现了加载其定义的规范 C 库的能力）。</p><p>有的语言，比如，Rust，要调用 C 库，不再需要使用 C 语言写绑定工程，而是直接使用 Rust 语言写。这样，就有个好处是，你不再需要掌握 C 语言的那么多的繁文缛节和工具链（但是还是必须懂 C 语言）。</p><h3 id="ffi-调用原理"><a class="markdownIt-Anchor" href="#ffi-调用原理"></a> FFI 调用原理</h3><p>为什么不同的语言之间能互相调用呢？</p><p>我们知道，计算机的运算，最底层的数据/代码都是以二进制的形式存在。所有的语言在编译后，都会以二进制的形式去执行（即使编译后的代码为字节码，虚拟机在运行的时候，也会继续翻译成 CPU 认识的二进制指令）。这就为不同语言间的调用提供了可能性。</p><p>但是，可能归可能。二进制毕竟太底层了。没有大家一致认可的 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUIwJTgzJUU3JTk0JUE4JUU3JUJBJUE2JUU1JUFFJTlB">调用约定<i class="fa fa-external-link-alt"></i></span>，那也是不可能互通的。于是，ABI（应用程序二进制接口） 就出现了。调用约定，类型表示和名称修饰这三者的统称，即是众所周知的应用二进制接口（ABI）。</p><p>试想，如果所有的语言在调用时都能认识同样一套 ABI 规范，那么就能完全畅通的调用了。可惜，世界不会像我们人为想象的那样干净。</p><p>在计算机技术发展的过程中，出现了各种 ABI 规范，它们有的看起来相似，但在具体编译器的实现上，又有细微不同。所以，这是一件很麻烦的事情。大体来说，有如下规范：</p><ul><li>cdecl</li><li>syscall</li><li>optlink</li><li>pascal</li><li>register</li><li>stdcall</li><li>fastcall</li><li>thiscall</li><li>winapi</li><li>Intel ABI</li><li>System V</li></ul><p>等。详情可参考：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvWDg2JUU4JUIwJTgzJUU3JTk0JUE4JUU3JUJBJUE2JUU1JUFFJTlBI2NkZWNs">X86调用约定<i class="fa fa-external-link-alt"></i></span>。</p><p>而 Rust 目前支持如下 ABI <span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9ub21pY29uL2ZmaS5odG1s">约定<i class="fa fa-external-link-alt"></i></span>：</p><ul><li>stdcall</li><li>aapcs</li><li>cdecl</li><li>fastcall</li><li>vectorcall</li><li>Rust</li><li>rust-intrinsic</li><li>system</li><li>C</li><li>win64</li><li>sysv64</li></ul><p>不过，值得庆幸的是，目前我们 IT 工业的基石，绝大部分是由 C 语言写成。于是自然而然，绝大多数库都遵循 cdecl（或 C）规范。所以我们可以专注于 C 规范来讨论问题。</p><hr><p>注: c++ 的函数名默认会有 &quot; 名称编程 &quot;, 需要在函数加上 extend “C” 才能直接使用原名称查找到函数;</p><hr><h3 id="ffi-的困难之处"><a class="markdownIt-Anchor" href="#ffi-的困难之处"></a> FFI 的困难之处</h3><p>FFI 实现起来，比想像的要复杂许多，困难体现在：</p><ul><li>如果 host 语言（调用主动方）带 GC（垃圾收集器），而 guest 语言（调用被动方）不带，那么可能会在资源管理（创建，释放）上面造成一些问题，需要特别细致地处理；</li><li>复杂对象或类型，在映射到两边的时候，可能会有一些不协调甚至失真的现象；</li><li>两边要同时引用一个可变对象的时候，可能会遇到问题；</li><li>如果两边的语言都是运行在 VM 之上的语言，那么这两个语言之间的直接 FFI 非常困难甚至不可能；</li><li>类型系统/对象组合模型/继承机制等其它细节，可能在跨语言的时候，成为障碍；</li><li>其它。</li></ul><p>所以，虽然都能做 FFI，但是不同语言实现 FFI 的困难程度是不同的。</p><h3 id="哪些语言可以方便地对外提供-ffi-库支持"><a class="markdownIt-Anchor" href="#哪些语言可以方便地对外提供-ffi-库支持"></a> 哪些语言可以方便地对外提供 FFI 库支持</h3><p>可惜，大部分语言只能单向地 &quot; 索取 &quot;。目前所知，能（较方便地）对其它语言提供 FFI 库支持的语言有：</p><ul><li>C</li><li>C++（通过定义 C 接口）</li><li>Rust（通过使用 C 约定）</li><li>Ada</li><li>Fortran</li></ul><p>小编能力所限，如有未列举完整之处，欢迎补充。</p><h3 id="偷懒的程序员"><a class="markdownIt-Anchor" href="#偷懒的程序员"></a> 偷懒的程序员</h3><p>在开发的过程中，要一个一个对大量的 C/C++ 库写绑定来进行 FFI，毕竟是一项费时费力的活儿。聪明的程序员们就开始构想一些 &quot; 通用 &quot; 的方案，实现批量快速绑定。</p><h4 id="swig"><a class="markdownIt-Anchor" href="#swig"></a> SWIG</h4><p>以下定义来自 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU1dJRw==">https://zh.wikipedia.org/wiki/SWIG<i class="fa fa-external-link-alt"></i></span> :</p><blockquote><p>简单包装界面产生器 (SWIG) 是一个开源软件工具，用来将 C 语言或 C++ 写的计算机程序或函式库，连接脚本语言，例如 Lua, Perl, PHP, Python, R, Ruby, Tcl, 和其它语言，例如 C#, Java, JavaScript, Go, D, OCaml, Octave, Scilab 以及 Scheme. 也可以输出成 XML 格式。</p></blockquote><p>也就是说，使用了 SWIG 这套工具和规范，就可以直接在上层语言（动态语言居多）中调用 C/C++ 库了，省却大量烦恼。但在实际使用中，还会有一些细节问题，往往需要人工调整。所以也不是那么完美。</p><p>SWIG 官网：<span class="exturl" data-url="aHR0cDovL3N3aWcub3JnLw==">http://swig.org/<i class="fa fa-external-link-alt"></i></span> 。</p><h4 id="gnome-社区关于构建通用-gi-规范的理想和实践"><a class="markdownIt-Anchor" href="#gnome-社区关于构建通用-gi-规范的理想和实践"></a> Gnome 社区关于构建通用 GI 规范的理想和实践</h4><p>Gnome/Gtk 那一帮理想主义青年，发明了 GI（GObject Introspection）。用于对基于 glib/gobject 生态的众多软件（C 代码库）自动生成完整的接口描述文件（及 typelib），然后其它语言只要实现了对 Gir 这一个标准的支持，那么就可以无缝调用所有经过 Gir 化处理的 C 库。而不再需要单独为每一个 C 库做绑定了。这样就大大简化了 FFI 接口项目的编写工作。</p><p>目前这一杰出创意的重量级工作成果有 cairo, pango, gtk 等库。</p><p>更多信息请参考：<span class="exturl" data-url="aHR0cHM6Ly9naS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvJUUzJTgwJTgy">https://gi.readthedocs.io/en/latest/。<i class="fa fa-external-link-alt"></i></span></p><h3 id="另一种思路基于字节码的平台级路线"><a class="markdownIt-Anchor" href="#另一种思路基于字节码的平台级路线"></a> 另一种思路——基于字节码的平台级路线</h3><p>语言间的相互调用，历史的发展提供了另一条路线：建立一个共同的字节码平台，这个平台之上的所有语言，皆可便捷地相互调用。</p><h4 id="jvm-平台语言之间的-ffi"><a class="markdownIt-Anchor" href="#jvm-平台语言之间的-ffi"></a> JVM 平台语言之间的 FFI</h4><p>Java 发展到现在，已经形成了一个强大的 JVM 生态。JVM 平台上有大量的新语言产生，比如 Scala, Clojure, JRuby, Jython 等。这些语言前端不同，但是共享同一套 JVM 字节码和调用规范。因此，这些语言和 Java 之间，以及这些衍生语言之间，能比较容易地实现相互调用。</p><p>JVM 平台的缺点在于，其生态中的成果，被局限在了 JVM 平台内，无法（或很难）被其它语言平台所享用。</p><h4 id="wasm-平台的-ffi"><a class="markdownIt-Anchor" href="#wasm-平台的-ffi"></a> WASM 平台的 FFI</h4><p>Web Assembly（WASM）是一个新的字节码平台，其势头发展很猛。其有着比 JVM 平台更大的野心和联盟。因为是新设计的字节码，故其在设计的时候，就对 JVM 平台的一些问题做了规避（这方面可 Google 查阅相关资料）。</p><p>目前几乎所有主流语言都已实现将 WASM 作为编译目标，并且有相当一部分语言能够加载 WASM 库文件，调用其中的函数。不同的语言编译出的 WASM 效能和体积大小也是不同的。目前来看，C、C++、Rust 这些非 GC 语言能够编译出最精简，执行效率最高的 WASM 字节码。</p><p>WASM 的规范还在快速完善中。</p><h3 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h3><p>本篇描述了 FFI （外部程序接口）的概念和基本原理，并对其历史、内在的困难，以及程序员在 FFI 发展上的各种尝试，都做了简单介绍。</p><p>本篇大量内容参考 wikipedia 的 Foreign function interface <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm9yZWlnbl9mdW5jdGlvbl9pbnRlcmZhY2U=">页面<i class="fa fa-external-link-alt"></i></span>。</p><p>恕小编能力所限，如有描述不当或不完整之处，欢迎同行指正或补充，感谢！</p><h2 id="rust-语言层面对-ffi-的支持"><a class="markdownIt-Anchor" href="#rust-语言层面对-ffi-的支持"></a> Rust 语言层面对 FFI 的支持</h2><p>Rust 语言对 FFI 有比较完善的支持。本节主要讲在基础设施层面，Rust 语言对 FFI 的支持。</p><p>Rust 语言主要在关键字和标准库两个方面对 FFI 提供了支持，具体如下：</p><ul><li>关键字 <code>extern</code><ul><li>属性 <code>#[no_mangle]</code></li><li>外部块 <code>ExternBlock</code> 及其属性 <code>link</code> 和 <code>link_name</code></li></ul></li><li>标准库<ul><li><code>std:os:raw</code> 模块</li><li><code>std:ffi</code> 模块</li></ul></li></ul><h3 id="1-关键字-extern"><a class="markdownIt-Anchor" href="#1-关键字-extern"></a> 1. 关键字 <code>extern</code></h3><p>在 Rust 语言中，使用关键字 <code>extern</code> 可以实现 Rust 语言与其它语言的交互，这是 Rust 外部函数接口 FFI 的基础。</p><h4 id="11-extern-函数"><a class="markdownIt-Anchor" href="#11-extern-函数"></a> 1.1 <code>extern</code> 函数</h4><p>直接在 Rust 的函数关键字 <code>fn</code> 前使用关键字 <code>extern</code>，可以创建一个允许其他语言调用 Rust 函数的接口。</p><p>同时可以通过使用 ABI 字符串 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 来指定具体的 ABI，其中有三个 ABI 字符串是跨平台的：</p><ul><li><code>extern &quot;Rust&quot;</code>，默认的 ABI，在 Rust 代码中对任何普通函数 <code>fn foo()</code> 声明时都将使用该 ABI。</li><li><code>extern &quot;C&quot;</code>，指定使用 C-ABI，类似 <code>extern fn foo()</code>，无论 C 编译器支持哪种默认设置。</li><li><code>extern &quot;system&quot;</code>，通常类似 <code>extern &quot;C&quot;</code>，但在 Win32 平台上，它是 “stdcall”，或用于链接到 Windows API。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ffi/c-call-rust/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_rust</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This is a Rust function for C!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-属性-no_mangle"><a class="markdownIt-Anchor" href="#12-属性-no_mangle"></a> 1.2 属性 <code>#[no_mangle]</code></h4><p>属性 <code>no_mangle</code>，用来关闭 Rust 的名称修改（name mangling）功能。<em>Mangling</em> 是编译器在解析名称时，修改我们定义的函数名称，增加一些用于其编译过程的额外信息。</p><p>但在与其它语言交互时，如果函数名称被编译器修改，程序开发者无法知道修改后的函数名称，其它语言也无法按原名称调用。执行 1.1 中示例代码时，报错信息如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols <span class="keyword">for</span> <span class="title class_">architecture</span> x86_64:</span><br><span class="line">  <span class="string">&quot;_call_from_rust&quot;</span>, referenced from:</span><br><span class="line">      _main <span class="keyword">in</span> main-<span class="number">77</span>cb59.o</span><br><span class="line">ld: <span class="title function_ invoke__">symbol</span>(s) not found <span class="keyword">for</span> <span class="title class_">architecture</span> x86_64</span><br><span class="line">clang: error: linker command failed with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以为了使 Rust 函数能在其它语言中被调用，必须禁用 Rust 编译器的名称修改功能。通过在 1.1 的示例代码中增加属性 <code>#[no_mangle]</code> ，告诉 Rust 编译器不要修改此函数的名称。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ffi/c-call-rust/src/lib.rs</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_rust</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This is a Rust function for C!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-外部块-externblock"><a class="markdownIt-Anchor" href="#13-外部块-externblock"></a> 1.3 外部块 <code>ExternBlock</code></h4><p>在 Rust 语言中，使用关键字 <code>extern</code> 可以声明一个外部块（ExternBlock），通过外部块的形式，可以在 Rust 代码中调用外部代码。</p><p>在 Rust 语言参考文档中，使用关键字 <code>extern</code> 声明一个外部块的语法格式如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> Abi? &#123;</span><br><span class="line">    InnerAttribute*</span><br><span class="line">    ExternalItem*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>Abi</code> 表示调用库使用的 ABI 标准，可选值为 1.1 节中提到的 ABI 字符串。缺省情况下，外部块默认为标准的 C-ABI。在定义外部块的时候，可以使用 <code>link</code> 和 <code>link_name</code> 这两个属性，通过它们来控制外部块的行为。</p><h5 id="外部块的属性-link"><a class="markdownIt-Anchor" href="#外部块的属性-link"></a> 外部块的属性 <code>link</code></h5><p>属性 <code>link</code> 用来指定原生库的名称，编译器根据它为外部块链接原生库。它支持的键有：<code>name</code>，<code>kind</code> 和 <code>wasm_import_module</code>，<code>name</code> 用来定义要链接的原生库的名称。 <code>kind</code> 是一个可选值，通过它来指定原生库的类型，它有以下三种可选的值：</p><ul><li><code>dylib</code>，表示为动态库。如果未指定 <code>kind</code>，则它为默认值。</li><li><code>static</code>，表示为静态库。</li><li><code>framework</code>，表示 macOS 的框架，这仅对 macOS 目标有效。</li></ul><p>如果对属性 <code>link</code> 设定了原生库的类型 <code>kind</code>，则必须包括原生库的名称 <code>name</code>。</p><p><code>wasm_import_module</code> 可用于指定 WebAssembly 模块的名称，如果未指定 <code>wasm_import_module</code>，则模块名称默认为 <code>env</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[link(name = <span class="string">&quot;c_library&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">c_function</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="外部块的属性-link_name"><a class="markdownIt-Anchor" href="#外部块的属性-link_name"></a> 外部块的属性 <code>link_name</code></h5><p>在外部块内，通过属性 <code>link_name</code>，指定原生库中函数或静态对象的名称，编译器根据它可以为外部块链接原生库并导入该名称定义的函数或静态对象。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#[link_name = <span class="string">&quot;c_function_name&quot;</span>]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name_in_rust</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部块中声明的函数在 Rust 代码中是不安全的，因为其他语言不会强制执行 Rust 语言中的语法规则，故无法检查这些代码，所以程序开发者务必要确保这部分代码的安全。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ffi/rust-call-c/src/main.rs</span></span><br><span class="line"><span class="comment">// 标准库&lt;stdlib.h&gt;内置的abs函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#[link_name = <span class="string">&quot;abs&quot;</span>]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs_in_rust</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;abs(-1) is &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs_in_rust</span>(-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-标准库"><a class="markdownIt-Anchor" href="#2-标准库"></a> 2. 标准库</h3><p>在实际开发 Rust 语言与其它语言相互调用的程序时，会遇到需要相互传递参数的情况。Rust 标准库 <code>std::os::raw</code> 和 <code>std::ffi</code> 这两个模块提供了这方面的支持。</p><h4 id="21-stdosraw-模块"><a class="markdownIt-Anchor" href="#21-stdosraw-模块"></a> 2.1 <code>std::os::raw</code> 模块</h4><p>使用 FFI 进行交互的代码通常会使用到 C 语言提供的基本类型，标准库 <code>std::os::raw</code> 模块 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 提供了一些类型与 C 语言定义的类型相匹配，以便与 C 语言交互的代码引用正确的类型。</p><table><thead><tr><th>类型</th><th>解释</th></tr></thead><tbody><tr><td><code>c_char</code></td><td>等同于 C 语言的 <code>char</code> 类型</td></tr><tr><td><code>c_double</code></td><td>等同于 C 语言的 <code>double</code> 类型</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>更多类型可以查见参考链接 <sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>。</p><h4 id="22-标准库-stdffi-模块"><a class="markdownIt-Anchor" href="#22-标准库-stdffi-模块"></a> 2.2 标准库 <code>std::ffi</code> 模块</h4><p>由于 Rust 语言中字符串与 C 语言字符串的不同之处，标准库 <code>std::ffi</code> 模块 <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 提供了一组实用的程序，主要用于外部函数接口 FFI 的绑定，以及用在与其他语言传递类 C 字符串的代码中。</p><p>在支持 C-ABI 的语言（如：Python）中传递 UTF-8 字符串 <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> 时，<code>CString</code> 和 <code>CStr</code> 很有用。</p><h5 id="cstr"><a class="markdownIt-Anchor" href="#cstr"></a> <code>CStr</code></h5><p>在 C 语言中生成的字符串，Rust 使用 <code>CStr</code> 来表示，它和 <code>str</code> 类型对应，表明并不拥有这个字符串的所有权。所以 <code>CStr</code> 表示一个以终止符 <code>\0</code> 结尾的字节数组的引用，如果它是有效的 UTF-8 字符串，则可以将其转换为 Rust 语言中的 <code>＆str</code>。实现从 C 语言到 Rust 语言的字符串传递。</p><h5 id="cstring"><a class="markdownIt-Anchor" href="#cstring"></a> <code>CString</code></h5><p>在 Rust 语言中生成的字符串，Rust 使用 <code>CString</code> 来表示用以传给 C 程序的字符串。<code>CString</code> 以终止符 <code>\0</code> 结尾，并且没有内部 <code>\0</code> 字符，代码可以首先从 Rust 语言的普通字符串创建 <code>CString</code> 类型，然后将其作为参数传递给使用 C-ABI 约定的字符串函数。实现从 Rust 语言到 C 语言的字符串传递。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CString;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="title function_ invoke__">rust_printer</span>(input: *<span class="keyword">const</span> c_char) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c_str_to_print</span> = CString::<span class="title function_ invoke__">new</span>(hello).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：因为所有权概念是 Rust 语言特有的，所以在和 C 语言交互时，必须实现一个释放内存的方法供 C 代码调用。</p><p>此外在不同操作系统平台传输字符串，或者在捕获外部命令的输出时，<code>OsString</code> 和 <code>OsStr</code> 很有用。</p><ul><li><code>OsString</code> 表示传递给操作系统的拥有所有权的字符串。例如，<code>env::var_os()</code> 用于查询环境变量，它返回一个 <code>Option&lt;OsString&gt;</code>。如果环境变量存在，将获得 <code>Some(os_string)</code>，然后可以将其转换为 Rust 字符串。</li><li><code>OsStr</code> 表示传递给操作系统的字符串引用，可以按照与 <code>OsString</code> 类似的方式将其转换为 UTF-8 编码的 Rust 字符串切片。</li></ul><p>另外，当用作指针时，<code>std::ffi::c_void</code> 等同于 C 语言中的 <code>void</code> 类型。</p><p>示例代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlc3RlcmxpL3J1c3QtcHJhY3RpY2UvdHJlZS9tYXN0ZXIvZmZp">https://github.com/lesterli/rust-practice/tree/master/ffi<i class="fa fa-external-link-alt"></i></span></p><h2 id="libc-crate"><a class="markdownIt-Anchor" href="#libc-crate"></a> Libc Crate</h2><p><strong>前文警示：如果对 Unix 环境系统编程没有基础知识的话，本文会看得云里雾里。</strong></p><p>我们在做 Rust 开发编译的时候，常常能在依赖列表中，看到 libc 这个 crate 的身影。我们一般不会直接依赖这个 crate，但是依赖的依赖（的依赖的依赖……）可能就会用到这个 crate。总的来说，它是 Rust 生态中非常基础非常底层的一个 crate 了。</p><h3 id="libc-是什么"><a class="markdownIt-Anchor" href="#libc-是什么"></a> Libc 是什么</h3><p>libc 是对各平台的系统库的原始 FFI 绑定。其代码地址在：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9saWJjJUUzJTgwJTgyJUU1JThGJUFGJUU0JUJCJUE1JUU3JTlDJThCJUU1JTg4JUIwJUVGJUJDJThDJUU4JUJGJTk5JUU2JTk4JUFG">https://github.com/rust-lang/libc。可以看到，这是<i class="fa fa-external-link-alt"></i></span> Rust 官方维护的一个库。</p><p>libc 提供了与 Rust 支持的各平台上的最基础系统 C 库打交道的所有必要设施。它导出了底层平台的类型、函数和常量。</p><p>所有内容都直接放置在 libc 这个命名空间下，没有再分模块了。因此，你可以使用 <code>libc::foo</code> 这种形式访问这个库中的任何导出内容。</p><p>它可以与 std 配合使用，也可以在 no_std 环境下使用。</p><h3 id="libc-的导入"><a class="markdownIt-Anchor" href="#libc-的导入"></a> Libc 的导入</h3><p>在项目的 <code>Cargo.toml</code> 中添加如下配置，就可以导入 libc 了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">libc = <span class="string">&quot;0.2&quot;</span></span><br></pre></td></tr></table></figure><h3 id="libc-的内容分类"><a class="markdownIt-Anchor" href="#libc-的内容分类"></a> Libc 的内容分类</h3><p>libc 会导出底层 C 库的这些东西：</p><ul><li>C 类型，比如 typedefs, 原生类型，枚举，结构体等等</li><li>C 常量，比如使用 <code>#define</code> 指令定义的那些常量</li><li>C 静态变量</li><li>C 函数（按它们的头文件中定义的函数签名来导出）</li><li>C 宏，在 Rust 中会实现为 <code>#[inline]</code> 函数</li></ul><p>另外，libc 中导出的所有 C struct 都已经实现了 <code>Copy</code> 和 <code>Clone</code> trait.</p><p>好吧，熟悉 C 的同学，应该已经知道了，C 的接口，无非也就这些东西了。现在 libc 全给导出来了。</p><p>导出的结果是什么呢？直接打开 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnJzL2xpYmMvMC4yLjY5L2xpYmMvaW5kZXguaHRtbA==">https://docs.rs/libc/0.2.69/libc/index.html<i class="fa fa-external-link-alt"></i></span> 查看，在你面前将会出现一个长长的网页。有</p><ul><li>Structs 对应 C 中的符号</li><li>Enums 对应 C 中的枚举</li><li>Constants 对应 C 中的常量</li><li>Functions 对应 C 中的函数接口</li><li>Type Definitions 对应 C 中的 typedef 定义的符号</li></ul><p>这些符号，可能 99% 的人都不敢打包票说用过 20% 以上，甚至很多专注于上层开发的同学从没见过这些命名。</p><p>这一套东西可不得了，它是计算机工程历史这么多年积累下来的成体系的精华之作。这套精华的体系就叫作 _Unix 环境编程 _。这套体系在 <span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTkwMDQwMy8=">《UNIX环境高级编程（第3版）》<i class="fa fa-external-link-alt"></i></span> 这本书中做了权威讲解。</p><p>这套东西的精华核心在于，它不仅仅是一套符号的简单罗列，其内在包含有一套精巧的机制来驱动。对，是一套机制。这套机制又是由若干个不同的部分组成，这些部分之间区分得非常清晰（Unix 的 KISS 原则），但是在设计理念上，又保持了同一种味道。因此，这套东西，我们称其为工程、技术、哲学、甚至艺术。</p><p>这套东西是现代 IT 工业，互联网的基石。</p><h3 id="libc-的界限"><a class="markdownIt-Anchor" href="#libc-的界限"></a> Libc 的界限</h3><p>熟悉 linux 系统开发的同学都知道，linux 系统本身有个 libc 库，是几乎一切应用的基础库。基本上 linux 下 C 语言写的代码都要链接这个库才能运行。</p><p>而 Rust 的 libc crate，不完全等价于 C 的 libc 库的封装。具体区别如下：</p><ul><li>Linux （以及其它 unix-like 平台）下，导出的是 libc, libm, librt, libdl, libutil 和 libpthread 这几个库的符号。</li><li>OSX 下，导出的是 libsystem_c, libsystem_m, libsystem_pthread, libsystem_malloc 和 libdyld 这几个库的符号。</li><li>Windows 下，导出的是 VS CRT（VS C RunTime VS C 运行时库）中的符号。但是这些符号，比前两个平台的符号，数量上要少得多。因此，可以直接这样说，Rust libc crate 在 Windows 平台上的功能有限。在 Windows 平台上，建议使用 <code>winapi</code> 这个 crate 进行开发。</li></ul><h3 id="举例使用-libc-创建子进程"><a class="markdownIt-Anchor" href="#举例使用-libc-创建子进程"></a> 举例：使用 Libc 创建子进程</h3><p>说得那么神乎其神，还是让我们见见 libc 的庐山真面目吧。下面，我们就用一个示例——创建一个子进程——来展示 libc 的用法，以及与 Rust 标准库中线程操作的不同。</p><p>Rust 标准库中没有提供创建子进程的设施，不过可以创建一个子线程。作为对比演示，我们就创建一个新线程吧：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">child</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello, I am a new rust thread!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = child.<span class="title function_ invoke__">join</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, I am main thread!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello, I am a new rust thread!</span><br><span class="line"><span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">Hello, I am main thread!</span><br></pre></td></tr></table></figure><p>下面我们来看看用 libc 如何创建一个子进程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;                                                                                              </span><br><span class="line">    <span class="keyword">unsafe</span> &#123;                                                                                             </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pid</span> = libc::<span class="title function_ invoke__">fork</span>();                                                                          </span><br><span class="line">                                                                                                       </span><br><span class="line">        <span class="keyword">if</span> pid &gt; <span class="number">0</span> &#123;                                                                                     </span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello, I am parent thread: &#123;&#125;&quot;</span>, libc::<span class="title function_ invoke__">getpid</span>());                                   </span><br><span class="line">        &#125;                                                                                           </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> pid == <span class="number">0</span> &#123;                                                                               </span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello, I am child thread: &#123;&#125;&quot;</span>, libc::<span class="title function_ invoke__">getpid</span>());                                    </span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;My parent thread: &#123;&#125;&quot;</span>, libc::<span class="title function_ invoke__">getppid</span>());                                           </span><br><span class="line">        &#125;                                                                                                </span><br><span class="line">        <span class="keyword">else</span> &#123;                                                                                           </span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Fork creation failed!&quot;</span>);                                                           </span><br><span class="line">        &#125;                                                                                                </span><br><span class="line">    &#125;                                                                                                    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>这段代码会有类似下面的输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am parent thread: <span class="number">5722</span></span><br><span class="line">Hello, I am child thread: <span class="number">5724</span></span><br><span class="line">My parent thread: <span class="number">5722</span></span><br></pre></td></tr></table></figure><p>具体的进程 id 数字，每次运行都可能会变化。</p><p>从两个程序的简单对比，可以发现：</p><ol><li>libc 的所有函数调用，都<strong>必须</strong>放进 <code>unsafe</code> 块中。因为它的所有调用都是 unsafe 的；</li><li>std 的线程操作封装，好用，形象。libc 的进程操作，与 C 语言系统编程一样，完全是另外一套思路和编程风格；</li><li>std 的线程操作虽然简洁，但是也缺少更细颗粒度的控制。而 libc 可以对进程的操作（及后面对子进程的功能扩充，父进程中的信号管理等），做到完全的控制，更加灵活，功能强大；</li><li>std 本身无法实现进程 fork 的功能。</li></ol><p>以上代码示例地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rhb2dhbmd0YW5nL2xlYXJuLXJ1c3QvdHJlZS9tYXN0ZXIvMDdsaWJjdGVzdA==">https://github.com/daogangtang/learn-rust/tree/master/07libctest<i class="fa fa-external-link-alt"></i></span></p><h3 id="哪些事情是-rust-std-不能做而-libc-能做的"><a class="markdownIt-Anchor" href="#哪些事情是-rust-std-不能做而-libc-能做的"></a> 哪些事情是 Rust Std 不能做而 Libc 能做的？</h3><p>几乎所有底层编程的事情（当然这句话并不严谨）。</p><p>随便举几个例子：<code>dup2</code> 标准库有吗？<code>openpty</code> 标准库有吗？<code>ioctl</code> 标准库有吗？</p><p>ioctl 没有，那就是跟底层 say byebye 啦（进而跟严肃的嵌入式开发绝缘）。当然，你可以说，那我拿 Rust 自己写操作系统呗。对嘛，你用 Rust 写操作系统，也用不上 std 啊。</p><p>应该说，使用 libc，类 Unix 平台上的所有系统编程，之前只能由 C 完成的工作，现在都能用 Rust 来做了。在这一层面上，C 能做到的事情，Rust 都能做到。</p><p>通过 libc 这一层，Rust 闯入了系统编程领域。</p><p>可能，有的同学又要辩解了，不就是一个库嘛，这没什么大不了的。Python 也有对操作系统基础库的封装，Python 一样的可以做系统开发。这点不足以证明 Rust 是一门系统编程语言，Rust 在这一点上没有什么不同。</p><p>其实只需要用一句话就能回击这种质疑：因为我 Rust 的封装是 zero cost （零成本）的。</p><p>Yes，就这么简单。零成本抽象赋予了 Rust 系统编程的能力。</p><h3 id="libc-与-stdosraw-的关系"><a class="markdownIt-Anchor" href="#libc-与-stdosraw-的关系"></a> Libc 与 std::os::*::raw 的关系？</h3><p>细心的同学会发现，在标准库的 os 模块下面，有一些东西与 libc 的重复。</p><p>页面 <span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9zdGQvb3MvcmF3L2luZGV4Lmh0bWw=">https://doc.rust-lang.org/std/os/raw/index.html<i class="fa fa-external-link-alt"></i></span> 包含了 <code>c_char, c_double, c_float, c_int, c_long, c_longlong, c_schar, c_short, c_uchar, c_uint, c_ulong, c_ulonglong, c_ushort</code>。</p><p>而 libc 中，对这些内容，也重新定义了一份（比如：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnJzL2xpYmMvMC4yLjY5L2xpYmMvdHlwZS5jX2NoYXIuaHRtbA==">https://docs.rs/libc/0.2.69/libc/type.c_char.html<i class="fa fa-external-link-alt"></i></span>）。为什么呢？&gt;</p><p>std::os::raw 中这些定义，可以用于与一些简单的 C 代码进行交互，比如说不存在系统调用的 C 代码。这个时候，就不需要再引入 libc 库了。</p><p>而一旦产生了系统调用或者 Unix 环境编程，那么就得引入 libc 库来操作。</p><p>std 下面还有一些 std::os::*::raw 的模块，这些模块现在已经被 Deprecated 了（比如：<span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9zdGQvb3MvdW5peC9yYXcvaW5kZXguaHRtbA==">https://doc.rust-lang.org/std/os/unix/raw/index.html<i class="fa fa-external-link-alt"></i></span>）。文档中明确注释了：&gt;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deprecated since <span class="number">1.8</span>.<span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">these <span class="keyword">type</span> <span class="title class_">aliases</span> are no longer supported by the standard library, the libc <span class="keyword">crate</span> on crates.io should be used instead <span class="keyword">for</span> <span class="title class_">the</span> correct definitions</span><br></pre></td></tr></table></figure><p>也就是说，这些东西，去 libc 中找吧，用 libc 来实现这些功能。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>我们应该庆幸，Rust 标准库为我们提供的人性化的便捷的编程方式。</p><p>同时，我们又应该庆幸，Rust 与 C 的亲密血缘关系，让我们 Rustaceans 可以轻松的几乎没有性能损失的用 C 的方式和思维进行最底层的系统编程。</p><p>这种小幸运（可能性），不是谁都能拥有的。</p><p>我为能掌握 Rust 而感到幸福。</p><h2 id="nix-crate"><a class="markdownIt-Anchor" href="#nix-crate"></a> Nix Crate</h2><p>在 Rust 中使用 nix 这个库，在某些情况下可以简化 Unix 系统编程。本文主要包括以下内容：</p><ul><li>前言：什么是 Unix 系统编程？</li><li>nix 库介绍</li><li>nix 库使用示例</li></ul><h3 id="什么是-unix-系统编程"><a class="markdownIt-Anchor" href="#什么是-unix-系统编程"></a> 什么是 Unix 系统编程？</h3><p>Unix 系统编程实际上是把底层编程和系统设计两个概念混在了一起，本文将其理解为 &quot; 操作系统层级的编程 &quot;。在进行 Unix 系统编程时，关键要熟悉 <span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L21pbmRleC5odG1s">POSIX 规范<i class="fa fa-external-link-alt"></i></span> 中定义的接口函数，以及 Unix/Linux 的 <span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvbWFuLXBhZ2VzLw==">man 手册<i class="fa fa-external-link-alt"></i></span>，以下是一些示例：</p><ul><li>进程管理（例如，<span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9mb3JrLmh0bWw=">fork<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9raWxsLmh0bWw=">kill<i class="fa fa-external-link-alt"></i></span>）</li><li>文件处理（例如，<span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9yZWFkLmh0bWw=">read<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy93cml0ZS5odG1s">write<i class="fa fa-external-link-alt"></i></span>）</li><li>网络编程（例如，<span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9zb2NrZXQuaHRtbA==">socket<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9saXN0ZW4uaHRtbA==">listen<i class="fa fa-external-link-alt"></i></span>）</li><li>与硬件交互（例如，<span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9pb2N0bC5odG1s">ioctl<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9tbWFwLmh0bWw=">mmap<i class="fa fa-external-link-alt"></i></span>）</li><li>Linux 容器（例如，<span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL2Nsb25lLjIuaHRtbA==">clone<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL21vdW50LjIuaHRtbA==">mount<i class="fa fa-external-link-alt"></i></span>）</li></ul><h3 id="nix-库介绍"><a class="markdownIt-Anchor" href="#nix-库介绍"></a> Nix 库介绍</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnJzL25peC8wLjE3LjAvbml4Lw==">nix 库<i class="fa fa-external-link-alt"></i></span> 旨在提供对各种类 Unix 平台（Linux，Darwin 等）API 的友好绑定（bindings），其代码地址在：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25peC1ydXN0L25peA==">https://github.com/nix-rust/nix<i class="fa fa-external-link-alt"></i></span>。在其&gt; <span class="exturl" data-url="aHR0cDovL2xpYi5ycw==">lib.rs<i class="fa fa-external-link-alt"></i></span> 文件中有如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Re-exported external crates</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="keyword">crate</span> libc;</span><br></pre></td></tr></table></figure><p>它通过使用强制合法或安全的类型对 libc 库进行了一次封装，相对于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9saWJj">libc<i class="fa fa-external-link-alt"></i></span> 库暴露的 <code>unsafe</code> API，它具有两个特点：</p><ul><li>用户代码中尽量没有 <code>unsafe</code></li><li>Rust 风格的错误处理</li></ul><p>以系统调用 <code>gethostname</code> 为例，我们来看一下，libc 和 nix 之间的区别：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libc api (unsafe, requires handling return code/errno)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="keyword">fn</span> <span class="title function_">gethostname</span>(name: *<span class="keyword">mut</span> c_char, len: size_t) <span class="punctuation">-&gt;</span> c_int;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nix api (returns a nix::Result&lt;CStr&gt;)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">gethostname</span>&lt;<span class="symbol">&#x27;a</span>&gt;(buffer: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> [<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;&amp;<span class="symbol">&#x27;a</span> CStr&gt;;</span><br></pre></td></tr></table></figure><p>不过尽管 nix 库尝试支持 libc 库支持的所有平台，但由于技术或人力限制，仅支持其中的某些平台。可能这也是一些底层库（比如：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rva2lvLXJzL21pbw==">tokio项目中的mio<i class="fa fa-external-link-alt"></i></span>）在版本 v0.6.3 之后 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rva2lvLXJzL21pby9jb21taXQvZTYwNjdlZDY0NDU1ZmUwOTFiOWRiZjAwNTQwMGUzN2Q4YjNiNTdmZiNkaWZmLTAxNWM4NzliODQ0ZTRlYmI1ODQxYTBiMmIwNzdhNWI4">移除<i class="fa fa-external-link-alt"></i></span> 对 nix 库依赖的一个原因吧。</p><p>nix 库中的模块大致如下：</p><ul><li>dir，相对标准库中的 <code>std::fs::ReadDir</code> 更底层的目录接口。</li><li>errno， nix 库中处理各种类 Unix 系统的错误类型，对于 FreeBSD，IOS，MacOS 系统直接封装的 libc 库中的。</li><li>fcntl， Unix 系统中文件 IO 的数据结构，以及对文件的各种操作接口。</li><li>features，用于操作系统级功能的测试。</li><li>ifaddrs，使用 Linux 或 BSD 中的函数 <code>getifaddrs</code> 获取网络接口及地址列表。</li><li>kmod，包含加载和卸载内核模块的功能。</li><li>mount，包含设备文件的挂载操作，<code>mount</code> 和 <code>umount</code>。</li><li>mqueue， 对应 POSIX 规范中消息队列 <span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW43L21xX292ZXJ2aWV3LjcuaHRtbA==">API<i class="fa fa-external-link-alt"></i></span> 的功能。</li><li>net，涉及网络接口的功能。</li><li>poll，在特点文件描述符上触发 wait 事件。</li><li>pty，创建主从虚拟伪终端 PTYs。</li><li>sched，提供 Linux 系统的调度接口。</li><li>sys，这个模块包括各种系统相关的功能：POSIX 异步 I/O，文件系统事件的监控 API，Socket 接口函数等。</li><li>ucontext，提供协程上下文相关的借接口。</li><li>unistd，在 libc 库 <code>unistd.h</code> 头文件中函数的 safe 封装。</li></ul><h3 id="nix-库使用示例"><a class="markdownIt-Anchor" href="#nix-库使用示例"></a> Nix 库使用示例</h3><p>在项目的 Cargo.toml 中添加如下配置，就可以导入 nix 库了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">nix = <span class="string">&quot;0.17.0&quot;</span></span><br></pre></td></tr></table></figure><h4 id="用-nix-如何创建一个子进程"><a class="markdownIt-Anchor" href="#用-nix-如何创建一个子进程"></a> 用 Nix 如何创建一个子进程</h4><p>我们用 nix 库重写 libc 文章中创建一个子进程的示例，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> nix::unistd::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">fork</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(ForkResult::Parent &#123; child &#125;) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 在父进程中</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello, I am parent thread: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">getpid</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(ForkResult::Child) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 在子进程中</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello, I am child thread: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">getpid</span>());</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;My parent thread: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">getppid</span>());            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(errno) =&gt; &#123;</span><br><span class="line">            <span class="comment">// fork 创建子进程失败</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Fork creation failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forkkill-示例"><a class="markdownIt-Anchor" href="#forkkill-示例"></a> <code>fork</code>/<code>kill</code> 示例</h4><p>熟悉 POSIX 规范的话，其中的 <code>fork()</code> 函数可以用来创建一个新的进程（子进程），而 <code>kill()</code> 函数可以用来向一个或一组进程发送信号。我们来看如下的一段 C 语言代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int <span class="title function_ invoke__">main</span>(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t child = <span class="title function_ invoke__">fork</span>();</span><br><span class="line">    <span class="title function_ invoke__">if</span> (child)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="title function_ invoke__">kill</span>(child, SIGKILL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">for</span> (;;)</span><br><span class="line">        <span class="comment">// 循环直到被 kill 掉</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有问题吗？</p><p>我们知道 <code>fork()</code> 函数如果执行成功，则向子进程返回 0，并将子进程的进程 ID 返回给父进程。否则，将向父进程返回 -1，不创建子进程，并设置 <code>errno</code> 来标识错误。</p><p>上述代码中没有处理 <code>fork()</code> 函数失败时的逻辑，这样则可能将 -1（<code>fork</code> 的错误结果）视为子进程的进程 ID。这时在随后的程序中关闭子进程 <code>kill(child, SIGKILL);</code>，你知道进程 ID 为 -1 时会发生什么吗？</p><blockquote><p>If pid is -1, sig shall be sent to all processes (excluding an unspecified set of system processes) for which the process has permission to send that signal.</p></blockquote><blockquote><p>如果进程 ID 等于 -1，则将信号发送到调用进程有权发送信号的每个进程，一些系统进程（如 <code>init</code>）除外。</p></blockquote><p><code>kill(-1, SIGKILL);</code> 等效于 kill 你有权发送信号的所有其他进程。</p><p>我们来看 nix 库中的 <code>fork()</code> 函数，其返回值为 <code>Result&lt;ForkResult, Errno&gt;</code> 类型，相比 C 语言中的 <code>fork()</code> 函数，它有两个优点：</p><ul><li>Rust 的错误处理风格，使用类型 <code>Result</code> 区分成功和失败的情况</li><li>使用枚举类型 <code>ForkResult</code> 区分返回父/子进程</li></ul><p>这时使用 nix 库来重写上述逻辑，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> nix::sys::signal::*;</span><br><span class="line"><span class="keyword">use</span> nix::unistd::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">fork</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;fork failed&quot;</span>) &#123;</span><br><span class="line">        ForkResult::Parent&#123; child &#125; =&gt; &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="title function_ invoke__">kill</span>(child, SIGKILL).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;kill failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ForkResult::Child =&gt; &#123;</span><br><span class="line">            <span class="comment">// 直到被 kill 掉</span></span><br><span class="line">            <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码示例地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlc3RlcmxpL3J1c3QtcHJhY3RpY2UvdHJlZS9tYXN0ZXIvZmZpL25peA==">https://github.com/lesterli/rust-practice/tree/master/ffi/nix<i class="fa fa-external-link-alt"></i></span></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>nix 库通过对 libc 库暴露的 <code>unsafe</code> API 进行封装，为 libc 库支持的某些平台提供了一种 <code>safe</code> 的替代方案。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>外部块支持的 ABI 字符串，<span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9yZWZlcmVuY2UvaXRlbXMvZXh0ZXJuYWwtYmxvY2tzLmh0bWw=">https://doc.rust-lang.org/reference/items/external-blocks.html<i class="fa fa-external-link-alt"></i></span> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>标准库 <code>unsafe</code> 模块，<span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9zdGFibGUvc3RkL29zL3Jhdy9pbmRleC5odG1s">https://doc.rust-lang.org/stable/std/os/raw/index.html<i class="fa fa-external-link-alt"></i></span> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>标准库 <code>safe</code> 模块，<span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9zdGQvZmZpL2luZGV4Lmh0bWw=">https://doc.rust-lang.org/std/ffi/index.html<i class="fa fa-external-link-alt"></i></span> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>Rust 中 String 与 UTF-8 编码，<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWlhfMEc2SmNOTXVzTHo2SkpPa05TZw==">https://mp.weixin.qq.com/s/ZX_0G6JcNMusLz6JJOkNSg<i class="fa fa-external-link-alt"></i></span> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Jasper</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jasper1024.com/jasper/20231127083222/" title="Rust FFI 基础知识">https://jasper1024.com/jasper/20231127083222/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/rust/" rel="tag"># rust</a> <a href="/tags/ffi/" rel="tag"># ffi</a></div><div class="post-nav"><div class="post-nav-item"><a href="/jasper/20231127103031/" rel="prev" title="手动绑定 C 库入门"><i class="fa fa-angle-left"></i> 手动绑定 C 库入门</a></div><div class="post-nav-item"><a href="/jasper/20231128102346/" rel="next" title="Rust 导出共享库">Rust 导出共享库 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-disqus">disqus</a></li><li class="tab"><a href="#comment-utterances">utterances</a></li></ul><div class="tab-content"><div class="tab-pane disqus" id="comment-disqus"><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><div class="tab-pane utterances" id="comment-utterances"><div class="comments utterances-container"></div></div></div></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">JasperHale</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">20:54</span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phc3Blci0xMDI0" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"jasper1024","count":true,"i18n":{"disqus":"disqus"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/disqus.min.js" defer></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Jasper-1024/blog_discuss","issue_term":"pathname","theme":"github-dark"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/utterances.min.js" defer></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>