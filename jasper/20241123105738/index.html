<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="M2t8cZr5nIzHmltyt7Utj3nWYxNyNkCzFyigXBHkGUs"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"jasper1024.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"vs2015","dark":"vs2015"},"prism":{"light":"prism-vsc-dark-plus","dark":"prism-vsc-dark-plus"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"disqus","order":-1},"utteranc":{"text":"utteranc","order":-2}}},"stickytabs":true,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/config.min.js" defer></script><meta name="description" content="OVS 项目 conntrack-tcp.c 源码阅读记录   资料来源:  https:&#x2F;&#x2F;github.com&#x2F;openvswitch&#x2F;ovs    更新 12024.11.23 初始"><meta property="og:type" content="article"><meta property="og:title" content="OVS conntrack-tcp 源码阅读"><meta property="og:url" content="https://jasper1024.com/jasper/20241123105738/index.html"><meta property="og:site_name" content="默"><meta property="og:description" content="OVS 项目 conntrack-tcp.c 源码阅读记录   资料来源:  https:&#x2F;&#x2F;github.com&#x2F;openvswitch&#x2F;ovs    更新 12024.11.23 初始"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-11-23T12:00:00.000Z"><meta property="article:modified_time" content="2024-11-24T02:27:42.000Z"><meta property="article:author" content="Jasper"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jasper1024.com/jasper/20241123105738/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jasper1024.com/jasper/20241123105738/","path":"jasper/20241123105738/","title":"OVS conntrack-tcp 源码阅读"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>OVS conntrack-tcp 源码阅读 | 默</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-207687331-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-207687331-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/analytics/google-analytics.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/comments.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/utils.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/motion.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/sidebar.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/next-boot.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/pjax.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/search/local-search.min.js" defer></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/pdf.min.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.10.1/dist/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/mermaid.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/fancybox.min.js" defer></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ItayEcWO7OsLFKF2Y8SsAYG1-MdYXbMMI","app_key":"18UBQFmJXXcOQFebLovT36lh","server_url":null,"security":false}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/statistics/lean-analytics.min.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/quicklink@3.0.1/dist/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://jasper1024.com/jasper/20241123105738/"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/quicklink.min.js" defer></script><link rel="stylesheet" href="source/_data/callout_blocks.css"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="默" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">默</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">生存是唯一的长路</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">45</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">330</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">65</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-comments fa-fw"></i>留言</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%AF%AD"><span class="nav-number">1.</span> <span class="nav-text">导语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E6%97%A5%E8%B0%88"><span class="nav-number">2.</span> <span class="nav-text">前日谈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ovs-conntrack"><span class="nav-number">3.</span> <span class="nav-text">Ovs Conntrack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conntrack-tcp"><span class="nav-number">4.</span> <span class="nav-text">Conntrack-tcp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp_new_conn"><span class="nav-number">4.1.</span> <span class="nav-text">tcp_new_conn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp_conn_update"><span class="nav-number">4.2.</span> <span class="nav-text">tcp_conn_update</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A3%80%E6%9F%A5%E5%92%8C-syn-%E5%8C%85%E5%A4%84%E7%90%86"><span class="nav-number">4.2.1.</span> <span class="nav-text">基础检查和 SYN 包处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7%E8%BF%BD%E8%B8%AA%E5%92%8C%E7%AA%97%E5%8F%A3%E8%AE%A1%E7%AE%97"><span class="nav-number">4.2.2.</span> <span class="nav-text">序列号追踪和窗口计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E9%80%BB%E8%BE%91"><span class="nav-number">4.2.3.</span> <span class="nav-text">状态更新逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86"><span class="nav-number">4.2.4.</span> <span class="nav-text">特殊情况处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%8E%9F%E8%AE%BA%E6%96%87%E5%AF%B9%E6%AF%94"><span class="nav-number">5.</span> <span class="nav-text">与原论文对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">6.</span> <span class="nav-text">结语</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Jasper" src="/images/avatar.jfif"><p class="site-author-name" itemprop="name">Jasper</p><div class="site-description" itemprop="description">微尘</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">330</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phc3Blci0xMDI0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jasper-1024"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><a href="/ljy087621@gmail.com" title="E-Mail → ljy087621@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly94LmNvbS9KYXNwZXJfMTAyNA==" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;Jasper_1024"><i class="fab fa-twitter fa-fw"></i>Twitter</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL2phc3BlcjEwMjQ=" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;jasper1024"><i class="fab fa-skype fa-fw"></i>Telegram</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fas fa-rss fa-fw"></i>RSS</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tLw==" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;">forecho</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tL2ZyaWVuZHNoaXAtbGlua3Mv" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;friendship-links&#x2F;">友链聚合</span></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jasper1024.com/jasper/20241123105738/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jfif"><meta itemprop="name" content="Jasper"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="默"><meta itemprop="description" content="微尘"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="OVS conntrack-tcp 源码阅读 | 默"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">OVS conntrack-tcp 源码阅读</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-11-23 12:00:00" itemprop="dateCreated datePublished" datetime="2024-11-23T12:00:00Z">2024-11-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-11-24 02:27:42" itemprop="dateModified" datetime="2024-11-24T02:27:42Z">2024-11-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a> </span></span><span id="/jasper/20241123105738/" class="post-meta-item leancloud_visitors" data-flag-title="OVS conntrack-tcp 源码阅读" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/jasper/20241123105738/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="jasper/20241123105738/" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>18 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li><p>OVS 项目 conntrack-tcp.c 源码阅读记录</p></li><li><p>资料来源:</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW52c3dpdGNoL292cw==">https://github.com/openvswitch/ovs<i class="fa fa-external-link-alt"></i></span></p></blockquote></li><li><p>更新</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024.11</span>.<span class="number">23</span> 初始</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h2 id="导语"><a class="markdownIt-Anchor" href="#导语"></a> 导语</h2><p><a href="/jasper/20241117125429/#^i2ly">上一篇的 flag</a> 填坑; 先总结下 Real Stateful TCP Packet Filtering in IP Filter 的精华</p><ul><li>合理推到出了对 seq / seq +n / ack 的正确上下界约束 -&gt; <a href="/jasper/20241117125429/#总结">总结</a></li><li>算法复杂度 O(1) 非常有利于实现</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW52c3dpdGNoL292cw==">ovs<i class="fa fa-external-link-alt"></i></span> 实现了用户态的 conntrack 实现了类似 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNsb3VkZmxhcmUuY29tL2Nvbm50cmFjay10YWxlcy1vbmUtdGhvdXNhbmQtYW5kLW9uZS1mbG93cy8=">kernel 的 conntrack<i class="fa fa-external-link-alt"></i></span> 的能力, 完整追踪每个连接, 因此这一套 conntrack 可以被移植用于 防火墙/NAT 等程序中, 久经考验.</p><ul><li>又见 cloudflare 的文章…😶‍🌫️</li></ul><p>这一篇是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW52c3dpdGNoL292cy9ibG9iL21haW4vbGliL2Nvbm50cmFjay10Y3AuYw==">conntrack-tcp.c<i class="fa fa-external-link-alt"></i></span> 的详细分析, 以代码为主, 可能比较抽象;</p><h2 id="前日谈"><a class="markdownIt-Anchor" href="#前日谈"></a> 前日谈</h2><p>conntrack(connection tracking) 是网络协议栈中的一个组件, 主要用于跟踪网络连接的状态.常用于防火墙 NAT 和负载均衡等网络功能中扮演着关键角色.</p><p>conntrack 能够记录并维护每个网络连接的状态信息,包括源地址 目标地址 端口号以及协议类型等, 这使其所在的实体能够做出更智能的网络决策:</p><ul><li>允许或阻止特定的数据包</li><li>实现更精确的网络控制和安全策略</li></ul><p>在 OVS（Open vSwitch）中, conntrack 的为虚拟网络环境提供了连接跟踪能力.</p><h2 id="ovs-conntrack"><a class="markdownIt-Anchor" href="#ovs-conntrack"></a> Ovs Conntrack</h2><p>ovs conntrack 的代码集中在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW52c3dpdGNoL292cy90cmVlL21haW4v">lib<i class="fa fa-external-link-alt"></i></span>/conntrack-*</p><ul><li>conntrack.h: 模块入口</li><li>conntrack-private.h: 私有数据结构函数等<ul><li>conntrack.c: conntrack.h / conntrack-private.h 的实现</li></ul></li><li>conntrack-tp.h/conntrack-tp.c: 超时时间相关</li><li>conntrack-icmp.c / conntrack-tcp.c / conntrack-other.c: icmp icmp6 / tcp / other 的连接追踪实现.</li></ul><p>每个 connect 被抽象为 <code>struct conn</code></p><ul><li>conn 主键是 <code>struct conn_key_node []</code> 数组, 对应 orign 和 reply 两个反向的 <code>struct conn_key</code></li><li>每个 <code>struct conn_key</code> 相当于是 5 元组, <code>struct ct_endpoint</code> 真正的 ip:port</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ct_endpoint</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">ct_addr</span> <span class="title">addr</span>;</span> <span class="comment">// ip 地址</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ovs_be16 port; <span class="comment">// 端口</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ovs_be16 icmp_id;</span><br><span class="line">            <span class="type">uint8_t</span> icmp_type;</span><br><span class="line">            <span class="type">uint8_t</span> icmp_code;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 五元组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_key</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ct_endpoint</span> <span class="title">src</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ct_endpoint</span> <span class="title">dst</span>;</span></span><br><span class="line"></span><br><span class="line">    ovs_be16 dl_type;</span><br><span class="line">    <span class="type">uint16_t</span> zone;</span><br><span class="line">    <span class="type">uint8_t</span> nw_proto;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_key_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">key_dir</span> <span class="title">dir</span>;</span> <span class="comment">// 方向</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_key</span> <span class="title">key</span>;</span> <span class="comment">// 五元组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmap_node</span> <span class="title">cm_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Immutable data. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_key_node</span> <span class="title">key_node</span>[<span class="title">CT_DIRS</span>];</span> <span class="comment">// 主键数组[2]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_key</span> <span class="title">parent_key</span>;</span> <span class="comment">/* Only used for orig_tuple support. */</span></span><br><span class="line">    <span class="type">uint16_t</span> nat_action;</span><br><span class="line">    <span class="type">char</span> *alg;</span><br><span class="line">    <span class="type">atomic_flag</span> reclaimed; <span class="comment">/* False during the lifetime of the connection,</span></span><br><span class="line"><span class="comment">                            * True as soon as a thread has started freeing</span></span><br><span class="line"><span class="comment">                            * its memory. */</span></span><br><span class="line">    xxxx</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与协议有关的 conn 操作被抽象为了 <code>struct ct_l4_proto</code> 指针数组, tcp icmp ohter 各自实现.</p><ul><li>new_conn 新建 conn</li><li>valid_new 验证 pkt 是否是新 conn 开始</li><li>conn_update 更新 conn</li><li>conn_get_protoinfo: 可以忽略</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ct_l4_proto</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> *(*<span class="title">new_conn</span>)(<span class="keyword">struct</span> <span class="title">conntrack</span> *<span class="title">ct</span>, <span class="keyword">struct</span> <span class="title">dp_packet</span> *<span class="title">pkt</span>,</span></span><br><span class="line"><span class="class">                             <span class="title">long</span> <span class="title">long</span> <span class="title">now</span>, <span class="title">uint32_t</span> <span class="title">tp_id</span>);</span></span><br><span class="line">    <span class="type">bool</span> (*valid_new)(<span class="keyword">struct</span> dp_packet *pkt);</span><br><span class="line">    <span class="keyword">enum</span> <span class="title function_">ct_update_res</span> <span class="params">(*conn_update)</span><span class="params">(<span class="keyword">struct</span> conntrack *ct, <span class="keyword">struct</span> conn *conn,</span></span><br><span class="line"><span class="params">                                      <span class="keyword">struct</span> dp_packet *pkt, <span class="type">bool</span> reply,</span></span><br><span class="line"><span class="params">                                      <span class="type">long</span> <span class="type">long</span> now)</span>;</span><br><span class="line">    <span class="type">void</span> (*conn_get_protoinfo)(<span class="type">const</span> <span class="keyword">struct</span> conn *,</span><br><span class="line">                               <span class="keyword">struct</span> ct_dpif_protoinfo *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">ct_l4_proto</span> <span class="title">ct_proto_tcp</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">ct_l4_proto</span> <span class="title">ct_proto_other</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">ct_l4_proto</span> <span class="title">ct_proto_icmp4</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">ct_l4_proto</span> <span class="title">ct_proto_icmp6</span>;</span></span><br></pre></td></tr></table></figure><ul><li>other 相当于就是对 UDP 的处理, 除了 icmp icmp6 tcp 外都这样处理: 没有连接状态, 可以多路复用, 代码实现非常简单.</li></ul><p>以 tcp 为例, 实际的 conn_tcp = <code>struct conn</code> + 拖车</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_tcp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> <span class="title">up</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_peer</span> <span class="title">peer</span>[2];</span> <span class="comment">/* &#x27;conn&#x27; lock protected. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来会专注在 conntrack-tcp 的实现上</p><h2 id="conntrack-tcp"><a class="markdownIt-Anchor" href="#conntrack-tcp"></a> Conntrack-tcp</h2><p>与追踪有关的集中在 <code>tcp_new_conn</code> <code>tcp_conn_update</code> 两个函数中, 这两个函数均是操纵 <code>struct conn_tcp</code> 这个数据结构.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ct_l4_proto</span> <span class="title">ct_proto_tcp</span> =</span> &#123;</span><br><span class="line">    .new_conn = tcp_new_conn,</span><br><span class="line">    .valid_new = tcp_valid_new,</span><br><span class="line">    .conn_update = tcp_conn_update,</span><br><span class="line">    .conn_get_protoinfo = tcp_conn_get_protoinfo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据结构 <code>struct conn_tcp</code></p><ul><li>一个 conn_tcp 包含了两个方向的状态 <code>struct tcp_peer</code></li><li><code>struct tcp_peer</code> 则包含了单个方向的所有状态, 包括了窗口缩放状态;<ul><li>seqlo: 公式 II IV</li><li>seqhi: 公式 I</li><li>max_win: 公式 I II</li><li>state tcp 状态机定义的 tcp 状态</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_peer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> seqlo;   <span class="comment">/* Max sequence number sent     */</span></span><br><span class="line">    <span class="type">uint32_t</span> seqhi;   <span class="comment">/* Max the other end ACKd + win */</span></span><br><span class="line">    <span class="type">uint16_t</span> max_win; <span class="comment">/* largest window (pre scaling) */</span></span><br><span class="line">    <span class="type">uint8_t</span> wscale;   <span class="comment">/* window scaling factor        */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ct_dpif_tcp_state</span> <span class="title">state</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_tcp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> <span class="title">up</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_peer</span> <span class="title">peer</span>[2];</span> <span class="comment">/* &#x27;conn&#x27; lock protected. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>enum ct_dpif_tcp_state</code>: X 宏, 定义了全部的 tcp 的状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/openvswitch/ovs/blob/dc7663f13ce73e69e2983af77a0342f216467b31/lib/ct-dpif.h#L80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CT_DPIF_TCP_STATES \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(CLOSED) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(LISTEN) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(SYN_SENT) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(SYN_RECV) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(ESTABLISHED) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(CLOSE_WAIT) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(FIN_WAIT_1) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(CLOSING) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(LAST_ACK) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(FIN_WAIT_2) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(TIME_WAIT) \</span></span><br><span class="line"><span class="meta">    CT_DPIF_TCP_STATE(MAX_NUM)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OVS_PACKED_ENUM</span> <span class="title">ct_dpif_tcp_state</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CT_DPIF_TCP_STATE(STATE) CT_DPIF_TCPS_##STATE,</span></span><br><span class="line">    CT_DPIF_TCP_STATES</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CT_DPIF_TCP_STATE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>tcp_new_conn</code> <code>tcp_conn_update</code> 两个函数就是正确的更新 <code>struct conn_tcp</code> 的各种标志和状态.</p><h3 id="tcp_new_conn"><a class="markdownIt-Anchor" href="#tcp_new_conn"></a> <code>tcp_new_conn</code></h3><p>先来看下 <code>tcp_new_conn</code>, 这里直接上代码了…其函数实现非常清晰</p><ul><li>有可能进入 <code>tcp_new_conn</code> 的 pkt 通常是 tcp 的首个 syn 包, 但是代码中也对非 syn 包做了处理<ul><li>非 syn 包将状态标记为未知</li></ul></li><li>正常的 syn 包初始化各种状态 窗口缩放等</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp 类型的新连接</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> conn *</span><br><span class="line"><span class="title function_">tcp_new_conn</span><span class="params">(<span class="keyword">struct</span> conntrack *ct, <span class="keyword">struct</span> dp_packet *pkt, <span class="type">long</span> <span class="type">long</span> now,</span></span><br><span class="line"><span class="params">             <span class="type">uint32_t</span> tp_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_tcp</span> *<span class="title">newconn</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_header</span> *<span class="title">tcp</span> =</span> dp_packet_l4(pkt);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_peer</span> *<span class="title">src</span>, *<span class="title">dst</span>;</span></span><br><span class="line">    <span class="type">uint16_t</span> tcp_flags = TCP_FLAGS(tcp-&gt;tcp_ctl);</span><br><span class="line"></span><br><span class="line">    newconn = xzalloc(<span class="keyword">sizeof</span> *newconn); <span class="comment">// 申请内存</span></span><br><span class="line"></span><br><span class="line">    src = &amp;newconn-&gt;peer[<span class="number">0</span>];</span><br><span class="line">    dst = &amp;newconn-&gt;peer[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    src-&gt;seqlo = ntohl(get_16aligned_be32(&amp;tcp-&gt;tcp_seq));               <span class="comment">// max: seq</span></span><br><span class="line">    src-&gt;seqhi = src-&gt;seqlo + dp_packet_get_tcp_payload_length(pkt) + <span class="number">1</span>; <span class="comment">// max: ack + win</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_flags &amp; TCP_SYN) <span class="comment">// syn 包</span></span><br><span class="line">    &#123;</span><br><span class="line">        src-&gt;seqhi++;                      <span class="comment">// ack + win 最大值+1</span></span><br><span class="line">        src-&gt;wscale = tcp_get_wscale(tcp); <span class="comment">// 取窗口缩放因子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 其他情况, 理论上很少</span></span><br><span class="line">        src-&gt;wscale = CT_WSCALE_UNKNOWN;</span><br><span class="line">        dst-&gt;wscale = CT_WSCALE_UNKNOWN; <span class="comment">// 窗口缩放 状态皆为未知</span></span><br><span class="line">    &#125;</span><br><span class="line">    src-&gt;max_win = MAX(ntohs(tcp-&gt;tcp_winsz), <span class="number">1</span>); <span class="comment">// 源端窗口大小</span></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;wscale &amp; CT_WSCALE_MASK)             <span class="comment">// 源端窗口缩放因子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Remove scale factor from initial window */</span></span><br><span class="line">        <span class="type">uint8_t</span> sws = src-&gt;wscale &amp; CT_WSCALE_MASK;                     <span class="comment">// 窗口缩放因子</span></span><br><span class="line">        src-&gt;max_win = DIV_ROUND_UP((<span class="type">uint32_t</span>)src-&gt;max_win, <span class="number">1</span> &lt;&lt; sw s); <span class="comment">// 源端窗口大小移位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tcp_flags &amp; TCP_FIN) <span class="comment">// fin 包</span></span><br><span class="line">    &#123;</span><br><span class="line">        src-&gt;seqhi++; <span class="comment">// ack + win 最大值+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;seqhi = <span class="number">1</span>;                     <span class="comment">// 对端 seqhi 初始化为 1</span></span><br><span class="line">    dst-&gt;max_win = <span class="number">1</span>;                   <span class="comment">// 对端窗口大小初始化为 1</span></span><br><span class="line">    src-&gt;state = CT_DPIF_TCPS_SYN_SENT; <span class="comment">// 源端状态</span></span><br><span class="line">    dst-&gt;state = CT_DPIF_TCPS_CLOSED;   <span class="comment">// 对端状态</span></span><br><span class="line"></span><br><span class="line">    newconn-&gt;up.tp_id = tp_id;                                           <span class="comment">// tp_id</span></span><br><span class="line">    conn_init_expiration(ct, &amp;newconn-&gt;up, CT_TM_TCP_FIRST_PACKET, now); <span class="comment">// 超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;newconn-&gt;up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图渲染后就是比较丑…尝试优化 N 次就是没有满意的, 不影响信息表达, 暂时不改了.</p><pre><code class="highlight mermaid">flowchart TD
    A[开始 tcp_new_conn] --&gt; B[分配内存 newconn]
    B --&gt; C[设置源端和目的端指针]
    C --&gt; D[设置源端初始序列号 seqlo]
    D --&gt; E[计算源端序列号上限 seqhi]
    
    E --&gt; F&#123;是否为 SYN 包?&#125;
    F --&gt;|是| G[源端 seqhi++]
    G --&gt; H[获取源端窗口缩放因子]
    
    F --&gt;|否| I[设置双方窗口缩放状态为未知]
    
    H --&gt; J[设置源端最大窗口大小]
    I --&gt; J
    
    J --&gt; K&#123;窗口缩放因子是否有效?&#125;
    K --&gt;|是| L[根据缩放因子调整窗口大小]
    K --&gt;|否| M[继续处理]
    
    L --&gt; N&#123;是否为 FIN 包?&#125;
    M --&gt; N
    
    N --&gt;|是| O[源端 seqhi++]
    N --&gt;|否| P[继续处理]
    
    O --&gt; Q[初始化目的端参数]
    P --&gt; Q
    
    Q --&gt; R[设置连接状态]
    R --&gt; S[设置 tp_id]
    S --&gt; T[初始化超时时间]
    T --&gt; U[返回连接对象]</code></pre><h3 id="tcp_conn_update"><a class="markdownIt-Anchor" href="#tcp_conn_update"></a> <code>tcp_conn_update</code></h3><p><mark style="background:#ffb86CA6">注意: 能够进入 tcp_conn_update 流程的已经不是首个包了, conn 已经被创建了</mark></p><p><code>tcp_conn_update</code> 实在是其处理细节太多了…依次划分为了 4 个流程</p><ul><li>基础检查和 SYN 包处理</li><li>序列号追踪和窗口计算</li><li>状态更新逻辑</li><li>特殊情况处理</li></ul><h4 id="基础检查和-syn-包处理"><a class="markdownIt-Anchor" href="#基础检查和-syn-包处理"></a> 基础检查和 SYN 包处理</h4><pre><code class="highlight mermaid">flowchart TD
    A[开始] --&gt; B&#123;检查TCP flags是否合法&#125;
    B --&gt;|不合法| C[返回CT_UPDATE_INVALID]
    B --&gt;|合法| D&#123;是否是SYN包&#125;
    D --&gt;|是| E&#123;检查连接状态&#125;
    E --&gt;|双端&gt;=FIN_WAIT_2| F[设置双端为CLOSED&lt;br&gt;返回CT_UPDATE_NEW]
    E --&gt;|src&lt;=SYN_SENT| G[设置src为SYN_SENT&lt;br&gt;更新超时时间&lt;br&gt;返回CT_UPDATE_VALID_NEW]
    D --&gt;|否| H[继续处理]</code></pre><p>这部分主要是处理 <code>tcp_conn_update</code> 处理 syn 包的情况</p><ul><li>当 conn 收个包不是 syn 包, syn 包非进入 <code>tcp_conn_update</code> <span id="^3xaz" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^3xaz</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 这个函数是在 conn 已存在以后才会调用; 通常单独的 syn 包回调用到 tcp_new_conn 而不是这里</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> ct_update_res</span><br><span class="line"><span class="title function_">tcp_conn_update</span><span class="params">(<span class="keyword">struct</span> conntrack *ct, <span class="keyword">struct</span> conn *conn_,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> dp_packet *pkt, <span class="type">bool</span> reply, <span class="type">long</span> <span class="type">long</span> now)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_tcp</span> *<span class="title">conn</span> =</span> conn_tcp_cast(conn_);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_header</span> *<span class="title">tcp</span> =</span> dp_packet_l4(pkt);</span><br><span class="line">    <span class="comment">/* The peer that sent &#x27;pkt&#x27; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_peer</span> *<span class="title">src</span> =</span> &amp;conn-&gt;peer[reply ? <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">    <span class="comment">/* The peer that should receive &#x27;pkt&#x27; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_peer</span> *<span class="title">dst</span> =</span> &amp;conn-&gt;peer[reply ? <span class="number">0</span> : <span class="number">1</span>];</span><br><span class="line">    <span class="type">uint8_t</span> sws = <span class="number">0</span>, dws = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint16_t</span> tcp_flags = TCP_FLAGS(tcp-&gt;tcp_ctl);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> win = ntohs(tcp-&gt;tcp_winsz);</span><br><span class="line">    <span class="type">uint32_t</span> ack, end, seq, orig_seq;</span><br><span class="line">    <span class="type">uint32_t</span> p_len = dp_packet_get_tcp_payload_length(pkt); <span class="comment">// tcp 包长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_invalid_flags(tcp_flags))<span class="comment">// 确保不是非法的 TCP flags</span></span><br><span class="line">    &#123;</span><br><span class="line">        COVERAGE_INC(conntrack_invalid_tcp_flags);</span><br><span class="line">        <span class="keyword">return</span> CT_UPDATE_INVALID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((tcp_flags &amp; (TCP_SYN | TCP_ACK)) == TCP_SYN) <span class="comment">// syn 包</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dst-&gt;state &gt;= CT_DPIF_TCPS_FIN_WAIT_2 &amp;&amp; src-&gt;state &gt;= CT_DPIF_TCPS_FIN_WAIT_2)</span><br><span class="line">        &#123;                                                  <span class="comment">// 原连接已接近关闭情况下重连</span></span><br><span class="line">            src-&gt;state = dst-&gt;state = CT_DPIF_TCPS_CLOSED; <span class="comment">// 清理原连接</span></span><br><span class="line">            <span class="keyword">return</span> CT_UPDATE_NEW;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (src-&gt;state &lt;= CT_DPIF_TCPS_SYN_SENT) <span class="comment">// 其他情况, conn 状态小于等于 SYN_SENT</span></span><br><span class="line">        &#123;                                             <span class="comment">// 可能是重复的 syn 包, 也可能是新连接</span></span><br><span class="line">            src-&gt;state = CT_DPIF_TCPS_SYN_SENT;</span><br><span class="line">            conn_update_expiration(ct, &amp;conn-&gt;up, CT_TM_TCP_FIRST_PACKET, now);</span><br><span class="line">            <span class="keyword">return</span> CT_UPDATE_VALID_NEW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="序列号追踪和窗口计算"><a class="markdownIt-Anchor" href="#序列号追踪和窗口计算"></a> 序列号追踪和窗口计算</h4><pre><code class="highlight mermaid">flowchart TD
    A[计算序列号和窗口] --&gt; B&#123;是否是首次处理该方向&#125;
    B --&gt;|是| C[初始化序列号追踪]
    C --&gt; D[处理窗口缩放]
    D --&gt; E[计算seq_hi]
    B --&gt;|否| F[常规序列号计算]
    F --&gt; G[处理特殊情况的ACK]
    G --&gt; H[无数据包特殊处理]
    H --&gt; I[计算ackskew]</code></pre><p>取窗口缩放 这里也被 <a href="/jasper/20241123105738/#^3xaz">首个包非 syn</a> 这种情况影响到了;</p><p>流程进入首次处理该方向时, 对于 新建或非稳定状态的连接 关闭了 严格 ack 检查 (check_ackskew = false)</p><p>非首次处理这个方向时的 ack 特殊情况</p><ul><li>pkt 干脆没有 ack, 直接让其通过检查 (<code>ack = dst-&gt;seqlo;</code>)</li><li>ack = 0. 但是设置了 ack 和 rst, 可能是一些协议栈实现中对 syn 超时发送 (<code>ack = dst-&gt;seqlo;</code>)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (src-&gt;wscale &amp; CT_WSCALE_FLAG &amp;&amp; dst-&gt;wscale &amp; CT_WSCALE_FLAG &amp;&amp; !(tcp_flags &amp; TCP_SYN)) </span><br><span class="line">&#123; <span class="comment">// 窗口缩放是在 syn 包协商, 这里是已经协商完毕直接取值</span></span><br><span class="line">    sws = src-&gt;wscale &amp; CT_WSCALE_MASK;</span><br><span class="line">    dws = dst-&gt;wscale &amp; CT_WSCALE_MASK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (src-&gt;wscale &amp; CT_WSCALE_UNKNOWN &amp;&amp; dst-&gt;wscale &amp; CT_WSCALE_UNKNOWN &amp;&amp; !(tcp_flags &amp; TCP_SYN))</span><br><span class="line">&#123; <span class="comment">// 不是 syn 包 窗口缩放还没有协商. 可能触发创建连接建立的不是 syn 包</span></span><br><span class="line">    sws = TCP_MAX_WSCALE;</span><br><span class="line">    dws = TCP_MAX_WSCALE; <span class="comment">// 保守的取最大值 确保不会限制连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sequence tracking algorithm from Guido van Rooij&#x27;s paper:</span></span><br><span class="line"><span class="comment"> *   http://www.madison-gurkha.com/publications/tcp_filtering/</span></span><br><span class="line"><span class="comment"> *      tcp_filtering.ps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">orig_seq = seq = ntohl(get_16aligned_be32(&amp;tcp-&gt;tcp_seq)); <span class="comment">// seq</span></span><br><span class="line"><span class="type">bool</span> check_ackskew = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (src-&gt;state &lt; CT_DPIF_TCPS_SYN_SENT) <span class="comment">// 比 SYN_SENT 状态还小, orign 方向第一个包, 初始化序列号追踪</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* First packet from this end. Set its state */</span></span><br><span class="line">    </span><br><span class="line">    ack = ntohl(get_16aligned_be32(&amp;tcp-&gt;tcp_ack)); <span class="comment">// ack</span></span><br><span class="line"></span><br><span class="line">    end = seq + p_len; <span class="comment">// seq + n</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_flags &amp; TCP_SYN) <span class="comment">// syn 包, 也就是首个包不是 syn 包</span></span><br><span class="line">    &#123;</span><br><span class="line">        end++; <span class="comment">// seq + n + 1</span></span><br><span class="line">        <span class="keyword">if</span> (dst-&gt;wscale &amp; CT_WSCALE_FLAG) <span class="comment">// 对端设置了 窗口缩放</span></span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;wscale = tcp_get_wscale(tcp); <span class="comment">// tcp 可选项 提取窗口缩放</span></span><br><span class="line">            <span class="keyword">if</span> (src-&gt;wscale &amp; CT_WSCALE_FLAG)  <span class="comment">// orign 方向 设置窗口缩放?</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Remove scale factor from initial window */</span></span><br><span class="line">                sws = src-&gt;wscale &amp; CT_WSCALE_MASK;          <span class="comment">// 缩放因子</span></span><br><span class="line">                win = DIV_ROUND_UP((<span class="type">uint32_t</span>)win, <span class="number">1</span> &lt;&lt; sws); <span class="comment">// 窗口大小移位</span></span><br><span class="line">                dws = dst-&gt;wscale &amp; CT_WSCALE_MASK;          <span class="comment">// 对端窗口缩放因子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; <span class="comment">// 没有窗口缩放</span></span><br><span class="line">                <span class="comment">/* fixup other window */</span></span><br><span class="line">                dst-&gt;max_win &lt;&lt;= dst-&gt;wscale &amp; CT_WSCALE_MASK;</span><br><span class="line">                <span class="comment">/* in case of a retrans SYN|ACK */</span></span><br><span class="line">                dst-&gt;wscale = <span class="number">0</span>; <span class="comment">// 对端窗口缩放因子清零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tcp_flags &amp; TCP_FIN) <span class="comment">// fin 包</span></span><br><span class="line">    &#123;</span><br><span class="line">        end++; <span class="comment">// end +1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    src-&gt;seqlo = seq;                   <span class="comment">// orign 方向最大 seq</span></span><br><span class="line">    src-&gt;state = CT_DPIF_TCPS_SYN_SENT; <span class="comment">// orign 方向状态</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * May need to slide the window (seqhi may have been set by</span></span><br><span class="line"><span class="comment">     * the crappy stack check or if we picked up the connection</span></span><br><span class="line"><span class="comment">     * after establishment)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// src-&gt;seqhi == 1 相当于是新连接</span></span><br><span class="line">    <span class="comment">// SEQ_GEQ(end + MAX(1, dst-&gt;max_win &lt;&lt; dws), src-&gt;seqhi) 当前包的结束序列号 + win &gt; 源端最大的 seq, 需要更新 seqhi</span></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;seqhi == <span class="number">1</span> || SEQ_GEQ(end + MAX(<span class="number">1</span>, dst-&gt;max_win &lt;&lt; dws), src-&gt;seqhi))</span><br><span class="line">    &#123;</span><br><span class="line">        src-&gt;seqhi = end + MAX(<span class="number">1</span>, dst-&gt;max_win &lt;&lt; dws); <span class="comment">// 更新 seqhi</span></span><br><span class="line">        <span class="comment">/* We are either picking up a new connection or a connection which</span></span><br><span class="line"><span class="comment">         * was already in place.  We are more permissive in terms of</span></span><br><span class="line"><span class="comment">         * ackskew checking in these cases.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 这个注释说明了为什么这里不严格检查 ack</span></span><br><span class="line">        <span class="comment">// 新连接 或 已有连接但是需要更新 最大 seq 的; 这两种情况下 序列号尚不稳定. 因此 ackskew 检查不严格</span></span><br><span class="line">        check_ackskew = <span class="literal">false</span>; <span class="comment">// 不严格检查 ack</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (win &gt; src-&gt;max_win)</span><br><span class="line">    &#123;</span><br><span class="line">        src-&gt;max_win = win; <span class="comment">// orign 方向最大窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ack = ntohl(get_16aligned_be32(&amp;tcp-&gt;tcp_ack)); <span class="comment">// 取 ack</span></span><br><span class="line">    end = seq + p_len;                              <span class="comment">// 取结束序列号</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_flags &amp; TCP_SYN)                        <span class="comment">// syn 包</span></span><br><span class="line">    &#123;</span><br><span class="line">        end++; <span class="comment">// seq + n + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tcp_flags &amp; TCP_FIN) <span class="comment">// fin 包</span></span><br><span class="line">    &#123;</span><br><span class="line">        end++; <span class="comment">// seq + n + 1 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((tcp_flags &amp; TCP_ACK) == <span class="number">0</span>) <span class="comment">// 没有 ack or ack = 0 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Let it pass through the ack skew check */</span> </span><br><span class="line">    <span class="comment">// 没有 ack , 作弊让其通过 ack 检查, 都没有检查个啥</span></span><br><span class="line">    ack = dst-&gt;seqlo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ack = 0. 但是设置了 ack 和 rst</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((ack == <span class="number">0</span> &amp;&amp; (tcp_flags &amp; (TCP_ACK | TCP_RST)) == (TCP_ACK | TCP_RST))</span><br><span class="line">         <span class="comment">/* broken tcp stacks do not set ack */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Many stacks (ours included) will set the ACK number in an</span></span><br><span class="line"><span class="comment">     * FIN|ACK if the SYN times out -- no sequence to ACK. */</span></span><br><span class="line">    <span class="comment">// 一些堆栈(包括我们的)在 SYN 超时时会在 FIN|ACK 中设置 ACK 号码 -- 没有序列号来 ACK</span></span><br><span class="line">    <span class="comment">// 用来处理一些现实的 tcp 协议栈实现</span></span><br><span class="line">    ack = dst-&gt;seqlo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seq == end) <span class="comment">// pkt 内没有有效数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Ease sequencing restrictions on no data packets */</span></span><br><span class="line">    seq = src-&gt;seqlo;</span><br><span class="line">    end = seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ackskew = check_ackskew ? dst-&gt;seqlo - ack : <span class="number">0</span>; <span class="comment">// 不检查 ack 就取 0 , 检查就取 dst-&gt;seqlo - ack</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="状态更新逻辑"><a class="markdownIt-Anchor" href="#状态更新逻辑"></a> 状态更新逻辑</h4><pre><code class="highlight mermaid">flowchart TD
    A[开始状态更新] --&gt; B&#123;序列号检查是否通过&#125;
    B --&gt;|通过| C[更新窗口和序列号]
    C --&gt; D[状态转换处理]
    D --&gt; E&#123;检查SYN标志&#125;
    E --&gt;|有| F[更新SYN状态]
    D --&gt; G&#123;检查FIN标志&#125;
    G --&gt;|有| H[更新FIN状态]
    D --&gt; I&#123;检查ACK标志&#125;
    I --&gt;|有| J[更新ACK状态]
    D --&gt; K&#123;检查RST标志&#125;
    K --&gt;|有| L[设置TIME_WAIT]
    D --&gt; M[更新连接超时时间]</code></pre><p>正常连接状态更新最核心的部分;</p><p>这里的状态检查中的 seq 和 ack, 对应原论文公式 I II, 做了进一步拓展:</p><p>状态检测</p><ul><li>首先这里的 MAXACKWINDOW = 65535 + 1500 , 比原论文又 +1500 确保, ack 检查范围足够大</li><li>检测 seq 对应公式 I</li><li>ack 回退不能超过 1 个 MAXACKWINDOW</li><li>ack 最大也不能超过 1 个 MAXACKWINDOW(带缩放)</li><li>rst 包下 seq 检测相当严格,只能在 ±1 范围内</li></ul><p>之后的状态和超时时间更新, 严格按照 tcp 状态机处理.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXACKWINDOW (0xffff + 1500) <span class="comment">/* 1500 is an arbitrary fudge factor */</span> <span class="comment">// 在原论文最大窗口基础上再 +1500</span></span></span><br><span class="line">    <span class="keyword">if</span> ((SEQ_GEQ(src-&gt;seqhi, end)                                            <span class="comment">// 对应公式 I</span></span><br><span class="line">         <span class="comment">/* Last octet inside other&#x27;s window space */</span></span><br><span class="line">         &amp;&amp; SEQ_GEQ(seq, src-&gt;seqlo - (dst-&gt;max_win &lt;&lt; dws)) <span class="comment">// 对应公式 II</span></span><br><span class="line">         <span class="comment">/* Retrans: not more than one window back */</span></span><br><span class="line">         &amp;&amp; (ackskew &gt;= -MAXACKWINDOW) <span class="comment">// ack 最小也不应该小于 -MAXACKWINDOW | 最小不能先前回退一个 MAXACKWINDOW</span></span><br><span class="line">         <span class="comment">/* Acking not more than one reassembled fragment backwards */</span></span><br><span class="line">         &amp;&amp; (ackskew &lt;= (MAXACKWINDOW &lt;&lt; sws)) <span class="comment">// ack 最大也不应该大于 MAXACKWINDOW &lt;&lt; sws(带窗口缩放) | 最大不能超过 MAXACKWINDOW(缩放后)</span></span><br><span class="line">         <span class="comment">/* Acking not more than one window forward */</span></span><br><span class="line">         <span class="comment">// rst 包?                 seq == 最大 send 过的最大 seq 或  seq == 最大 send 过的最大 seq + 1 或 seq + 1 == 最大 send 过的最大 seq</span></span><br><span class="line">         <span class="comment">// rst 包的话 检查严格, 可能的话就是 +-1 范围内的检查</span></span><br><span class="line">         &amp;&amp; ((tcp_flags &amp; TCP_RST) == <span class="number">0</span> || orig_seq == src-&gt;seqlo || (orig_seq == src-&gt;seqlo + <span class="number">1</span>) || (orig_seq + <span class="number">1</span> == src-&gt;seqlo))) ||</span><br><span class="line">        tcp_bypass_seq_chk(ct))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Require an exact/+1 sequence match on resets when possible */</span></span><br><span class="line">        <span class="comment">// 全部成功, 那么可以开始更新状态了;</span></span><br><span class="line">        <span class="comment">/* update max window */</span> <span class="comment">// 源 最大窗口</span></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;max_win &lt; win)</span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;max_win = win;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* synchronize sequencing */</span> <span class="comment">// 源 seq</span></span><br><span class="line">        <span class="keyword">if</span> (SEQ_GT(end, src-&gt;seqlo))</span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;seqlo = end; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* slide the window of what the other end can send */</span></span><br><span class="line">        <span class="keyword">if</span> (SEQ_GEQ(ack + (win &lt;&lt; sws), dst-&gt;seqhi)) <span class="comment">//</span></span><br><span class="line">        &#123;</span><br><span class="line">            dst-&gt;seqhi = ack + MAX((win &lt;&lt; sws), <span class="number">1</span>); <span class="comment">// 对端窗口 (缩放) | 公式II</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update states */</span></span><br><span class="line">        <span class="comment">// syn 包               且  源状态 &lt; SYN_SENT</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_flags &amp; TCP_SYN &amp;&amp; src-&gt;state &lt; CT_DPIF_TCPS_SYN_SENT)</span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;state = CT_DPIF_TCPS_SYN_SENT; <span class="comment">// 源 syn 包已发送</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fin 包               且  源状态 &lt; CLOSING</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_flags &amp; TCP_FIN &amp;&amp; src-&gt;state &lt; CT_DPIF_TCPS_CLOSING)</span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;state = CT_DPIF_TCPS_CLOSING; <span class="comment">// 源 方向关闭中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ack 包</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_flags &amp; TCP_ACK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dst-&gt;state == CT_DPIF_TCPS_SYN_SENT) <span class="comment">// 对端状态为 SYN_SENT</span></span><br><span class="line">            &#123;</span><br><span class="line">                dst-&gt;state = CT_DPIF_TCPS_ESTABLISHED; <span class="comment">// 3次握手完成, 连接建立</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dst-&gt;state == CT_DPIF_TCPS_CLOSING) <span class="comment">// 对端状态为 CLOSING, 等待确认关闭</span></span><br><span class="line">            &#123;</span><br><span class="line">                dst-&gt;state = CT_DPIF_TCPS_FIN_WAIT_2; <span class="comment">// 进入 fun_wait_2 状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tcp_flags &amp; TCP_RST) <span class="comment">// rst 包</span></span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;state = dst-&gt;state = CT_DPIF_TCPS_TIME_WAIT; <span class="comment">// 双方均进入 超时</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两端都已经处于 FIN_WAIT_2 状态 或 更高, </span></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;state &gt;= CT_DPIF_TCPS_FIN_WAIT_2 &amp;&amp; dst-&gt;state &gt;= CT_DPIF_TCPS_FIN_WAIT_2)</span><br><span class="line">        &#123;</span><br><span class="line">            conn_update_expiration(ct, &amp;conn-&gt;up, CT_TM_TCP_CLOSED, now); <span class="comment">// 可以关闭了, 更新超时时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  两端都处于 CLOSING 状态 或 更高</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (src-&gt;state &gt;= CT_DPIF_TCPS_CLOSING &amp;&amp; dst-&gt;state &gt;= CT_DPIF_TCPS_CLOSING)</span><br><span class="line">        &#123;</span><br><span class="line">            conn_update_expiration(ct, &amp;conn-&gt;up, CT_TM_TCP_FIN_WAIT, now); <span class="comment">// 按照 FIN_WAIT 更新超时时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任一方未完成连接建立</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (src-&gt;state &lt; CT_DPIF_TCPS_ESTABLISHED || dst-&gt;state &lt; CT_DPIF_TCPS_ESTABLISHED)</span><br><span class="line">        &#123;</span><br><span class="line">            conn_update_expiration(ct, &amp;conn-&gt;up, CT_TM_TCP_OPENING, now); <span class="comment">// 按照 OPENING 更新超时时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任意一方开始关闭连接</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (src-&gt;state &gt;= CT_DPIF_TCPS_CLOSING || dst-&gt;state &gt;= CT_DPIF_TCPS_CLOSING)</span><br><span class="line">        &#123;</span><br><span class="line">            conn_update_expiration(ct, &amp;conn-&gt;up, CT_TM_TCP_CLOSING, now); <span class="comment">// 开始关闭的超时时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 连接稳定状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            conn_update_expiration(ct, &amp;conn-&gt;up, CT_TM_TCP_ESTABLISHED, now); <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="特殊情况处理"><a class="markdownIt-Anchor" href="#特殊情况处理"></a> 特殊情况处理</h4><pre><code class="highlight mermaid">flowchart TD
    A[特殊情况检查] --&gt; B&#123;是否满足特殊条件&#125;
    B --&gt;|是| C[保守更新窗口]
    C --&gt; D[保守更新序列号]
    D --&gt; E[处理FIN标志]
    E --&gt; F[处理RST标志]
    B --&gt;|否| G[序列号检查失败]
    G --&gt; H[返回CT_UPDATE_INVALID]
    C --&gt; I[返回CT_UPDATE_VALID]</code></pre><p>处理完毕正常就该处理异常情况了, 有 3 种<mark style="background:#fff3A3A6">特殊网络行为</mark></p><ol><li>非标准 TCP 实现：在接收 ACK 之前重复发送 SYN</li><li>网络设备重启：如防火墙或 NAT 设备重启后重新追踪已建立的连接</li><li>连接关闭后的异常行为：如某些系统 (Solaris) 在连接关闭后发送额外的 ACK 或 FIN 包</li></ol><p>这部分处理必须非常谨慎… 因为 ddos 的包也会进入这里的处理流程, 要限制其造成的影响.</p><p>这里会保守更新状态信息, 这里不更新 ttl 等.<br>对于<mark style="background:#fff3A3A6">特殊网络行为</mark> 对端会正常回复,然后之后流程就进入到正常状态更新了. 对于 ddos 流量 异常连接超时后直接自行关闭了, 其造成影响被降低到最低.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这会是一些特殊的情况了</span></span><br><span class="line">    <span class="comment">//         对端还未发送 syn                    或 对端已经处于 fin_wait_2 或更高         或 源端已经处于 fin_wait_2 或更高          且   pkt 的结束序号在窗口的 +方向还往后</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((dst-&gt;state &lt; CT_DPIF_TCPS_SYN_SENT || dst-&gt;state &gt;= CT_DPIF_TCPS_FIN_WAIT_2 || src-&gt;state &gt;= CT_DPIF_TCPS_FIN_WAIT_2) &amp;&amp; SEQ_GEQ(src-&gt;seqhi + MAXACKWINDOW, end)</span><br><span class="line">             <span class="comment">/* Within a window forward of the originating packet */</span></span><br><span class="line">             <span class="comment">// pkt 的结束序号在窗口 -方向还往前</span></span><br><span class="line">             &amp;&amp; SEQ_GEQ(seq, src-&gt;seqlo - MAXACKWINDOW))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Within a window backward of the originating packet */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This currently handles three situations:</span></span><br><span class="line"><span class="comment">         *  1) Stupid stacks will shotgun SYNs before their peer</span></span><br><span class="line"><span class="comment">         *     replies.</span></span><br><span class="line"><span class="comment">         *  2) When PF catches an already established stream (the</span></span><br><span class="line"><span class="comment">         *     firewall rebooted, the state table was flushed, routes</span></span><br><span class="line"><span class="comment">         *     changed...)</span></span><br><span class="line"><span class="comment">         *  3) Packets get funky immediately after the connection</span></span><br><span class="line"><span class="comment">         *     closes (this should catch Solaris spurious ACK|FINs</span></span><br><span class="line"><span class="comment">         *     that web servers like to spew after a close)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This must be a little more careful than the above code</span></span><br><span class="line"><span class="comment">         * since packet floods will also be caught here. We don&#x27;t</span></span><br><span class="line"><span class="comment">         * update the TTL here to mitigate the damage of a packet</span></span><br><span class="line"><span class="comment">         * flood and so the same code can handle awkward establishment</span></span><br><span class="line"><span class="comment">         * and a loosened connection close.</span></span><br><span class="line"><span class="comment">         * In the establishment case, a correct peer response will</span></span><br><span class="line"><span class="comment">         * validate the connection, go through the normal state code</span></span><br><span class="line"><span class="comment">         * and keep updating the state TTL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 说了有 3 种特殊情况: </span></span><br><span class="line">        <span class="comment">// 1. 一些古怪的 tcp 协议栈实现, 会在对端回复 ack 之前,重复发送 syn</span></span><br><span class="line">        <span class="comment">// 2. 带 connect 实体(防火墙 nat表 ...)重启了, 重新对已建立的连接开始追踪</span></span><br><span class="line">        <span class="comment">// 3. 连接关闭后的异常包, 例如 Solaris 会在关闭连接后继续发送 ack|fin 包</span></span><br><span class="line">        <span class="comment">// 这部分代码必须非常谨慎... 因为 ddos 的包也会进入这里的处理流程</span></span><br><span class="line">        <span class="comment">// 这里不更新 ttl 以减少 ddos 的影响, 异常连接超时后直接自行关闭了.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保守更新状态信息, 正常连接 对端会正常回复,然后之后流程就进入到正常状态更新了.</span></span><br><span class="line">        <span class="comment">/* update max window */</span></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;max_win &lt; win)</span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;max_win = win; <span class="comment">// 源端最大窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* synchronize sequencing */</span></span><br><span class="line">        <span class="keyword">if</span> (SEQ_GT(end, src-&gt;seqlo))</span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;seqlo = end; <span class="comment">// 源端最大 seq</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* slide the window of what the other end can send */</span></span><br><span class="line">        <span class="keyword">if</span> (SEQ_GEQ(ack + (win &lt;&lt; sws), dst-&gt;seqhi))</span><br><span class="line">        &#123;</span><br><span class="line">            dst-&gt;seqhi = ack + MAX((win &lt;&lt; sws), <span class="number">1</span>); <span class="comment">// 最大可接收的窗口范围更新</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Cannot set dst-&gt;seqhi here since this could be a shotgunned</span></span><br><span class="line"><span class="comment">         * SYN and not an already established connection.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 不能在这 设置 dst-&gt;seqhi, 因为这可能是一个重复的 syn 包, 而不是已经建立的连接</span></span><br><span class="line">        <span class="comment">// 怪不得作者吐槽一些 tcp 协议栈实现...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_flags &amp; TCP_FIN &amp;&amp; src-&gt;state &lt; CT_DPIF_TCPS_CLOSING) <span class="comment">// fin 包</span></span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;state = CT_DPIF_TCPS_CLOSING; <span class="comment">// 源端关闭中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_flags &amp; TCP_RST) <span class="comment">// rst 包</span></span><br><span class="line">        &#123;</span><br><span class="line">            src-&gt;state = dst-&gt;state = CT_DPIF_TCPS_TIME_WAIT; <span class="comment">// 双方进入超时状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 超过了 +- 一个最大窗口了, 直接扔了</span></span><br><span class="line">    &#123;</span><br><span class="line">        COVERAGE_INC(conntrack_tcp_seq_chk_failed);</span><br><span class="line">        <span class="keyword">return</span> CT_UPDATE_INVALID; <span class="comment">// 丢弃, 更新连接状态失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CT_UPDATE_VALID; <span class="comment">// 更新有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与原论文对比"><a class="markdownIt-Anchor" href="#与原论文对比"></a> 与原论文对比</h2><p>最后看一下 ovs 实现的 conntrack 与原论文的对比</p><p>ovs 实现了完整的 tcp 状态机, 借助 tcp 状态更加精确的判断 pkt 是否合法, 顺带设置更合适的超时时间.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_peer</span> &#123;</span></span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ct_dpif_tcp_state</span> <span class="title">state</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了额外跳过 seq 和 ack 检查 机制, 这可能让其在实际中更加实用.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check_ackskew = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">tcp_bypass_seq_chk(<span class="keyword">struct</span> conntrack *ct)</span><br></pre></td></tr></table></figure><p>将用于 ack 检查的 MAXACKWINDOW 又 +1500, 额外的容错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXACKWINDOW (0xffff + 1500)    <span class="comment">/* 1500 is an arbitrary fudge factor */</span></span></span><br></pre></td></tr></table></figure><p>支持了窗口缩放, 这一点很重要,对于跨洋线路,窗口缩放非常实用.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (src-&gt;wscale &amp; CT_WSCALE_FLAG &amp;&amp; dst-&gt;wscale &amp; CT_WSCALE_FLAG &amp;&amp; !(tcp_flags &amp; TCP_SYN)) &#123;</span><br><span class="line">    sws = src-&gt;wscale &amp; CT_WSCALE_MASK;</span><br><span class="line">    dws = dst-&gt;wscale &amp; CT_WSCALE_MASK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (src-&gt;wscale &amp; CT_WSCALE_UNKNOWN &amp;&amp; dst-&gt;wscale &amp; CT_WSCALE_UNKNOWN &amp;&amp; !(tcp_flags &amp; TCP_SYN)) &#123;</span><br><span class="line">    sws = TCP_MAX_WSCALE;</span><br><span class="line">    dws = TCP_MAX_WSCALE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还有其他的代码 省略</span></span><br></pre></td></tr></table></figure><p><mark style="background:#fff3A3A6">特殊网络行为的处理</mark></p><ul><li>这里也对应 <a href="/jasper/20241117125429/#^bx7v">filter 重启</a> 的实现: conntrack 的实体重启后如何追踪已建立连接.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((dst-&gt;state &lt; CT_DPIF_TCPS_SYN_SENT || dst-&gt;state &gt;= CT_DPIF_TCPS_FIN_WAIT_2 || src-&gt;state &gt;= CT_DPIF_TCPS_FIN_WAIT_2) &amp;&amp; SEQ_GEQ(src-&gt;seqhi + MAXACKWINDOW, end)</span><br><span class="line">         &amp;&amp; SEQ_GEQ(seq, src-&gt;seqlo - MAXACKWINDOW))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 特殊情况处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>这篇是在 GPT 完整辅助下完成的, 具体是在 代码阅读完毕, 添加注释后, 尝试全程使用 GPT 辅助:</p><ul><li>更加以往 blog 进行章节划分;</li><li>流程图划分 &amp; 绘制: 这个节约了大量时间, 同等规模自行绘制至少需要额外 4H 才能完成.</li><li>对草稿的校对, 名词 事实 表达等, 纠正了一些名词.</li></ul><p>总体评估: 只在撰写环境, 相对于没有 GPT 节约时间在 8H 左右.</p><p>说实在的这篇欠稿了好久, 看看草稿箱,还有好多… 不看长远,只看 2 天, 继续调整,继续完成.</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Jasper</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jasper1024.com/jasper/20241123105738/" title="OVS conntrack-tcp 源码阅读">https://jasper1024.com/jasper/20241123105738/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-nav"><div class="post-nav-item"><a href="/jasper/20241121094538/" rel="prev" title="Gtest 中 Mock C Function 那点事"><i class="fa fa-angle-left"></i> Gtest 中 Mock C Function 那点事</a></div><div class="post-nav-item"><a href="/jasper/20241205103309/" rel="next" title="XDP-2-xdp-tutorial-base">XDP-2-xdp-tutorial-base <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-disqus">disqus</a></li><li class="tab"><a href="#comment-utterances">utterances</a></li></ul><div class="tab-content"><div class="tab-pane disqus" id="comment-disqus"><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><div class="tab-pane utterances" id="comment-utterances"><div class="comments utterances-container"></div></div></div></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">JasperHale</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">20:54</span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phc3Blci0xMDI0" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"jasper1024","count":true,"i18n":{"disqus":"disqus"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/disqus.min.js" defer></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Jasper-1024/blog_discuss","issue_term":"pathname","theme":"github-dark"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/utterances.min.js" defer></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>