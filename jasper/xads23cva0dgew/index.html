<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="M2t8cZr5nIzHmltyt7Utj3nWYxNyNkCzFyigXBHkGUs"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"jasper1024.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"vs2015","dark":"vs2015"},"prism":{"light":"prism-vsc-dark-plus","dark":"prism-vsc-dark-plus"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"disqus","order":-1},"utteranc":{"text":"utteranc","order":-2}}},"stickytabs":true,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/config.min.js" defer></script><meta name="description" content="rust 基础总结 12023-08-29 初始化"><meta property="og:type" content="article"><meta property="og:title" content="Rust 基础入门"><meta property="og:url" content="https://jasper1024.com/jasper/xads23cva0dgew/index.html"><meta property="og:site_name" content="默"><meta property="og:description" content="rust 基础总结 12023-08-29 初始化"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-08-29T23:14:00.000Z"><meta property="article:modified_time" content="2023-09-30T16:14:02.000Z"><meta property="article:author" content="Jasper"><meta property="article:tag" content="rust"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jasper1024.com/jasper/xads23cva0dgew/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jasper1024.com/jasper/xads23cva0dgew/","path":"jasper/xads23cva0dgew/","title":"Rust 基础入门"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Rust 基础入门 | 默</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-207687331-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-207687331-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/analytics/google-analytics.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/comments.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/utils.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/motion.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/sidebar.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/next-boot.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/pjax.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/search/local-search.min.js" defer></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/pdf.min.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.10.1/dist/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/mermaid.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/fancybox.min.js" defer></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ItayEcWO7OsLFKF2Y8SsAYG1-MdYXbMMI","app_key":"18UBQFmJXXcOQFebLovT36lh","server_url":null,"security":false}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/statistics/lean-analytics.min.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/quicklink@3.0.1/dist/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://jasper1024.com/jasper/xads23cva0dgew/"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/quicklink.min.js" defer></script><link rel="stylesheet" href="source/_data/callout_blocks.css"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="默" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">默</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">生存是唯一的长路</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">45</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">330</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">65</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-comments fa-fw"></i>留言</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%AF%AD"><span class="nav-number">1.</span> <span class="nav-text">导语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E8%83%83%E8%8F%9C"><span class="nav-number">2.</span> <span class="nav-text">开胃菜</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="nav-number">3.</span> <span class="nav-text">编译器行为</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5-%E5%A4%8D%E6%9D%82%E7%BB%93%E6%9E%84%E7%9A%84%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA"><span class="nav-number">3.1.</span> <span class="nav-text">(插入) 复杂结构的打印输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">变量绑定与解构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">浮点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nan"><span class="nav-number">5.3.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97"><span class="nav-number">5.4.</span> <span class="nav-text">运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97"><span class="nav-number">5.5.</span> <span class="nav-text">序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%90%86%E6%95%B0-%E5%A4%8D%E6%95%B0"><span class="nav-number">5.6.</span> <span class="nav-text">有理数 复数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6-%E5%B8%83%E5%B0%94-%E5%8D%95%E5%85%83"><span class="nav-number">6.</span> <span class="nav-text">字符 布尔 单元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">语句 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">发散函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83-%E4%B8%8E-%E5%80%9F%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">所有权 与 借用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">9.1.</span> <span class="nav-text">所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8-%E5%92%8C-%E5%80%9F%E7%94%A8"><span class="nav-number">9.2.</span> <span class="nav-text">引用 和 借用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">复合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%92%8C-go-%E5%BE%88%E5%83%8F"><span class="nav-number">10.1.</span> <span class="nav-text">字符串 (和 Go 很像)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-number">10.1.1.</span> <span class="nav-text">字符串操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E5%9D%91"><span class="nav-number">10.1.2.</span> <span class="nav-text">小坑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">10.1.3.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84"><span class="nav-number">10.2.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">10.3.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">10.4.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null-%E5%A4%84%E7%90%86"><span class="nav-number">10.4.1.</span> <span class="nav-text">Null 处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84-array"><span class="nav-number">10.5.</span> <span class="nav-text">数组 (不可变数组 array)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">11.</span> <span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">12.</span> <span class="nav-text">模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#match-if-let"><span class="nav-number">12.1.</span> <span class="nav-text">Match &#x2F; if Let</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84-option"><span class="nav-number">12.2.</span> <span class="nav-text">解构 Option</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">12.3.</span> <span class="nav-text">模式适用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">12.3.1.</span> <span class="nav-text">哪里用到了模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%A8%A1%E5%BC%8F%E5%88%97%E8%A1%A8"><span class="nav-number">12.4.</span> <span class="nav-text">全模式列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84"><span class="nav-number">12.4.1.</span> <span class="nav-text">解构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E5%BE%81"><span class="nav-number">14.</span> <span class="nav-text">泛型和特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">14.1.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const-%E6%B3%9B%E5%9E%8B"><span class="nav-number">14.1.1.</span> <span class="nav-text">Const 泛型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81"><span class="nav-number">14.2.</span> <span class="nav-text">特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E5%8F%82"><span class="nav-number">14.2.1.</span> <span class="nav-text">入参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E"><span class="nav-number">14.2.2.</span> <span class="nav-text">返回</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-2"><span class="nav-number">14.2.3.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">14.2.4.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">14.3.</span> <span class="nav-text">特征对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91"><span class="nav-number">14.3.1.</span> <span class="nav-text">动态分发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#self-and-self"><span class="nav-number">14.3.2.</span> <span class="nav-text">Self and Self</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81-2"><span class="nav-number">14.4.</span> <span class="nav-text">特征 2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.4.1.</span> <span class="nav-text">关联类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">14.4.2.</span> <span class="nav-text">默认泛型类型参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95-%E8%B0%83%E7%94%A8%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="nav-number">14.4.3.</span> <span class="nav-text">完全限定语法 (调用同名函数&#x2F;方法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E7%9A%84%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F"><span class="nav-number">14.4.4.</span> <span class="nav-text">特征的特征约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newtype"><span class="nav-number">14.4.5.</span> <span class="nav-text">Newtype</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-vector"><span class="nav-number">15.1.</span> <span class="nav-text">动态数组 Vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">15.1.1.</span> <span class="nav-text">排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashmap"><span class="nav-number">15.2.</span> <span class="nav-text">HashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">16.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">17.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#panic"><span class="nav-number">17.1.</span> <span class="nav-text">Panic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#result-%E5%92%8C"><span class="nav-number">17.2.</span> <span class="nav-text">Result 和 ?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97"><span class="nav-number">18.</span> <span class="nav-text">包与模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#use"><span class="nav-number">18.1.</span> <span class="nav-text">Use</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A-%E6%96%87%E6%A1%A3"><span class="nav-number">19.</span> <span class="nav-text">注释 &#x2F; 文档</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Jasper" src="/images/avatar.jfif"><p class="site-author-name" itemprop="name">Jasper</p><div class="site-description" itemprop="description">微尘</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">330</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phc3Blci0xMDI0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jasper-1024"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><a href="/ljy087621@gmail.com" title="E-Mail → ljy087621@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly94LmNvbS9KYXNwZXJfMTAyNA==" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;Jasper_1024"><i class="fab fa-twitter fa-fw"></i>Twitter</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL2phc3BlcjEwMjQ=" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;jasper1024"><i class="fab fa-skype fa-fw"></i>Telegram</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fas fa-rss fa-fw"></i>RSS</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tLw==" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;">forecho</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tL2ZyaWVuZHNoaXAtbGlua3Mv" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;friendship-links&#x2F;">友链聚合</span></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jasper1024.com/jasper/xads23cva0dgew/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jfif"><meta itemprop="name" content="Jasper"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="默"><meta itemprop="description" content="微尘"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Rust 基础入门 | 默"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Rust 基础入门</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-08-29 23:14:00" itemprop="dateCreated datePublished" datetime="2023-08-29T23:14:00Z">2023-08-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-09-30 16:14:02" itemprop="dateModified" datetime="2023-09-30T16:14:02Z">2023-09-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a> </span></span><span id="/jasper/xads23cva0dgew/" class="post-meta-item leancloud_visitors" data-flag-title="Rust 基础入门" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/jasper/xads23cva0dgew/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="jasper/xads23cva0dgew/" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>36k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>33 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li><p>rust 基础总结</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">08</span>-<span class="number">29</span> 初始化</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h2 id="导语"><a class="markdownIt-Anchor" href="#导语"></a> 导语</h2><p>工作原因,需要抱紧 Rust, 那来吧,那个传说中的入门曲线….名不虚传…😂😒</p><p>这并非教程,是个人刷 Rust 圣经的记录,以备回看.</p><h2 id="开胃菜"><a class="markdownIt-Anchor" href="#开胃菜"></a> 开胃菜</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust 程序入口函数,还是 main，该函数目前无返回值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用let来声明变量，进行绑定，a 是不可变的</span></span><br><span class="line">    <span class="comment">// 编译器会推断类型：i32，有符号32位整数,rust 中编译器存在感真强</span></span><br><span class="line">    <span class="comment">// 语句的末尾必须以分号结尾 c/java</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 主动指定b的类型为i32,类型标注 语法基本相同</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i32</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 这里有两点值得注意：</span></span><br><span class="line">    <span class="comment">// 1. 可以在数值中带上类型:30i32表示数值是30，类型是i32</span></span><br><span class="line">    <span class="comment">// 2. c是可变的，mut是mutable的缩写</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="number">30i32</span>;</span><br><span class="line">    <span class="comment">// 数值和类型中间添加一个下划线</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = <span class="number">30_i32</span>;</span><br><span class="line">    <span class="comment">// 高阶函数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = <span class="title function_ invoke__">add</span>(<span class="title function_ invoke__">add</span>(a, b), <span class="title function_ invoke__">add</span>(c, d));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块</span></span><br><span class="line">    <span class="comment">// 该函数将指定的格式化字符串输出到标准输出中(控制台)</span></span><br><span class="line">    <span class="comment">// &#123;&#125;是占位符，在具体执行过程中，会把e的值代入进来, 因为编译器非常智能,不需要 %d %f 这样标明类型的占位符了.</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;( a + b ) + ( c + d ) = &#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(i: <span class="type">i32</span>, j: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 可以省略return | 这个很不一样,只在函数式编程中见过</span></span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另外几个需要注意的点</p><ul><li>字符串是双引号. 字符是单引号;</li><li>占位符只有 <code>&#123;&#125;</code>,具体类型 编译器会知道,无需再写 <code>%d</code> 啥的;</li></ul><h2 id="编译器行为"><a class="markdownIt-Anchor" href="#编译器行为"></a> 编译器行为</h2><p>一些调试编写代码常用 trick</p><p>可以以注解形式,控制一些编译器行为, 这些行为方便了 原型时候 调试代码;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused_variables)]</span>  允许未使用变量</span><br><span class="line"><span class="meta">#[allow(dead_code)]</span> 允许死循环</span><br></pre></td></tr></table></figure><p><code>_x</code> 下划线开头的变量将被 rust 编译器忽略,方便编写初始代码;</p><p>derive 派生特征: 类似注解,为对象实现默认特征</p><ul><li><code>#[derive(Debug)]</code>: 见过很多了, <code>println!(&quot;&#123;:?&#125;&quot;, s)</code> 可以打印整个结构体;</li><li><code>Copy</code></li></ul><h3 id="插入-复杂结构的打印输出"><a class="markdownIt-Anchor" href="#插入-复杂结构的打印输出"></a> (插入) 复杂结构的打印输出</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  width: <span class="type">u32</span>,</span><br><span class="line">  height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">      width: <span class="number">30</span>,</span><br><span class="line">      height: <span class="number">50</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个结构体是打印不出来的, 编译器: 结构体没有实现 Display… 难怪,结构体完全不同,能默认实现 Display 才怪.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`Rectangle` doesn<span class="symbol">&#x27;t</span> implement `std::fmt::Display`</span><br><span class="line">the <span class="keyword">trait</span> `std::fmt::Display` is not implemented <span class="keyword">for</span> `Rectangle`</span><br><span class="line"><span class="keyword">in</span> format strings you may be able to <span class="keyword">use</span> `&#123;:?&#125;` (or &#123;:#?&#125; <span class="keyword">for</span> <span class="title class_">pretty</span>-print) instead</span><br></pre></td></tr></table></figure><p>按照提示换用 <code>&#123;:#?&#125;</code>,编译器继续</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`Rectangle` doesn<span class="symbol">&#x27;t</span> implement `<span class="built_in">Debug</span>`</span><br><span class="line">the <span class="keyword">trait</span> `<span class="built_in">Debug</span>` is not implemented <span class="keyword">for</span> `Rectangle`</span><br><span class="line">add `<span class="meta">#[derive(Debug)]</span>` to `Rectangle` or manually `<span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span>`</span><br></pre></td></tr></table></figure><p>手动 impl Debug or 添加 <code>#[derive(Debug)]</code>, 那就添加; 能输出了;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rect1 is Rectangle &#123;</span><br><span class="line">    width: <span class="number">30</span>,</span><br><span class="line">    height: <span class="number">50</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果默认格式不满意就只能自行实现 Display 了;</p><p>还有另一种是 <code>dbg!(xxx)</code>: 打印出 表达式值 文件名 行号 等信息;</p><ul><li>输出到标准错误输出 <code>stderr</code>，而 <code>println!</code> 输出到标准输出 <code>stdout</code>。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbg!(rect1);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">[src/main.rs:<span class="number">13</span>] rect1 = Rectangle &#123;</span><br><span class="line">    width: <span class="number">60</span>,</span><br><span class="line">    height: <span class="number">50</span>,</span><br></pre></td></tr></table></figure><h2 id="变量绑定与解构"><a class="markdownIt-Anchor" href="#变量绑定与解构"></a> 变量绑定与解构</h2><p><code>let a = 1</code> 语法上等价于 赋值语句,这里意味着 a 与 1 的值绑定</p><ul><li>涉及到了 所有权 的概念</li></ul><p>默认 rust 变量不可变, 可变 -&gt; <code>let mut a = 2</code>.</p><ul><li>不可变带来了内存安全和性能的提升</li><li><s>和 kotlin 的不可变 <code>val</code> 有些类似</s> 一点也不像</li></ul><p><code>_x</code> 下划线开头的变量将被 rust 编译器忽略,方便编写初始代码;</p><p>变量解构: 与 py 中相同的概念,从变量中直接拆出部分内容;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 py 类似的语法</span></span><br><span class="line"><span class="keyword">let</span> (a, <span class="keyword">mut</span> b): (<span class="type">bool</span>,<span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更花的解构 左边并不是 let xx</span></span><br><span class="line"><span class="keyword">let</span> (a, b, c, d, e);</span><br><span class="line">(a, b) = (<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line"><span class="comment">// _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _</span></span><br><span class="line">[c, .., d, _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">Struct &#123; e, .. &#125; = Struct &#123; e: <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>常量… rust 居然还有这个概念…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 声明, 命名习惯上 全大写字母 下划线</span></span><br><span class="line"><span class="comment">// 作用域 相当于全局</span></span><br><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="type">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure><ul><li>不可变 变量 和 常量还是有点区别,<s>后面再详聊;</s><ul><li>常量 作用域是整个程序 or 模块. 常量值 和 类型 必须在编译时就确定;</li></ul></li></ul><p>变量遮蔽: 允许多个 let 声明同名变量, 后面会顶替前面; 前后是完全不同的变量,只是同名而已.</p><ul><li>还有个作用域的事, <code>&#123; &#125;</code> 内继承外部定义的变量,但内部定义变量作用域仅在 内部; 最后 println! 输出的还是 let x = x+1 定义的 x;</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 在main函数的作用域内对之前的x进行遮蔽</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在当前的花括号作用域内，对之前的x进行遮蔽</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 <span class="exturl" data-url="aHR0cHM6Ly96aC5wcmFjdGljZS5ycy92YXJpYWJsZXMuaHRtbA==">练习<i class="fa fa-external-link-alt"></i></span></p><h2 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h2><p>rust 不是动态语言,且因为所有权等概念的引入导致 类型相当相当重要;;;</p><ul><li>必须指明变量类型,大部分情况下编译器足够聪明,不需要操心…但是总有二般</li><li><code>let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);</code> 从字符串 <code>&quot;42&quot;</code> 解析出整数, 编译器要能推断出这个,都能自己写程序了.</li><li>这里必须显式补充上,要不然直接报错: <code>let guess: i32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);</code></li></ul><p>有 3 点 rust 与 c/c++ 完全不同</p><ul><li>数值类型相当多,且泾渭分明. 数字后面可以跟着类型 <code>let a = 8i8</code></li><li><strong>不存在隐式类型转换</strong>,所有转换必须是显式;</li><li><strong>数值可以直接调用方法</strong>…这一点又非常像 py… <code>a.is_nan</code></li></ul><p>基本类型</p><ul><li>数值类型:<ul><li>有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)</li><li>无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>)</li><li>浮点数 (<code>f32</code>, <code>f64</code>)</li><li>有理数、复数</li></ul></li><li>字符串：字符串字面量 和 字符串切片 <code>&amp;str</code></li><li>布尔类型： <code>true</code> 和 <code>false</code></li><li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li><li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code> <span id="^21ffc3" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^21ffc3</span><ul><li>这是最新鲜的…似乎是类似 c/c++ 的 <code>void</code></li></ul></li></ul><h3 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h3><p>(<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>) / (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 没了</p><ul><li>长度直接写在脸上了, 除了 isize / usize 是架构决定</li><li>默认 i32 一把梭子</li></ul><p>十进制 <code>98_200</code> 十六进制 <code>0x</code> 八进制 <code>0o</code> 二进制 <code>0b</code></p><p>整数溢出问题: 编译器 --debug 模式会检查,但 --release 就直接按照补码溢出来操作了…</p><ul><li>处理这些情况,使用标准库的拓展即可:</li><li><code>wrapping_*</code> 一切按照补码溢出操作; <code>checked_*</code> 溢出直接 None (rust 居然也有这个值); <code>overflowing_*</code> 是否溢出,返回 bool; <code>saturating_*</code> 值达到最大/最小值;</li></ul><h3 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h3><p>f32 f64 类似于 float double</p><ul><li>不能当作 hashmap 的 key,这个还是有点不一样</li></ul><p><strong>3 倍注意: 浮点数精度问题</strong>, C 中也常见,但 rust 要求更加严格;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">abc</span>: (<span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xyz</span>: (<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(abc.<span class="number">0</span> + abc.<span class="number">1</span> == abc.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(xyz.<span class="number">0</span> + xyz.<span class="number">1</span> == xyz.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是 0.1+0.2 与 0.3 比较, <mark style="background:#adcCFFA6">f32 就相等, f64 就不相等;</mark></p><ul><li>f32 下.加完都是 <code>3e99999a</code></li><li>f64 下精度高太多了, <code>3fd3333333333334</code> 和 <code>3fd3333333333333</code> 的比较.</li></ul><p>防御性编程: <code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code> 是最好的解决办法;</p><h3 id="nan"><a class="markdownIt-Anchor" href="#nan"></a> NaN</h3><p>数学上未定义结果统一 NaN… NaN != 0,无法用于比较,比较直接 painc;</p><p><code>x.is_nan()</code> 防御性编程;</p><h3 id="运算"><a class="markdownIt-Anchor" href="#运算"></a> 运算</h3><p>普通运算 <code>+ - * / %</code></p><p>位运算 <code>&amp; | ^ ! &lt;&lt; &gt;&gt;</code></p><h3 id="序列"><a class="markdownIt-Anchor" href="#序列"></a> 序列</h3><p><code>1..5</code> 生成 1 到 4; <code>1..=5</code> 生成 1 到 5;</p><p>字符同理 <code>'a'..'z'</code> 和 <code>'a'..='z'</code></p><ul><li>这是 py 吗…</li></ul><h3 id="有理数-复数"><a class="markdownIt-Anchor" href="#有理数-复数"></a> 有理数 复数</h3><p>rust 标准库并没有支持有理数 复数,而是需要第三方库 <span class="exturl" data-url="aHR0cHM6Ly9jcmF0ZXMuaW8vY3JhdGVzL251bQ==">num<i class="fa fa-external-link-alt"></i></span>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo add num</span><br></pre></td></tr></table></figure><h2 id="字符-布尔-单元"><a class="markdownIt-Anchor" href="#字符-布尔-单元"></a> 字符 布尔 单元</h2><p>来个 rust 震惊: 所有的 <code>Unicode</code> 值都可以作为 Rust 字符, 包括单个的中文 日文 韩文 emoji 表情符号等等,都是合法的字符类型.</p><ul><li>👽 我也是</li></ul><p>4 字节. <code>''</code> 单引号</p><p>bool: true false, <mark style="background:#ffb86CA6">1 字节</mark> (不是 1bit,看清楚)</p><p>单元类型; <code>()</code> 有且仅有这个 <code>()</code> <span id="^e508df" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^e508df</span></p><ul><li>看似无返回的函数返回的就是 <code>()</code></li><li>占位但不占用任何内存, map 不关注值 只关注 key 时候,<code>()</code> 可以作为值; (类似 go 的 <code>struct&#123;&#125;</code>)</li></ul><h2 id="语句-表达式"><a class="markdownIt-Anchor" href="#语句-表达式"></a> 语句 表达式</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_with_extra</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>; <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = y + <span class="number">5</span>; <span class="comment">// 语句</span></span><br><span class="line">    x + y <span class="comment">// 表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般编程语言中并没有特别区分 语句 和 表达式, rust 则是分的很开.</p><p>表达式是要返回值; 语句是纯执行没有返回值;</p><ul><li>函数就是表达式</li><li><mark style="background:#fff3A3A6">表达式不能包含分号</mark></li></ul><p>这一块的概念触及了更深层次,新东西太多,作者省略了一些细节.具体请看 <span class="exturl" data-url="aHR0cHM6Ly9ydXN0d2lraS5vcmcvemgtQ04vcmVmZXJlbmNlL3N0YXRlbWVudHMtYW5kLWV4cHJlc3Npb25zLmh0bWwjJUU4JUFGJUFEJUU1JThGJUE1JUU1JTkyJThDJUU4JUExJUE4JUU4JUJFJUJFJUU1JUJDJThG">语句和表达式<i class="fa fa-external-link-alt"></i></span></p><ul><li>似乎概念上 表达式的写法更加简洁,暂时没有更多实感.</li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><p>语法上 rs 的函数与带类型标注的 py 很像.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(i: <span class="type">i32</span>, j: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">   i + j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x - <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus2</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">5</span> &#123;</span><br><span class="line">        x - <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x + <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回可以不同 (表达式); plus plus2 等价;</li><li>关键词 <code>fn</code> 不同</li></ul><p>一般是蛇形命名 (全小写 下划线);</p><p>类似 c 中的 void 无返回的函数,实际上返回的是 <a href="/jasper/xads23cva0dgew/#^21ffc3">单元类型</a></p><h3 id="发散函数"><a class="markdownIt-Anchor" href="#发散函数"></a> 发散函数</h3><p>类似 void 的还是会返回 <code>()</code>,但 发散函数 是真的一去不回….</p><p>使用 <code>!</code> 作为函数的返回类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真 dead 函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dead</span>() <span class="punctuation">-&gt;</span> ! &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="所有权-与-借用"><a class="markdownIt-Anchor" href="#所有权-与-借用"></a> 所有权 与 借用</h2><p>堆 和 栈 的区别, 入栈要求固定大小,速度快; 堆则较为无序,速度慢;</p><p>粗看下来,有些类似 指针 + 所有权; 作用域 = 生命周期 ; 有些类似 面向对象语言中, 对象 生命周期的概念…通过编译器 严格遵守 生命周期 和 所有权, 避免了 对象 (?) GC…</p><p>感觉有点像 对象生命周期管理 的思想 用来管理 内存里的一切;;</p><hr><p>先看一段非常典型的 c 内存错误…类似的炸弹会存在在任何地方…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;          <span class="comment">// 变量a的作用域开始</span></span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span> *c = <span class="string">&quot;xyz&quot;</span>;   <span class="comment">// 变量c的作用域开始</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;                   <span class="comment">// 变量a和c的作用域结束</span></span><br></pre></td></tr></table></figure><p><span id="^fb6442" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^fb6442</span></p><ul><li>程序返回了一个指向局部变量的指针,局部变量销毁后就成了 野指针;</li></ul><p>所有权和借用 还涉及到了 堆 和 栈</p><ul><li>栈 出栈入栈要求长度类型确定,速度很快,长度确定因此找某个值也很快;</li><li>堆 不定长,不定类型,存入访问速度比栈慢,但能处理类型多很多.</li></ul><p>c/c++ 中堆上数据跟踪非常复杂,但 rust 要全管理起来 -&gt; 所有权 和 生命周期</p><h3 id="所有权"><a class="markdownIt-Anchor" href="#所有权"></a> 所有权</h3><p>3 个规则</p><ul><li>每个值只有一个所有者;</li><li>一个值的所有者只能是 一个;</li><li><mark style="background:#bbfABBA6">所有者离开作用域,值就 drop (drop!)</mark></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 拥有所有权</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>let 会将 x 的所有权转移到 y,因此 x 不再有效, println 就会报错; --&gt; 所有者仅 1 个</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但基本类型无碍</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x; <span class="comment">// 栈上的拷贝非常快</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); <span class="comment">//正常</span></span><br></pre></td></tr></table></figure><p>同样的逻辑下, 基本类型却没事… --&gt; 基本类型是在 栈 中, 栈内复制非常快,因此 let 并没有发生所有权转移,而是复制了一份 x 的副本给 y;</p><ul><li>其实是 Copy 特征</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: &amp;<span class="type">str</span> = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,x,y); <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure><p>但是字符串不是在堆中吗 😵… 这里引出了 引用 的概念… x 是指向字符串的引用,也在栈中,因此可以直接复制…</p><p>rust 永远不会自行创建 深拷贝,但又 <code>x.clone()</code> 手动执行深拷贝 (重复执行,对性能影响很大)</p><p>上面说的基本类型可以自动拷贝 (栈上的复制), 并不限于基本类型; --&gt; 任何 不需要分配内存或某种形式的资源 就可以 自动拷贝 (也叫实现了 Copy);</p><ul><li>基本类型</li><li>元组, 当且 包含类型也只有 基本类型时;</li><li>不可变 引用</li></ul><p><mark style="background:#ffb86CA6">变量传递给函数,函数返回值赋予变量 也有所有权的转移</mark>; // 这真没想到;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"><span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里,下面将无法使用 s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                    <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                    <span class="comment">// 它也将返回值移给 s3</span></span><br></pre></td></tr></table></figure><p>这样来回传递当然非常麻烦 --&gt; 借用和引用</p><ul><li>非常类似 权限控制的指针,或者说就是;</li></ul><p>let 的操作,对 复杂类型是 移动所有权, 对简单类型就是完整拷贝;</p><h3 id="引用-和-借用"><a class="markdownIt-Anchor" href="#引用-和-借用"></a> 引用 和 借用</h3><p>语法和 c/c++ 指针完全相同 <code>&amp; *</code> ;</p><p>为了安全性, 默认引用是不能修改值的; --&gt; 可变引用; <code>let r = &amp;mut s</code></p><p>还是为了完全性, 类似读者写者问题的解决方案:</p><ul><li><mark style="background:#fff3A3A6">不可变引用 与 可变引用 只能同时存在一个;</mark> <span id="^xlg6a4" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^xlg6a4</span></li><li><mark style="background:#fff3A3A6">不可变引用数量 可以有多个, 可变引用 只能有一个;</mark></li></ul><p>引用的作用域 呃, 非常独特…(⊙﹏⊙)…</p><p>最开始时候, 引用作用域判定规则和变量一致,这没啥…</p><p>但是叠加上: 变量释放时必须没有任何引用; 要了命了… 写代码时候要时刻注意 变量 + 引用的范围,随时加中括号…//这谁受得了///</p><p>最新编译器中: <mark style="background:#ffb86CA6">引用作用域等于最后一次使用该引用的位置</mark> == 解放</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2); <span class="comment">// 新编译器中，r1,r2 作用域到此为止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 老编译器下,r1 r2 有效,触发 不能同时可变和不可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3); <span class="comment">// 新编译器下 r3 作用域结束</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对于这样的 引用作用域,还有个专门的名称: <strong>Non-Lexical Lifetimes(NLL)</strong></p><p>悬垂引用/悬垂指针 类似 <a href="/jasper/xads23cva0dgew/#^fb6442">Rust 基础入门#^fb6442</a> 的情况, 变量被 drop 了,引用/指针 还存在; rust 编译器会阻止这一切;</p><h2 id="复合类型"><a class="markdownIt-Anchor" href="#复合类型"></a> 复合类型</h2><p>复合类型这里会提到 字符串/切片 元组 结构体 枚举 还有 数组, 大都见过,但是 rust 中会非常不一样.</p><h3 id="字符串-和-go-很像"><a class="markdownIt-Anchor" href="#字符串-和-go-很像"></a> <strong>字符串</strong> (和 Go 很像)</h3><p>语法层面上 rust 只有一种字符串类型: <code>str</code>,但 <code>str</code> 不可修改,所有权变化很乱, --&gt; 字符串的切片 <code>&amp;str</code> (跟 go 一模一样), 可变就交给了 标准库的 <code>String</code> 类型</p><ul><li>标准库还有更多类型 ( <code>xxStr</code> ),但常用就上面俩</li></ul><p>rust 中字符是 unicode 4 字节,那么 字符串 肯定也是 <code>4*字符量</code> 的长度吧…并不是, 字符串是 utf-8… 字符串中字符的长度是 1-4 变长…</p><ul><li>这个特性使得字符串处理与其他语言完全不同 --&gt; <mark style="background:#bbfABBA6">禁止字符串索引访问,虽然有切片…</mark></li><li>同时所有权等概念, 让这一切更加复杂</li></ul><p>切片 (go 基本相同): 本质上不可变引用</p><ul><li><code>let hello = &amp;s[0..5];</code></li><li><code>&amp;s[0..2];</code> 和 <code>&amp;s[..2];</code> | <code>&amp;s[4..len]</code> 和 <code>&amp;s[4..];</code></li><li><code>&amp;s[0..len]</code> 和 <code>&amp;s[..];</code></li><li><strong>特别的一点</strong>: <code>let s = &quot;Hello, world!&quot;;</code> <mark style="background:#ffb86CA6">字符串字面量 s 是切片 <code>&amp;str</code> 类型</mark></li></ul><p><code>String</code> 类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>(); <span class="comment">// 空的 String 对象</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;Hello, Rust!&quot;</span>.<span class="title function_ invoke__">to_string</span>(); <span class="comment">// 包含字符串字面量的 String 对象</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// 包含字符串字面量的 String 对象</span></span><br></pre></td></tr></table></figure><p><code>String</code> 和 <code>&amp;str</code> 转换</p><ul><li>上面新建 <code>String</code> 里就是 <code>String::from(&quot;hello,world&quot;)</code> 和 <code>&quot;hello,world&quot;.to_string()</code></li><li>转换回去就直接取引用 (切片);<ul><li>这里有隐式的类型转换 <span class="exturl" data-url="aHR0cHM6Ly9jb3Vyc2UucnMvYWR2YW5jZS9zbWFydC1wb2ludGVyL2RlcmVmLmh0bWwjZGVyZWYtJUU4JUE3JUEzJUU1JUJDJTk1JUU3JTk0JUE4">Deref 解引用<i class="fa fa-external-link-alt"></i></span></li></ul></li></ul><p><mark style="background:#fff3A3A6">禁止字符串索引访问</mark>, 即使切片也得注意索引范围;</p><ul><li>utf8 变长,索引取到中间值无意义,直接报错;</li><li>性能问题,期望性能始终为 O(1) 但始终难以保证</li></ul><h4 id="字符串操作"><a class="markdownIt-Anchor" href="#字符串操作"></a> 字符串操作</h4><p><code>s.push('!');</code> <code>s.push_str(&quot;rust&quot;);</code> <code>s.insert(5, ',');</code> <code>s.replace_range(7..8, &quot;R&quot;);</code></p><ul><li>操作原字符串, 需要 mut; 仅适用于 <code>String</code></li></ul><p><code>s.replace(&quot;rust&quot;, &quot;RUST&quot;)</code> <code>s.replacen(&quot;rust&quot;, &quot;RUST&quot;, 1)</code></p><ul><li>返回新字符串,不需要 mut; 适用于 <code>String</code> <code>&amp;str</code></li></ul><p>删除: 都需要 mut ,仅适用于 <code>String</code></p><ul><li>pop 删除最后一个字符;</li><li>remove(5): 删除单个字节</li><li>truncate(3): 删除索引到尾部 (字节)</li><li>clear(): 清空</li></ul><p>连接:</p><ul><li><code>+</code> <code>+=</code> : 相当于标准库的 <code>std::sting</code> 的 add 方法; 要求第二个必须是 <code>&amp;str</code> 类型,返回 <code>String</code> 类型;</li><li><code>format</code>: 类似 print, 适用于 <code>String</code> 和 <code>&amp;str</code>: <code>format!(&quot;&#123;&#125; &#123;&#125;!&quot;, s1, s2);</code></li></ul><h4 id="小坑"><a class="markdownIt-Anchor" href="#小坑"></a> 小坑</h4><p>字符串内: 所有权的坑</p><p><mark style="background:#bbfABBA6">调用方法 == 使用了引用, 非常容易出现 可变不可变 同时存在</mark></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// &lt;- 这里出错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看似挺正常的… 但是 <code>s.clear()</code> 就会出错….</p><ul><li>传入 first_word 的是一个不可变引用, println! 调用的 2</li><li>但是但是, <code>s.clear()</code> 是个方法,对自身修改,需要的 可变引用</li><li>可变引用 + 不可变引用 同时存在 + !<a href="/jasper/xads23cva0dgew/#^xlg6a4">Rust 基础入门#^xlg6a4</a> == bong !</li></ul><p><mark style="background:#bbfABBA6">任何直接消费 非实现 copy 类型,都有所有权的转移</mark></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    <span class="comment">// 在下句中，s1的所有权被转移走了，因此后面不能再使用s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// 任何直接消费 非实现 copy 类型,都有所有权的转移</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s3,<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="comment">// 下面的语句如果去掉注释，就会报错</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;,s1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s1 在 <code>let s3 = s1 + &amp;s2;</code> 就失效了</p><ul><li><code>+</code> 相当于 add 函数, s1 又是 String 非基本类型,所有权转移到了 add 内部 (相当于给函数传递了 变量 本身,所有权转移进去了)</li><li>add 执行完, s1 就被 drop 了…</li></ul><h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4><p>转义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\x73 直接转成 ascII or unicode 输出</span><br><span class="line">\\x73 原样 \\x73 输出</span><br></pre></td></tr></table></figure><p>utf-8</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 unicode 遍历字符串</span></span><br><span class="line"><span class="comment">// 输出 中  国  人</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;中国人&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样是纯字节了</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;中国人&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 utf-8 获取子串,标准库无能为力 --&gt; <span class="exturl" data-url="aHR0cHM6Ly9jcmF0ZXMuaW8vY3JhdGVzL3V0Zjhfc2xpY2U=">utf8_slice<i class="fa fa-external-link-alt"></i></span></p><h3 id="元组"><a class="markdownIt-Anchor" href="#元组"></a> 元组</h3><p>任意类型 <code>()</code> 常用于返回值 (这一点挺像 py)</p><p>访问: 解构 or <code>x.2</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = tup.<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h3><p>语法和 C 很像, <mark style="background:#bbfABBA6">但没有指针和分号</mark>; <code>struct</code> <code>,</code> 分割 声明类型;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例时,每个字段都得初始化, 但 顺序无所谓.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问结构体成员 <code>x.a</code>; 修改成员要求 实例必须是 mut 才行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user1 必须声明成 mut </span></span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>结构体初始化和创建,每一个字段都得精心维护,太繁琐了,有一些简便写法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数与字段名 重名,可省略一个声明;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已有实例创建新实例 (<strong>可能有 所有权转移</strong>)</p><ul><li>所有权一旦转移, use1 就可能 一部分字段可访问,一部分无效;</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..展开已有实例;</span></span><br><span class="line"><span class="comment">// 千万注意: ..user1 的成员有可能会发生所有权转移</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rust 结构体肯定不止 C 那样,还有几类特殊的结构体;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略字段名, 按照索引号访问 -&gt; 也叫元组结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="comment">// <a href="/jasper/xads23cva0dgew/#^e508df">单元类型</a> 是个占位符(描述行为的),后面特征(类似接口)会用到</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"><span class="comment">// 甚至 struct 也不是必须的 | 这也是元组结构体</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">person</span> = (<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;John&quot;</span>), <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>以上都没涉及到一个情况: 字段取到 引用 类型…. 在 学习生命周期前暂时不涉及</p><ul><li>应该 引用 要在 变量本身生命周期 内, 而又套上 结构体 就更复杂了…</li></ul><h3 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h3><p>将一类的值全包起来,不限制类型;</p><ul><li>rust 枚举 <mark style="background:#bbfABBA6">可以关联其他类型</mark> (这一点拓展了很多使用场景)</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerSuit</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Clubs</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Spades</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Diamonds</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hearts</span>(<span class="type">u8</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c1</span> = PokerCard::<span class="title function_ invoke__">Spades</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c2</span> = PokerCard::<span class="title function_ invoke__">Diamonds</span>(<span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>组织数据结构,屡试不爽…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举嵌套结构体... 有点干了泛型的活..</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标准库的例子,两个后续处理流程显示的 结构</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Websocket</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">Tcp</span>(Websocket&lt;TcpStream&gt;),</span><br><span class="line">  <span class="title function_ invoke__">Tls</span>(Websocket&lt;native_tls::TlsStream&lt;TcpStream&gt;&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="null-处理"><a class="markdownIt-Anchor" href="#null-处理"></a> Null 处理</h4><p>java 中最恨这个,其次是 getter/setter; 一不留神就程序没了; 所以 rust 直接不要 null 了…</p><p>rust 中任何可能为 null 的类型,得套上 <span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9zdGQvb3B0aW9uL2VudW0uT3B0aW9uLmh0bWw=">Option<i class="fa fa-external-link-alt"></i></span> 枚举, <code>Option&lt;T&gt;</code> 和 <code>T</code> 不能直接运算,得配合 null 的处理才行. 相当于强制用户必须处理 null …(习惯了,习惯了…吸氧…)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="^bce572" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^bce572</span></p><h3 id="数组-不可变数组-array"><a class="markdownIt-Anchor" href="#数组-不可变数组-array"></a> 数组 (不可变数组 array)</h3><p>前排提醒 这里数组特指 不可变数组 array; rust 中 可变数组 是 Vector ;</p><p>array 中括号 <code>[]</code>; 不可变; 定长; 类型一致; --&gt; 在栈中;</p><ul><li>定长,所以能 索引 访问了; 越界会直接 pannic…</li><li>快捷声明仅对 栈上 能直接 copy 的类型生效…</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 快捷声明 1,重复 5 次 ,但有坑</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = [<span class="number">1</span>; <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>不能直接 Copy 的类型有要用 --&gt; <code>std::array::from_fn</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::array::from_fn;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">arr</span> = <span class="title function_ invoke__">from_fn</span>(|i| i * <span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 有个坑? 把 assert_eq 去掉,则 arr 声明有误..</span></span><br><span class="line">	<span class="comment">// arr 长度来源于比较的数组, 确实不能带着其他语言的思维惯性 推测 rust 编译器行为</span></span><br><span class="line">	<span class="built_in">assert_eq!</span>(arr, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然集合类型都有切片</p><ul><li><mark style="background:#ffb86CA6">array 类型是 <code>[T;n]</code> , 切片是 <code>[T]</code></mark> 这俩千万别混淆了.</li><li>切片创建代价非常小</li><li>切片类型 <code>[T]</code> 大小不固定, 切片引用类型 <code>&amp;[T]</code> 大小固定 (只是个引用), 因此引用更常见.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h2><p>if - else while loop 以及 continue 和 break</p><ul><li>关键字还都蛮熟悉的, loop 是个死循环,在哪里见过呢,似乎是 vb…</li><li>关键是 rust 融合了很多高级语言的特性,本身定位又是系统编程…高低混合…这个乱啊…</li><li><code>continue</code> 或 <code>break</code> 多了一个标签 控制 (另类的 <code>goto</code>?)</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常见</span></span><br><span class="line"><span class="keyword">if</span> condition == <span class="literal">true</span> &#123;<span class="comment">// A…</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;<span class="comment">// B…&#125;</span></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// final &#125;</span></span><br><span class="line"><span class="comment">// 也有赋值的做法, 这里是个表达式 一定要有 `;`</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125; ;</span><br></pre></td></tr></table></figure><p>for 循环有个大坑 (所有权), <mark style="background:#bbfABBA6">迭代集合 (非 copy 类型) 一定要传入引用,</mark> 除非你之后不打算再使用这个集合了…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> XS &#123;&#125; <span class="comment">// 集合迭代</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> &amp;XS &#123;&#125; <span class="comment">// 传入引用,一般用这个</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> &amp;mux XS &#123;&#125; <span class="comment">// 传入可变引用</span></span><br><span class="line"><span class="title function_ invoke__">for</span> (i, v) <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>() &#123;&#125; <span class="comment">// 索引访问, x.iter</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;&#125; <span class="comment">// 带索引循环</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;&#125; <span class="comment">// 循环特定次数, `_` 代替了 i</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123; &#125; <span class="comment">// 一切如常</span></span><br><span class="line"><span class="keyword">loop</span> &#123; &#125; <span class="comment">// 一定记着 break </span></span><br></pre></td></tr></table></figure><p>标签: 标签名 <code>:</code> 流程, break or continue 可以指定 标签</p><ul><li>这可比只能控制当前流程 好太多了</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&#x27;outer</span>: <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>. &#123;</span><br><span class="line">    <span class="symbol">&#x27;inner</span>: <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">0</span>. &#123;</span><br><span class="line">        <span class="keyword">if</span> i * j &gt; <span class="number">30</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;outer</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span> <span class="symbol">&#x27;inner</span>&#x27; </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a class="markdownIt-Anchor" href="#模式匹配"></a> 模式匹配</h2><h3 id="match-if-let"><a class="markdownIt-Anchor" href="#match-if-let"></a> Match / if Let</h3><p>match 类似 switch,但更像 py 中的 switch;</p><ul><li>模式绑定: 取出枚举类绑定的值; --&gt; <a href="/jasper/xads23cva0dgew/#null-处理">Rust 基础入门#null 处理</a> 中 None 值的实际处理,一般就是配合 match ,在分支中进行.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> target &#123;</span><br><span class="line">    模式<span class="number">1</span> =&gt; 表达式<span class="number">1</span>,</span><br><span class="line">    模式<span class="number">2</span> | 模式<span class="number">3</span> =&gt; &#123; &#125;,</span><br><span class="line">    _ =&gt; 表达式<span class="number">3</span> or other =&gt; 表达<span class="number">3</span>(other)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也能用来赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ip_str</span> = <span class="keyword">match</span> ip1 &#123;</span><br><span class="line">    IpAddr::Ipv4 =&gt; <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    _ =&gt; <span class="string">&quot;::1&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解模式绑定</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState), <span class="comment">// 25美分硬币</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,&#125;&#125;</span><br></pre></td></tr></table></figure><p>当只想匹配一个条件时候 match --&gt; if let</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> v &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = v &#123; <span class="comment">// 乍一看和 if 写一行判断 没啥区别,但 好歹是模式匹配,能解开模式绑定</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里相比直接写 if 就节省了一行</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">optional_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 这一行 `=` 并非是赋值语句, 而是模式匹配的一部分</span></span><br><span class="line"><span class="comment">// if let 一行,干了 匹配? 匹配成功则赋值,两件事.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(number) = optional_number &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The number is &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;There is no number&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>matches!(value, pattern =&gt; epression)</code> value 值, pattern 是模式. 最后返回 bool 值.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"><span class="built_in">assert!</span>(matches!(foo, <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> | <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bar</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">assert!</span>(matches!(bar, <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &gt; <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>变量遮蔽: 模式和模式匹配后的表达式是一个新的代码块, 在这个作用域内 同名变量 会发生 变量遮蔽 <span id="^8963d3" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^8963d3</span></p><h3 id="解构-option"><a class="markdownIt-Anchor" href="#解构-option"></a> 解构 Option</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Some(i)</code> 会匹配到 <a href="/jasper/xads23cva0dgew/#^bce572">Option</a> 的 <code>Some(T)</code> 并且将 i 赋予具体的绑定值;</p><p><code>Some(4)</code> 有具体值的,就只能匹配到确切的值;</p><h3 id="模式适用场景"><a class="markdownIt-Anchor" href="#模式适用场景"></a> 模式适用场景</h3><p>这一节是模式匹配,终于谈到 模式了 2333 😂</p><p>模式本身就是 rust 的特殊的语法, 用于匹配和解构数据结构的语法; 一般可由下面内容混合</p><ul><li>字面值 | 解构的数组 枚举 结构体 或 元组 | 变量 | 通配符 | 占位符</li></ul><h4 id="哪里用到了模式"><a class="markdownIt-Anchor" href="#哪里用到了模式"></a> 哪里用到了模式</h4><p>match 的分支, 每个分支就是一个模式.最后用 <code>_</code> 兜底</p><p><code>if let</code> 单一模式</p><p><code>while let</code> 循环单一模式 使用 loop + iflet or match 更繁琐;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vec是动态数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组尾部插入元素</span></span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stack.pop从数组尾部弹出元素</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for (index, value) in v.iter().enumerate()</code> 也是一种匹配模式,元组匹配迭代器</p><p>甚至 <code>let a = 123</code> 也是一种模式匹配… 匹配的值 绑定到 变量上…</p><ul><li>就说闹不闹</li></ul><p>类似的解构元组 <code>let (x,y,z) = (1,2,3);</code> 也是模式匹配….这里模式还包括了 变量个数.</p><p>函数的参数也是模式…我去, 就是个筐是吧…</p><p><code>if let</code> 这里特殊一点, <code>if let</code> 允许不完全的匹配条件. -&gt; 可驳模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value; <span class="comment">// 可能还有 None,因此匹配失败</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value &#123; <span class="comment">// 这个会成功, 即使没有考虑 None 的情况</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全模式列表"><a class="markdownIt-Anchor" href="#全模式列表"></a> 全模式列表</h3><p>纯罗列…</p><p>字面值: 很简单 match 当 switch 来用;</p><p>命名变量: 前面提到的 <a href="/jasper/xads23cva0dgew/#^8963d3">变量遮蔽</a> 就是匹配命名变量时候遇到的.</p><ul><li>命名变量就是 <code>Some(y)</code> 这样…值被赋予了 y,要是前面还有同名变量,就会有变量遮蔽;</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y),</span><br></pre></td></tr></table></figure><p>单分支多模式: 多个模式 <code>|</code></p><p>序列匹配模式: 模式直接使用 <code>1..=5</code> <code>'a'..='j'</code></p><ul><li>只有 数字 和 字符 可以这样用, 适当使用节省了大量模板代码</li></ul><h4 id="解构"><a class="markdownIt-Anchor" href="#解构"></a> 解构</h4><p>前文中使用 解构直接拆分 结构体 元组 数组 引用等等,但是还不够,得加大药量.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">Point</span> &#123; x: a, y: b &#125; = p; <span class="comment">// 解构结构体, 变量名 其实可以和结构体不一致</span></span><br><span class="line">Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="comment">// 命名变量 和 值可以混用</span></span><br><span class="line">Point &#123; x: <span class="number">0</span>, y &#125; =&gt; </span><br></pre></td></tr></table></figure><p>解构也没有层级限制,唯一的限制是你能不能看的下去…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">   <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">   <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color), <span class="comment">// 绑定了另一个枚举</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123; <span class="comment">// 解构 枚举 嵌套 枚举</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,r, g,b)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,h,s,v)</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解构数组: 定长不定长…</p><p>#todo</p><h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2><p>又到了另一个与 go 相似的地方 <code>/o(*￣▽￣*)ブ</code></p><p>方法隶属于 object, 封装了对 属性的操作. rust 中</p><ul><li>object 定义 <mark style="background:#bbfABBA6">属性与方法分离</mark>, <code>impl</code> 关键词, 多个 <code>impl</code> 可组合.</li><li>方法内访问自身 <code>&amp;self</code> (第一个参数,又很像 py)</li><li>object 可以是: 结构体 / 枚举 / 特征 (类似接口)</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数 不带 *self 的</span></span><br><span class="line">    <span class="comment">// 这是个特例.约定俗成 new 是新建一个实例</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">u32</span>, y: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123;width: x,height: y,&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正方法, &amp;self 引用指向自身</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123; <span class="comment">// impl 可以有多个</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area2</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; <span class="comment">// 方法本质也是函数啊, 多个参数完全没问题</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">area</span>() &gt; other.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span>: Rectangle = Rectangle &#123;width: <span class="number">30</span>,height: <span class="number">50</span>,&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle::<span class="title function_ invoke__">new</span>(<span class="number">31</span>, <span class="number">51</span>); <span class="comment">// 关联函数调用 object`::`函数名</span></span><br><span class="line">  	<span class="built_in">println!</span>(<span class="string">&quot;rect1.area2(&amp;rect2) is &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area2</span>(&amp;rect2)); <span class="comment">// 方法则是 实例.方法名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关联函数: 方法本身可以算带 <code>*self</code> 的关联函数, 关联函数调用上 观感与类方法更接近.</p><p><code>*self</code> 其实是语法糖, 方法也是函数,也有所有权 生命周期 的问题</p><ul><li><code>self</code> <code>&amp;self</code> <code>&amp;mut self</code> 3 种, 多用 <code>&amp;self</code></li><li>执意使用 <code>self</code> 那么所有权直接转入,然后实例本身会被释放掉…这一点很坑,千万注意.</li></ul><p>还有一种用法是 方法与结构体字段名相同,实现 getter…<code>/(ㄒoㄒ)/~~</code></p><ul><li>结构体字段可设置为私有,增加安全性.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型和特征"><a class="markdownIt-Anchor" href="#泛型和特征"></a> 泛型和特征</h2><h3 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h3><hr><p>和 go 的泛型有得一拼… 但 rust 又是那种精心设计而非为了兼容妥协的,又比 c++ 精简多了…所以现在就是 👽👽👽…</p><hr><p>几个印象</p><ul><li>rust 泛型范围要比其他语言更广,结构体枚举都能用,甚至有 const 泛型.</li><li>0 成本,完全不会牺牲性能,总用代价吧? --&gt; 单态化,为每种可能类型都实现一遍,程序大小 ++</li></ul><p>一个示例: 动态数组最大值</p><ul><li>符号还是熟悉的 <code>T</code>,要提前声明在 函数名 <code>&lt;T&gt;</code></li><li>面向对象中的 extend 和 super 限制 T 的种类,rust 中则基于 特征 (类似于接口) 限定.</li><li>其他 T 的使用,没有太多差别.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">lagest</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, <span class="title function_ invoke__">lagest</span>(&amp;number_list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体泛型</p><ul><li>结构体名 <code>&lt;T&gt;</code>,一样得提前声明;</li><li><code>T</code> 只能代表一种类型, 多种类型 就声明多个呗. 即使是这样 `struct Woo&lt;T,U,V,W,X&gt;</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">0.0</span> &#125;;</span><br></pre></td></tr></table></figure><p>枚举泛型: 大明湖畔的 <code>Option</code> 已经见过了</p><ul><li>语法与结构体泛型基本一致</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法泛型: 方法也是函数,自然也能用泛型.</p><ul><li>一个声明中泛型的来源就是 <code>impl</code> 后面的&lt;&gt;中, <code>Point&lt;xx&gt;</code> 都是具体的类型</li><li>方法泛型中还可夹带 函数泛型,互不影响;</li><li><strong>重点:</strong> <mark style="background:#fff3A3A6">方法可以限定具体类型, 仅针对该类型实现方法</mark>; <span id="^pkn22t" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^pkn22t</span></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T, T&gt; &#123; <span class="comment">// Point&lt;T, T&gt; 是使用 T 不是声明</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="comment">// 一切如常</span></span><br><span class="line">        Point &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">X</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明时 可以使用具体类型. 仅方法一家;</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T, <span class="type">i32</span>&gt; Point&lt;T, <span class="type">i32</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">Y</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">zero</span>&lt;V, W&gt;(x: V, y: W) <span class="punctuation">-&gt;</span> Point&lt;V, W&gt; &#123; <span class="comment">// 函数泛型 互不干扰</span></span><br><span class="line">        Point &#123; x: x, y: y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const-泛型"><a class="markdownIt-Anchor" href="#const-泛型"></a> Const 泛型</h4><p>: 值的泛型</p><ul><li>上面种种泛型,T 代指的总是某个类型, 但在 rust 中还有一点特殊情况…需要待指某个具体值;</li></ul><p>数组 <code>[i32; 2]</code> 和 <code>[i32; 5]</code> 是不同的类型, 这一点仅在 rust,其他语言似乎都是同一个类型.这是个数组类型就好了…</p><p>这个问题导致了,明明都是 i32 的数组,只是长度不同,就得编写基本相同的函数处理…导致大量重复代码;</p><ul><li>改用数组切片,传入引用可以解决大部分,但并不是全部.</li><li>以前有的数组库限定长度 32,就是为每个长度实现一遍…简直…</li></ul><p>值的泛型: 加上关键词 <code>const</code>; 仅支持 整数 bool 和 char 类型</p><ul><li>这个实际上在编译时就能确认 N 的具体值, 归根结底算是个语法糖.</li><li>类型的泛型,编译时无法确定到底是什么类型; 只能为每个可能都实现一遍;</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N 是一个常量</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123; <span class="comment">// 如同常量一般使用 N</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">	<span class="title function_ invoke__">test</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有 const 表达式 和 const 函数指针; 但书里暂时没有更多介绍</p><h3 id="特征"><a class="markdownIt-Anchor" href="#特征"></a> 特征</h3><p>特征 (类似 接口) 定义一组方法 的集合 // 会有类似 面向对象 鸭子类型的感觉…</p><ul><li>真正定义的是一组 方法的签名 // 非常非常的 java 接口… 也会有类似 java 接口的用法</li></ul><p>定义 <code>trait X</code> 特征名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span>  &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>; <span class="comment">// 方法的签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>impl X for m</code>, 调用 <code>实例.x</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">M</span> &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">		<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = M &#123;name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>),x: <span class="number">1</span>,&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, m.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure><p>允许定义默认实现 (和 实现一个方法 没有区别)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">O</span> &#123;&#125; <span class="comment">// 可以不废话直接大括号了</span></span><br><span class="line">o.summarize <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure><p>孤儿规则?? #todo <span id="^bd02aa" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^bd02aa</span></p><p>特征也能用作 函数 入参 or 返回值 // 这不就是 java 接口吗…</p><h4 id="入参"><a class="markdownIt-Anchor" href="#入参"></a> 入参</h4><p>也叫特征约束</p><ul><li><code>fn notify(item: &amp;impl Summary)</code> 和 <code>fn notify2&lt;T: Summary&gt;(item: &amp;T)</code> 等价,前者是语法糖,但是异常好读.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;impl Summary 异常好读</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify2</span>&lt;T: Summary&gt;(item: &amp;T) &#123; <span class="comment">// 这才是实际的展开</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 限制入参类型 item1 item2 相同,就不能用语法糖了</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><p>多重约束: 几个特征一起来</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两者等价</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><p>要是泛型参数再多几个,每个的特征约束也再来几个…一行不敢看了… --&gt; Where 约束,换个写法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将泛型的约束 另起一行</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T&gt;(item: &amp;T) </span><br><span class="line">    <span class="keyword">where</span> T: Summary + Display</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 参数越多越有效</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>当特征 遇到 <a href="/jasper/xads23cva0dgew/#^pkn22t">方法泛型</a> = 为指定类型 指定特征 实现 方法</p><ul><li>这样的方式要比 java 接口更细致</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有 T 同时实现 Display 和 PartialOrd 特征时才可以调用 cmp_display</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回"><a class="markdownIt-Anchor" href="#返回"></a> 返回</h4><p>当作 返回值</p><ul><li>有一个限制: 即使 M N 都实现了 Summary,但返回两个类型时候 编译器还是提示报错;</li><li>这里得用 --&gt; <a href="/jasper/xads23cva0dgew/#特征对象">Rust 基础入门#特征对象</a></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">return_test</span>(flag: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">	M &#123;name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>),x: <span class="number">1</span>,&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回两个类型会报错</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">return_test</span>(flag: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> flag &#123;</span><br><span class="line">	    M &#123;name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>),x: <span class="number">1</span>,&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    N &#123;name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;N&quot;</span>),x: <span class="number">2</span>,&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他-2"><a class="markdownIt-Anchor" href="#其他-2"></a> 其他</h4><p>derive 派生特征: 类似注解,为对象实现默认特征</p><ul><li><code>#[derive(Debug)]</code>: 见过很多了, <code>println!(&quot;&#123;:?&#125;&quot;, s)</code> 可以打印整个结构体;</li><li><code>Copy</code></li><li>更多的参考 --&gt; <span class="exturl" data-url="aHR0cHM6Ly9jb3Vyc2UucnMvYXBwZW5kaXgvZGVyaXZlLmh0bWwjJUU5JTk5JTg0JUU1JUJEJTk1LWQlRTYlQjQlQkUlRTclOTQlOUYlRTclODklQjklRTUlQkUlODEtdHJhaXQ=">派生特征 trait<i class="fa fa-external-link-alt"></i></span></li></ul><p>调用方法时,需要特定 特征, as 又有很大限制 --&gt; <code>TryInto</code></p><ul><li>尝试将类型转换为另一个类型, 返回 <code>Result</code> 类型;</li><li>转换成功就包含值,转换失败就包含失败信息;</li></ul><h4 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h4><p>特征这里和其他概念交叉太多了,还是例子更好理解;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Point结构体派生Debug特征，用于格式化输出</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T: Add&lt;T, Output = T&gt;&gt; &#123; <span class="comment">//限制类型T必须实现了Add特征，否则无法进行+操作。</span></span><br><span class="line">    x: T, y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Add&lt;T, Output = T&gt;&gt; Add <span class="keyword">for</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, p: Point&lt;T&gt;) <span class="punctuation">-&gt;</span> Point&lt;T&gt; &#123;</span><br><span class="line">        Point&#123;x: <span class="keyword">self</span>.x + p.x,y: <span class="keyword">self</span>.y + p.y,&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: Add&lt;T, Output=T&gt;&gt;(a:T, b:T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point&#123;x: <span class="number">1.1f32</span>, y: <span class="number">1.1f32</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point&#123;x: <span class="number">2.1f32</span>, y: <span class="number">2.1f32</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(p1, p2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = Point&#123;x: <span class="number">1i32</span>, y: <span class="number">1i32</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p4</span> = Point&#123;x: <span class="number">2i32</span>, y: <span class="number">2i32</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(p3, p4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特征对象"><a class="markdownIt-Anchor" href="#特征对象"></a> 特征对象</h3><p>动态分发 / 动态分配</p><p>特征对象: 是一个引用, 指向 实现了 特征的 实例</p><ul><li>参数的关键词是 <code>dyn</code> 实际上是动态分发关键词</li><li>真正创建时: 对实例取 <code>&amp;</code> or <code>Box&lt;T&gt;</code><ul><li><code>Box&lt;T&gt;</code> 涉及智能指针, 被包裹的 T 会强制分配在 堆 上.</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123; <span class="comment">// 特征</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Draw default&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123; <span class="comment">// 为已有类型实现</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">&quot;Draw u8: &#123;&#125;&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw1</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;) &#123; <span class="comment">// Box | 声明时需要 dyn</span></span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>(); <span class="comment">// 这一步 Box 智能指针会自动解引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw2</span>(x: &amp;<span class="keyword">dyn</span> Draw) &#123; <span class="comment">// &amp; | 声明时需要 dyn</span></span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1.1_f64</span>; <span class="comment">// 实例</span></span><br><span class="line">    <span class="title function_ invoke__">draw1</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x)); <span class="comment">// 创建</span></span><br><span class="line">    <span class="title function_ invoke__">draw2</span>(&amp;x);<span class="comment">// &amp;实例 不再需要 dyn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征对象数组调用: components 元素仅实现了 Draw 特征,嗯 接口数组…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>(); <span class="comment">// 调用特征实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型实现 限定数组仅有一种元素</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span>&lt;T: Draw&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Draw &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态分发"><a class="markdownIt-Anchor" href="#动态分发"></a> 动态分发</h4><p>在运行时才能确定到底是那个实例的实现 --&gt; 动态分发</p><ul><li>相对的是静态分发, 类似于泛型的处理,编译时就完成了;</li></ul><p>具体就不展开了, 有点搞不懂…</p><h4 id="self-and-self"><a class="markdownIt-Anchor" href="#self-and-self"></a> Self and Self</h4><p>Self 代指 特征 or 方法类型 (class) | self 代指 实例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Self 代表的是 Button 类型</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够实现特征对象的 特征 == 要求 特征是 对象安全; 要求所有方法 (除了方法还有别的要求):</p><ul><li>方法返回类型不能是 <code>Self</code></li><li>方法没有任何泛型参数</li></ul><h3 id="特征-2"><a class="markdownIt-Anchor" href="#特征-2"></a> 特征 2</h3><p>特征内容实在太多了,这是第二个章节, 其实是很多其他特性 与 特征 的结合使用</p><h4 id="关联类型"><a class="markdownIt-Anchor" href="#关联类型"></a> 关联类型</h4><p>特征中叠加进 类型; 比泛型声明更加精简;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>; <span class="comment">// 关联类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;; <span class="comment">// Self::Item 返回定义的关联类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>; <span class="comment">// 关联类型实例化 👽</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123; <span class="comment">// 真正使用关联类型地方</span></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型能做到相同的事情</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关联类型 在多个参数时候, 能比泛型节约模板代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A B 泛型必须深入到每个地方...</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Container</span>&lt;A,B&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>,a: A,b: B) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">difference</span>&lt;A,B,C&gt;(container: &amp;C) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    C : Container&lt;A,B&gt; &#123;…&#125;</span><br><span class="line"><span class="comment">// 关联类型 仅在 特征内部, 其他实现中不再需要 大量泛型声明</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">A</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">B</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, a: &amp;<span class="keyword">Self</span>::A, b: &amp;<span class="keyword">Self</span>::B) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">difference</span>&lt;C: Container&gt;(container: &amp;C) &#123;&#125;</span><br></pre></td></tr></table></figure><p>似乎关联类型可以使用泛型了…已经是稳定版了…</p><h4 id="默认泛型类型参数"><a class="markdownIt-Anchor" href="#默认泛型类型参数"></a> 默认泛型类型参数</h4><p>这个和特征无关,任何用到泛型的地方都能用.</p><p>给泛型一个默认值 (T=i32), 在未指定泛型时,编译器使用默认值;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123; <span class="comment">// 给 RHS 来个默认值</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: RHS) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output; <span class="comment">// 这里使用了 泛型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;x: <span class="type">i32</span>,y: <span class="type">i32</span>,&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123; <span class="comment">// 注意这里并没有声明 泛型RHS, 那编译器直接用了 Self</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;x: <span class="keyword">self</span>.x + other.x,y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">3</span> &#125;,Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure><p>节省了很多模板代码… 仅此而已.</p><h4 id="完全限定语法-调用同名函数方法"><a class="markdownIt-Anchor" href="#完全限定语法-调用同名函数方法"></a> 完全限定语法 (调用同名函数/方法)</h4><p>结构体 实现 多个特征 和 方法, 这里每个结构都带有一个签名完全相同的函数…(闲的…)</p><ul><li>调用顺序是 结构体的方法</li><li>其他特征的方法需要显式调用 --&gt; 完全限定语法</li></ul><p>完全限定语法: <code>&lt;Path&gt;::&lt;Function&gt;(args)</code> 显式指明函数/方法/关联函数的完整路径</p><ul><li>特征的方法 <code>Pilot::fly(&amp;person);</code></li><li>多个特征的关联函数 <code>&lt;Dog as Animal&gt;::baby_name()</code> (注意 as 关键词)</li></ul><p>大部分情况下无需如此, rust 的编译器完全值得信赖.</p><h4 id="特征的特征约束"><a class="markdownIt-Anchor" href="#特征的特征约束"></a> 特征的特征约束</h4><p>泛型中能用 特征 作为约束条件, 那 特征也能作为 特征 的约束条件…// 直接说 类似 接口继承就完事了…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OutlinePrin 依赖于 Display 特征, 任何实现 OutlinePrin 的 类型 必须先实现 Display</p><h4 id="newtype"><a class="markdownIt-Anchor" href="#newtype"></a> Newtype</h4><p><span id="^d732f3" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^d732f3</span></p><p>没有什么是加一层解决不了的，如果不行那就再加一层… from 鲁迅没说过</p><p><a href="/jasper/xads23cva0dgew/#^bd02aa">孤儿规则</a> 的存在使得未在本作用域 定义的 特征 和 类型, 没法做啥文章, 但 newtype 绕过了这个限制… --&gt; 如直面意思,再包一层 (类型)</p><ul><li><code>Vec&lt;T&gt;</code> 和 <code>Display</code> 均定义在标准库,无法为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code></li><li>那可以 Wrapper 包含成员 <code>Vec&lt;T&gt;</code>, 为 Wrapper 实现 <code>Display</code> 啊.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br></pre></td></tr></table></figure><ul><li>这样的麻烦就是访问时候,还得 <code>x.a</code> 访问成员才行 --&gt; <span class="exturl" data-url="aHR0cHM6Ly9jb3Vyc2UucnMvYWR2YW5jZS9zbWFydC1wb2ludGVyL2RlcmVmLmh0bWwjZGVyZWYtJUU4JUE3JUEzJUU1JUJDJTk1JUU3JTk0JUE4">Deref 解引用<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="集合类型"><a class="markdownIt-Anchor" href="#集合类型"></a> 集合类型</h2><h3 id="动态数组-vector"><a class="markdownIt-Anchor" href="#动态数组-vector"></a> 动态数组 Vector</h3><p>这个才是其他编程语言中的数组…</p><p>Vetor: 单一类型; 动态扩容; 关键词 <code>Vec</code>;</p><p>声明: <code>Vec::new()</code> <code>vec![]</code></p><ul><li>已知数组大小 -&gt; <code>Vec::with_capacity(capacity)</code> 可以避免动态扩容的损耗</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(); <span class="comment">// 最 rust 的声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(); <span class="comment">// </span></span><br><span class="line">v2.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);<span class="comment">// 没这一句, 上面要报错 | 上文也有类似情况,到比较时候才能推定具体类型</span></span><br><span class="line"><span class="comment">// 声明兼初始化</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v3</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>单个访问: 索引 和 <code>get</code></p><ul><li><code>get</code> 返回 <code>Option&lt;&amp;T&gt;</code> 还需要 match 解才行, 索引倒是直接返回值,但遇空 可能会 挂掉</li><li>rust 意思是,反正我都给了,爱用那个用那个.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v3[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"><span class="keyword">match</span> v3.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里有个新的格式化输出, <code>&#123;third&#125;</code> 嗯又来 python 了 →_→</li></ul><p>更新: mut 还是必须的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">v[<span class="number">0</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>多个数组元素访问</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;first&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>这里肯定报错了 first 作用域内,出现了 <code>v.push(6);</code> 可变引用;</li><li>一方面是语法上限制,令一方面 Vec 动态数组 可能会动态扩容: 拷贝 再更新地址; 这样 first 可能指向无效内存….</li></ul><p>遍历: 自然是可以通过索引 来, 也能通过 迭代方式来,不用每次检查索引 还更快.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储不同类型: Vec 还是只能存储单一类型 --&gt; 枚举 or 特征对象</p><ul><li>特征对象要繁琐一些, 但更加灵活 更为常见</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[IpAddr::<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>()),IpAddr::<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>())];</span><br><span class="line"><span class="comment">// 特征对象 明显要繁琐很多</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V4</span>(<span class="type">String</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V4</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv4: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V6</span>(<span class="type">String</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V6</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv6: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> IpAddr&gt;&gt; = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),];</span><br></pre></td></tr></table></figure><h4 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h4><p><code>sort_unstable</code> 稳定 <code>sort_unstable_by</code> 非稳定; 非稳定更快, 稳定还需要额外空间</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">15</span>];    </span><br><span class="line">vec.<span class="title function_ invoke__">sort_unstable</span>();  </span><br><span class="line"><span class="comment">// 浮点数 </span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1.0</span>, <span class="number">5.6</span>, <span class="number">10.3</span>, <span class="number">2.0</span>, <span class="number">15f32</span>];    </span><br><span class="line">vec.<span class="title function_ invoke__">sort_unstable</span>();<span class="comment">// 直接报错 浮点数有 NAN 值无法比较</span></span><br><span class="line">vec.<span class="title function_ invoke__">sort_unstable_by</span>(|a, b| a.<span class="title function_ invoke__">partial_cmp</span>(b).<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 确认不含 NAN , 传入 partial_cmp 自定义比较</span></span><br></pre></td></tr></table></figure><p>结构体: 可以传入比较函数 or 实现 <code>Ord</code> 特征</p><ul><li><code>Ord</code> 特征依赖于 <code>Ord</code> <code>Eq</code> <code>PartialEq</code> <code>PartialOrd</code> --&gt; <code>derive</code> 注解</li><li>注解要求 结构体所有属性 均已经实现了 <code>Ord</code> 特征,否则报错</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>, age: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Person &#123;</span><br><span class="line">        Person &#123; name, age &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">people</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Zoe&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>),Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Al&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">60</span>),Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">1</span>),</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 定义一个按照年龄倒序排序的对比函数</span></span><br><span class="line">people.<span class="title function_ invoke__">sort_unstable_by</span>(|a, b| b.age.<span class="title function_ invoke__">cmp</span>(&amp;a.age));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `Ord` 特征 好在有注解</span></span><br><span class="line"><span class="meta">#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: <span class="type">String</span>, age: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Person &#123;</span><br><span class="line">        Person &#123; name, age &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">people</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Zoe&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>),Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Al&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">60</span>),Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Al&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">30</span>),</span><br><span class="line">    Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">1</span>),Person::<span class="title function_ invoke__">new</span>(<span class="string">&quot;John&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>),</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_ invoke__">sort_unstable</span>();</span><br></pre></td></tr></table></figure><h3 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h3><p>HashMap: 不在 prelude 中,因此需要 use xxx</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_gems</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">my_gems.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;红宝石&quot;</span>, <span class="number">1</span>);<span class="comment">// 将宝石类型和对应的数量写入表中</span></span><br></pre></td></tr></table></figure><p>#todo</p><h2 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h2><p>→_→ →_→ 终于到了号称最难的部分了 ←_← ←_←</p><ul><li>其实也还好, 类似于对象生命周期概念, 所有权 引用 作用域 搞清楚了,就没啥了…</li></ul><p>生命周期 = 实例的有效作用域,大部分情况下 rust 编译器已经足够了,用不到我们操心…但总有二般…</p><ul><li>多种类型存在,编译器会犯糊涂,此时就需要 手动标注,以方便编译器理解.</li></ul><p>生命周期标注 就是糊弄编译器,让其给代码开个通关文牒. <mark style="background:#ff5582A6">不会改变任何引用的实际作用域 !</mark></p><ul><li>标注: <code>'a</code> (单引号 +a 开始)</li><li><code>&amp;'a str'</code> 在 <code>&amp;</code> 后面</li><li>结构体和方法内 与 泛型位置基本一致</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, <span class="comment">// 结构体中使用引用类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123; <span class="comment">//`impl` 使用结构体的完整名称 包括 `&lt;&#x27;a&gt;`，生命周期标注也是结构体类型的一部分！</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="number">3</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>一般情况下编译器会智能推断生命周期 == 自动加上生命周期标记 -&gt; 生命周期消除 的规则 (第一条输入, 23 条是输出) <span id="^17576a" style="font-size:smaller;color:gray;vertical-align:top;opacity:.75">^17576a</span></p><ul><li>每个<mark style="background:#bbfABBA6">输入</mark>参数 标注上独立的生命周期:<ul><li><code>fn foo(x: &amp;i32, y: &amp;i32)</code> -&gt; <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code></li></ul></li><li>只有一个输入,其生命周期自动赋予所有输出:<ul><li><code>fn foo(x: &amp;i32) -&gt; &amp;i32</code> 仅有一个输入,则 <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code> x 的生命周期赋予 返回值</li></ul></li><li>输入中存在 <strong><code>&amp;self</code> or <code>&amp;mut self</code></strong>,所有输出默认与 <code>&amp;self</code> 一致<ul><li>方法狂喜,狂喜.</li></ul></li></ul><p>编译器按照生命周期消除规则 加上 标注, 还不过就报错.</p><p>实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;x&#125; else &#123;y&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第一个规则 -&gt; fn longest&lt;&#x27;a,&#x27;b&#x27;&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;str</span><br><span class="line">// 第2 3规则不满足略过,最终是 fn longest&lt;&#x27;a,&#x27;b&#x27;&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;str</span><br><span class="line">// 编译器无法确定返回值的生命周期, 报错</span><br><span class="line"></span><br><span class="line">impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123;</span><br><span class="line">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">        xxx</span><br><span class="line">&#125;&#125;</span><br><span class="line">// 第一个规则 -&gt; fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;str </span><br><span class="line">// 第2个不满足,第3个 -&gt; fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;&#x27;a str</span><br><span class="line">// 没啥问题,通过</span><br></pre></td></tr></table></figure><p>生命周期标注也有类似 泛型 约束的写法, 包括 where</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;b</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123; <span class="comment">// &#x27;a: &#x27;b 代表 &#x27;a 必须比 &#x27;b 活得久</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>,</span><br><span class="line">    &#123; <span class="keyword">self</span>.part &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总有些无解的生命周期吧 --&gt; <code>static</code> 我会活的和程序一样长</p><ul><li>存在即合理吧, 最后的解决就这个</li><li><code>&amp;'static</code>: 字符串常量 特征对象</li><li><code>T: 'static</code>: 泛型 or 一个奇迹</li></ul><p>最后来个例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h2><p>这里就和 go 没啥关系了;; 放心没有 <code>if err != nil &#123;&#125;</code></p><h3 id="panic"><a class="markdownIt-Anchor" href="#panic"></a> Panic</h3><p>做内核相关肯定不想看到这个…(⓿_⓿)</p><p><code>panic!</code> 直接输出恐慌</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;just for test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// runing</span></span><br><span class="line"><span class="comment">//thread &#x27;main&#x27; panicked at &#x27;just for test&#x27;, src/main.rs:2:5</span></span><br></pre></td></tr></table></figure><ul><li>恐慌信息: 代码的位置; 那个函数; 很正常</li></ul><p><code>$env:RUST_BACKTRACE=1 ; cargo run</code> 带 backtrace 展开调用的堆栈,方便追踪到底哪里出错了.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    v[<span class="number">99</span>]; <span class="comment">// panic!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vsc 调试直接带了 stack backtrace | 这里直接 cargo run</span></span><br><span class="line"><span class="comment">//thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 5 but the index is 99&#x27;, src/main.rs:3:5</span></span><br><span class="line"><span class="comment">//note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span></span><br><span class="line"><span class="comment">// $env:RUST_BACKTRACE=1 ; cargo run 呢?</span></span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">5</span> but the index is <span class="number">99</span>&#x27;, src/main.rs:<span class="number">3</span>:<span class="number">5</span></span><br><span class="line">stack backtrace:</span><br><span class="line">   <span class="number">0</span>: rust_begin_unwind</span><br><span class="line">             at /rustc/<span class="number">90</span>c541806f23a127002de5b4038be731ba1458ca/library/std/src/panicking.rs:<span class="number">578</span>:<span class="number">5</span></span><br><span class="line">    xxx</span><br><span class="line">   <span class="number">6</span>: hello_remote_world::main</span><br><span class="line">             at ./src/main.rs:<span class="number">3</span>:<span class="number">5</span></span><br><span class="line">   <span class="number">7</span>: core::ops::function::<span class="built_in">FnOnce</span>::call_once</span><br><span class="line">             at /rustc/<span class="number">90</span>c541806f23a127002de5b4038be731ba1458ca/library/core/src/ops/function.rs:<span class="number">250</span>:<span class="number">5</span></span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br></pre></td></tr></table></figure><p>panic 后,程序有两种方式善后:</p><ul><li>栈展开 (默认): 追踪哪里出错了,并打印详细信息.</li><li>直接终止: 直接退出,善后交给操作系统…</li><li><code>Cargo.toml</code> 中 <code>[profile.release] panic = 'abort'</code></li></ul><p>善后完成后, panic 的线程就终止了,但不影响其他线程, 因此不要在 main 线程 堆积过多逻辑;</p><p>panic 的包装 <code>unwrap</code> 和 <code>expect</code></p><ul><li>两者都会解析返回值 Result 类型, 遇到错误直接 panic</li><li><code>expect</code> 可以自定义错误信息,<code>unwrap</code> 则抛出默认错误信息</li><li>这俩一般仅在原型 / 调试 时候使用,有更好的办法处理 Result 类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span>: IpAddr = <span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>); <span class="comment">// 自定义错误信息</span></span><br></pre></td></tr></table></figure><h3 id="result-和"><a class="markdownIt-Anchor" href="#result-和"></a> Result 和 ?</h3><p><code>unwrap</code> 和 <code>expect</code> 比直接 panic 好了一点,但还是会 panic, 配合 match</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的做法 --&gt; match 匹配,传播错误; error 别 panic 犯不上… 但是…繁琐…繁琐…</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 打开文件，f是`Result&lt;文件句柄,io::Error&gt;`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="comment">// 打开文件成功，将file句柄赋值给f</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="comment">// 打开文件失败，将错误返回(向上传播)</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建动态字符串s</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// 从f文件句柄读取数据并写入s中</span></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="comment">// 读取成功，返回Ok封装的字符串</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="comment">// 将错误向上传播</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>?</code> 来了/ 嘿嘿 / 少了一大半代码… 作用完全一致.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>?</code> 是一个宏定义, 配合 Result 类型, ok 就立刻返回, 错误就向上抛出.</p><ul><li>一般在返回值是 Rsult 的 函数/方法 中使用 (Option 其实也行)</li><li>可以处理 错误类型转换 和 链式调用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?; <span class="comment">// 先打开文件 没错误 再读取 没错误</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>始终注意 <code>?</code> 的限制条件,需要一个变量来承载正确值; (不行就展开成 match 看看对不对)</li></ul><h2 id="包与模块"><a class="markdownIt-Anchor" href="#包与模块"></a> 包与模块</h2><p>有不同的等级</p><ul><li>Packages \ Crate \ Module</li></ul><p>Packages 顶级</p><ul><li>独享的 <code>Cargo.toml</code> 文件</li><li>3 种类型<ul><li>Binary Package: 即使 Package 嵌套也仅一个,入口一般是 <code>src/main.rs</code>,编译后是一个二进制文件.</li><li>Library Package: Package 嵌套时可以有多个,不能独立运行,只能供其他调用. 创建时会在 <code>src/package_name.rs</code></li><li>Tool Package: 辅助,代码生成,自动化测试等等.</li></ul></li></ul><p>Crate 层级更小一点,常见 <code>pub (crate)</code> 仅在包内公开</p><p>Module 更像 py 的 <code>__int__.py</code></p><ul><li><code>mod xxx</code> 创建新模块,其他地方能引用的.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绝对路径引用</span></span><br><span class="line">crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"><span class="comment">// 相对路径引用</span></span><br><span class="line">front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"><span class="comment">// 还是相对路径,但是 父module </span></span><br><span class="line">super::serve_order</span><br><span class="line"><span class="comment">// 同 module 下</span></span><br><span class="line">self::back_of_house::<span class="title function_ invoke__">cook_order</span>()</span><br></pre></td></tr></table></figure><p>rust 中子 Module 都是对 父 Module 隐藏的…</p><ul><li>pub 结构体 字段还是隐藏的///</li><li>pub 枚举 成员就全部公开…</li></ul><p>文件夹作为模块:</p><ul><li>目录下创建 <span class="exturl" data-url="aHR0cDovL21vZC5ycw==">mod.rs<i class="fa fa-external-link-alt"></i></span>,再指定 哪些模块是公开暴露的.</li><li>另一种方式是 <span class="exturl" data-url="aHR0cDovL3huLS02a3F0ajc5ZjhzY2V0a3BzanAxbC5ycw==">创建于文件夹名.rs<i class="fa fa-external-link-alt"></i></span> ,内容同上, 不过可以避免大量的 <span class="exturl" data-url="aHR0cDovL21vZC5ycw==">mod.rs<i class="fa fa-external-link-alt"></i></span>.</li></ul><h3 id="use"><a class="markdownIt-Anchor" href="#use"></a> Use</h3><p>不管那个文件,先 <code>use</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绝对路径 | 模块</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 相对路径 | 函数</span></span><br><span class="line"><span class="comment">// 函数与模块仅颗粒度不同</span></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting::add_to_waitlist;</span><br><span class="line"><span class="comment">// 同名可以通过模块名区分</span></span><br><span class="line"><span class="comment">// 也能通过 as 别名</span></span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入后的模块/函数 都是私有的,如果需要二次暴露, 得</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#125; 可以省略部分重复</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"><span class="comment">// 一次性导入全部函数</span></span><br><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure><p>可见性 pub</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> 意味着可见性无任何限制</span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) 表示在当前包可见</span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">self</span>) 在当前模块可见</span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) 在父模块可见</span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> &lt;path&gt;) 表示在某个路径代表的模块中可见，其中 path 必须是父模块或者祖先模块</span><br></pre></td></tr></table></figure><h2 id="注释-文档"><a class="markdownIt-Anchor" href="#注释-文档"></a> 注释 / 文档</h2><p>按照分级</p><ul><li>代码注释: <code>//</code> or <code>/* */</code></li><li>文档注释: <code>///</code> or <code>/** */</code> 甚至包括测试用例 (和 py 很像)</li><li>包和模块注释</li></ul><p>文档注释</p><ul><li>需要位于 <code>lib</code> 类型的包中，例如 <code>src/lib.rs</code> 中</li><li>被注释的对象需要使用 <code>pub</code> 对外可见</li><li>可以使用 <code>markdown</code></li><li>文档注释是给用户看的，<mark style="background:#fff3A3A6">内部实现细节不应该被暴露出去</mark></li></ul><p>包和模块注释</p><p>文档测试<br>#todo</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Jasper</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jasper1024.com/jasper/xads23cva0dgew/" title="Rust 基础入门">https://jasper1024.com/jasper/xads23cva0dgew/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/rust/" rel="tag"># rust</a></div><div class="post-nav"><div class="post-nav-item"><a href="/jasper/20230807103007/" rel="prev" title="uintr 用户中断流程梳理"><i class="fa fa-angle-left"></i> uintr 用户中断流程梳理</a></div><div class="post-nav-item"><a href="/jasper/20230903093108/" rel="next" title="Gitea 小记 自建 &amp; Action">Gitea 小记 自建 & Action <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-disqus">disqus</a></li><li class="tab"><a href="#comment-utterances">utterances</a></li></ul><div class="tab-content"><div class="tab-pane disqus" id="comment-disqus"><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><div class="tab-pane utterances" id="comment-utterances"><div class="comments utterances-container"></div></div></div></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">JasperHale</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">20:54</span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phc3Blci0xMDI0" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"jasper1024","count":true,"i18n":{"disqus":"disqus"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/disqus.min.js" defer></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Jasper-1024/blog_discuss","issue_term":"pathname","theme":"github-dark"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/utterances.min.js" defer></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>