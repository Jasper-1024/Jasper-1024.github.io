<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="M2t8cZr5nIzHmltyt7Utj3nWYxNyNkCzFyigXBHkGUs"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"jasper1024.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"vs2015","dark":"vs2015"},"prism":{"light":"prism-vsc-dark-plus","dark":"prism-vsc-dark-plus"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"disqus","order":-1},"utteranc":{"text":"utteranc","order":-2}}},"stickytabs":true,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/config.min.js" defer></script><meta name="description" content="bash 速描   资料来源:  https:&#x2F;&#x2F;wangdoc.com&#x2F;bash&#x2F;index.html    更新 12345620.05.19 初始化20.05.22 变量20.05.23 字符串20.05.24 行操作20.05.26 条件判断20.05.27 函数"><meta property="og:type" content="article"><meta property="og:title" content="bash 速描"><meta property="og:url" content="https://jasper1024.com/jasper/iomhgyb7831da/index.html"><meta property="og:site_name" content="默"><meta property="og:description" content="bash 速描   资料来源:  https:&#x2F;&#x2F;wangdoc.com&#x2F;bash&#x2F;index.html    更新 12345620.05.19 初始化20.05.22 变量20.05.23 字符串20.05.24 行操作20.05.26 条件判断20.05.27 函数"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-05-19T19:00:00.000Z"><meta property="article:modified_time" content="2023-12-14T21:22:55.000Z"><meta property="article:author" content="Jasper"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jasper1024.com/jasper/iomhgyb7831da/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jasper1024.com/jasper/iomhgyb7831da/","path":"jasper/iomhgyb7831da/","title":"bash 速描"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>bash 速描 | 默</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-207687331-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-207687331-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/analytics/google-analytics.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/comments.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/utils.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/motion.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/sidebar.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/next-boot.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/pjax.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/search/local-search.min.js" defer></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/pdf.min.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.10.1/dist/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/mermaid.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/fancybox.min.js" defer></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ItayEcWO7OsLFKF2Y8SsAYG1-MdYXbMMI","app_key":"18UBQFmJXXcOQFebLovT36lh","server_url":null,"security":false}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/statistics/lean-analytics.min.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/quicklink@3.0.1/dist/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://jasper1024.com/jasper/iomhgyb7831da/"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/quicklink.min.js" defer></script><link rel="stylesheet" href="source/_data/callout_blocks.css"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="默" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">默</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">生存是唯一的长路</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">45</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">330</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">65</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-comments fa-fw"></i>留言</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%AF%AD"><span class="nav-number">1.</span> <span class="nav-text">导语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">基础语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E6%8B%93%E5%B1%95"><span class="nav-number">4.</span> <span class="nav-text">模式拓展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%8F%B7%E5%92%8C%E8%BD%AC%E4%B9%89"><span class="nav-number">5.</span> <span class="nav-text">引号和转义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">6.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">字符串操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">8.</span> <span class="nav-text">算术运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">9.</span> <span class="nav-text">行操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E5%A0%86%E6%A0%88"><span class="nav-number">10.</span> <span class="nav-text">目录堆栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8"><span class="nav-number">11.</span> <span class="nav-text">脚本入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#read-%E5%91%BD%E4%BB%A4"><span class="nav-number">12.</span> <span class="nav-text">Read 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">13.</span> <span class="nav-text">条件判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">14.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">16.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-number">16.1.</span> <span class="nav-text">创建数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E7%BB%84"><span class="nav-number">16.2.</span> <span class="nav-text">读取数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-%E5%91%BD%E4%BB%A4"><span class="nav-number">16.3.</span> <span class="nav-text">Set 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shopt-%E5%91%BD%E4%BB%A4"><span class="nav-number">16.4.</span> <span class="nav-text">Shopt 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E9%99%A4%E9%94%99"><span class="nav-number">16.5.</span> <span class="nav-text">脚本除错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mktemp-%E5%91%BD%E4%BB%A4"><span class="nav-number">16.6.</span> <span class="nav-text">Mktemp 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trap-%E5%91%BD%E4%BB%A4"><span class="nav-number">16.7.</span> <span class="nav-text">Trap 命令</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Jasper" src="/images/avatar.jfif"><p class="site-author-name" itemprop="name">Jasper</p><div class="site-description" itemprop="description">微尘</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">330</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phc3Blci0xMDI0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jasper-1024"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><a href="/ljy087621@gmail.com" title="E-Mail → ljy087621@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly94LmNvbS9KYXNwZXJfMTAyNA==" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;Jasper_1024"><i class="fab fa-twitter fa-fw"></i>Twitter</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL2phc3BlcjEwMjQ=" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;jasper1024"><i class="fab fa-skype fa-fw"></i>Telegram</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fas fa-rss fa-fw"></i>RSS</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tLw==" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;">forecho</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tL2ZyaWVuZHNoaXAtbGlua3Mv" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;friendship-links&#x2F;">友链聚合</span></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jasper1024.com/jasper/iomhgyb7831da/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jfif"><meta itemprop="name" content="Jasper"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="默"><meta itemprop="description" content="微尘"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="bash 速描 | 默"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">bash 速描</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-05-19 19:00:00" itemprop="dateCreated datePublished" datetime="2020-05-19T19:00:00Z">2020-05-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-14 21:22:55" itemprop="dateModified" datetime="2023-12-14T21:22:55Z">2023-12-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/shell/" itemprop="url" rel="index"><span itemprop="name">shell</span></a> </span></span><span id="/jasper/iomhgyb7831da/" class="post-meta-item leancloud_visitors" data-flag-title="bash 速描" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/jasper/iomhgyb7831da/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="jasper/iomhgyb7831da/" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li><p>bash 速描</p></li><li><p>资料来源:</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9iYXNoL2luZGV4Lmh0bWw=">https://wangdoc.com/bash/index.html<i class="fa fa-external-link-alt"></i></span></p></blockquote></li><li><p>更新</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20.05</span>.<span class="number">19</span> 初始化</span><br><span class="line"><span class="number">20.05</span>.<span class="number">22</span> 变量</span><br><span class="line"><span class="number">20.05</span>.<span class="number">23</span> 字符串</span><br><span class="line"><span class="number">20.05</span>.<span class="number">24</span> 行操作</span><br><span class="line"><span class="number">20.05</span>.<span class="number">26</span> 条件判断</span><br><span class="line"><span class="number">20.05</span>.<span class="number">27</span> 函数</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h2 id="导语"><a class="markdownIt-Anchor" href="#导语"></a> 导语</h2><ul><li>重刷一遍 bash.</li><li>最开始接触 bash 是跟着 鸟哥的 linux 私房菜,之后没有太多应用就放弃了.然而现在又到了大量需要时候…</li><li>正好阮一峰老师的 <a href="www.ruanyifeng.com/blog/2020/04/bash-tutorial.html">bash 教程</a> 发布了,wsl2 也随着 win10 2004 到了正式版中,条件成熟,开搞.</li></ul><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><ul><li>shell,这个词听说了很久,所谓 shell ,相对于 kernel 而言,就是壳的意思.</li><li>shell 可以说是用户通过命令与内核交互的途径.shell 可以有很多种,我们熟悉的 sh bash zsh 就是几种常见的 shell 类型.</li><li>使用最广的自然是 bash 了 (其实挺想学学 zsh 的,但是别着急).</li><li>2019 年 bash 最新版本是 <code>5.0.3(1)-release</code>.</li><li>这一篇仅仅是 bash 的速描,而非教程.</li></ul><h2 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h2><ul><li>echo(ow 新英雄😂)<ul><li>文本输出到屏幕</li><li>多行需要 “”</li><li>-n: 去掉默认会在文本末尾添加的 \n 换行符.</li><li>-e: 解释 “” 内部的特殊字符,没有 -e 例如 \n 就会直接输出 \n 字符,而不是换行.</li></ul></li><li>命令格式<ul><li>基本上是 <code>$ command [ arg1 … [ argN ]]</code></li><li>命令 + 参数 1 …参数 N</li><li>一般参数有两种<ul><li><code>-</code>: 短形式,简写,在命令行居多.</li><li><code>--</code>: 长形式,脚本中居多.</li></ul></li><li>多行编辑时,通过 \ 连接多行命令,执行时会合并成一行.</li></ul></li><li>空格<ul><li>bash 的不同参数之间以空格区分</li><li>会忽略多个空格</li></ul></li><li>分号<ul><li>分割两个命令</li><li>即使第一个命令执行失败,第二个命运也会继续执行.</li></ul></li><li>命令组合<ul><li><code>Command1 &amp;&amp; Command2</code>: 只有命令 1 执行成功,才执行命令 2.</li><li><code>Command1 || Command2</code>: 不管命令 1 执行如何,始终执行命令 2.</li></ul></li><li>type 命令<ul><li>可以区分命令本身来源于内置命令,还是外部程序.</li><li>type 本身也是内置命令</li><li>-a: 输出命令的全部定义</li><li>-t: 返回命令的全部类型,<ul><li>别名 alias</li><li>关键字 keyword</li><li>函数 function</li><li>内置命令 builtin</li><li>文件 file</li></ul></li></ul></li><li>快捷键<ul><li><code>Ctrl + L</code>: 清屏,把当前行移动到页面最上位置.</li><li><code>Ctrl + C</code>: 中断命令</li><li><code>Ctrl + U</code>: 由光标位置,删除到行首</li><li><code>Ctrl + K</code>: 由光标位置,删除到行末</li><li><code>Ctrl + D</code>: 等于 exit</li><li><code>Shift + PageUP</code>: 向上滚动</li><li><code>Shift + PageDown</code>: 向下滚动</li></ul></li><li>TAB 补全,如果遇到无法补全,检查一下 <code>bash-completion</code> 这个插件,装没装.</li></ul><h2 id="模式拓展"><a class="markdownIt-Anchor" href="#模式拓展"></a> 模式拓展</h2><ul><li>如果要完成一项复杂的工作,纯粹的 shell 命令会烦死的,由此引入的模式拓展.</li><li>模式拓展,大概是将 <code>?*</code> 等等通过预定的模式展开成原始的命令,最大的作用是省纸.</li><li>有点类似于正则啊,实际上模式拓展要早于正则,但是模式拓展要简单方便很多.</li><li>当然模式拓展是可关闭的.<code>set -f</code> 关闭,<code>set +f</code> 打开.</li><li>波浪线拓展<ul><li>~: 用户当前的主目录</li><li>~user: 用户 user 的主目录.</li><li>~+: =pwd 当前目录</li></ul></li><li><code>?</code> 字符拓展<ul><li><code>?</code>: 文件路径中任意的单字符,不包括空字符.</li><li>如果匹配的文件存在才进行转换,否则只是输出成 <code>?</code> 本身.</li></ul></li><li><code>*</code> 字符拓展<ul><li><code>*</code>: 文件路径中任意数量的任意字符 (类似正则的 <code>.*</code>)</li><li><code>.*</code>: 匹配隐藏文件.</li><li><code>.[!.]*</code>: 排除 <code>.</code> <code>..</code> 以外的隐藏文件,以 <code>.</code> 开头,第二个字符不是 <code>.</code>,之后是任意字符.</li><li><code>**/*</code>: 匹配包括任意层级子目录的任意文件.</li><li>只有文件确实存在时,才会进行转换,否则只是输出 <code>*</code> 本身.</li></ul></li><li>方括号拓展<ul><li><code>[..]</code>: 一个方括号内任意字符.</li><li><code>[^..]</code> 或 <code>[!..]</code>: 任何一个不在方括号内任意字符</li><li><code>[[..]</code>: 匹配 <code>[</code> 这个字符本身.</li><li><code>[-..]</code> 或 <code>[..-]</code>: 匹配 <code>-</code> 这个字符时,只能放在开头或结尾.</li><li>只有文件确实存在时,才会进行转换,否则只是输出 <code>[..]</code> 本身.</li></ul></li><li><code>[start-end]</code> 拓展<ul><li><code>[a-z]</code>: 所有小写字母任意一个</li><li><code>[a-zA-Z]</code>: 所有小写大写字母任意一个</li><li><code>[a-zA-Z0-9]</code>: 所有大小写字母和数字任意一个</li><li><code>[!a-zA-Z]</code>: 除了英文字母以外的任意一个字符</li></ul></li><li>大括号拓展<ul><li><strong>非文件拓展,会自动转换成所有值</strong></li><li><code>&#123;…&#125;</code>: 自动拓展成大括号内所有值,各个值期使用逗号隔开.逗号前后不能有空格.</li><li><code>&#123;j&#123;p,pe&#125;g,png&#125;</code>: 大括号嵌套,可以一定程度上当生成器了</li><li><code>&#123;cat,d*&#125;</code>: 大括号可以与其它模式连用,但是大括号总是优先于其他模式.这里就是匹配 <code>cat</code> 和 <code>d*</code> 的文件.</li></ul></li><li>{start…end} 扩展,类似中括号 <code>[start-end]</code><ul><li><code>&#123;a..c&#125;</code>: a b c</li><li><code>&#123;1..4&#125;</code>: 1 2 3 4</li><li><code>&#123;c..b&#125;</code>: c b a</li><li><code>&#123;4..1&#125;</code>: 4 3 2 1</li><li><code>&#123;01..5&#125;</code>: 01 02 03 04</li><li><code>&#123;0..8..2&#125;</code>: 0 2 4 6 8 (步长是 2)</li><li>无法转换的简写,原样输出.</li></ul></li><li>变量拓展<ul><li>以一个 <code>$</code> 代表变量值…嗯…kotlin 有这味.</li><li><code>$value</code>: 拓展成对应变量值</li><li><code>$&#123;value&#125;</code>: 同上.</li><li><code>$&#123;!string*&#125;</code> 或 <code>$&#123;!string@&#125;</code>: 返回所有匹配给定字符串 string 的变量名</li></ul></li><li>子命令拓展<ul><li><code>$(…)</code>: 将括号内的命令运行结果作为拓展输出.</li><li>$ `…`: 同上.</li><li>可以嵌套.</li></ul></li><li>算术拓展<ul><li><code>echo $((2 + 2))</code>: 结果拓展为 4 .</li></ul></li><li>字符类<ul><li><code>[[:class:]]</code>: 表示一个字符类,扩展成某一类特定字符之中的 <strong>一个</strong>.</li><li>当没有匹配时,会直接输出.</li><li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li><li><code>[[:alpha:]]</code>：匹配任意英文字母</li><li><code>[[:blank:]]</code>：空格和 Tab 键</li><li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符</li><li><code>[[:digit:]]</code>：匹配任意数字 0-9</li><li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号</li><li><code>[[:lower:]]</code>：匹配任意小写字母 a-z</li><li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符</li><li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）</li><li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）</li><li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z</li><li><code>[[:xdigit:]]</code>：16 进制字符（A-F、a-f、0-9）</li><li>例子:<ul><li><code>$ echo [[:upper:]]*</code>: 所有以大写字母开头的文件.</li><li><code>$ echo [![:digit:]]*</code>: 所有不以数字开头的文件</li></ul></li></ul></li><li>量词语法<ul><li>量词语法控制拓展的匹配次数.由 <code>extglob</code> 参数控制,一般是开着的.</li><li>当没有匹配时,原样输出.</li><li><code>?(pattern-list)</code>：0 或 1</li><li><code>*(pattern-list)</code>：0 或 多</li><li><code>+(pattern-list)</code>：1 或 多</li><li><code>@(pattern-list)</code>：1</li><li><code>!(pattern-list)</code>：匹配零个或一个以上的模式，但不匹配单独一个的模式 (??)</li><li>例子<ul><li><code>abc?(.)txt</code>: 不取 或 只取第一个符合开头 abc 结尾 .txt 的文件</li><li><code>abc+(.txt|.php)</code>: 不取 或 匹配多个以 adc 开头,结尾是 .txt 或 .php 的文件</li></ul></li></ul></li><li>匹配注意点<ul><li>通配符是先拓展再执行.</li><li>文件名拓展不存在匹配时,基本都是按照原样输出.</li><li>通配符文件名拓展一般只适用于本层路径.子路径需要声明子路径才行 <code>xx/xx</code>.也可以使用 <code>**/xx</code>,直接匹配所有的文件 (不可控).</li><li>Bash 允许文件名使用通配符,即文件名包括特殊字符,这时引用文件名,需要把文件名放在单引号里面.<code>fo*</code>.</li></ul></li><li>shopt 命令<ul><li>shopt 命令可以调整 Bash 的行为.<ul><li><code>$ shopt -s [optionname]</code>: 打开某个参数</li><li><code>$ shopt -u [optionname]</code>: 关闭某个参数</li><li><code>$ shopt [optionname]</code>: 查询某个参数关闭还是打开</li></ul></li><li><code>dotglob</code>: 拓展结果包含隐藏文件</li><li><code>nullglob</code>: 拓展没有结果时,返回空字符.</li><li><code>failglob</code>: 拓展没有结果时,直接报错,不再执行.</li><li><code>extglob</code>: Bash 支持 ksh 的一些扩展语法,量词拓展就是之一.</li><li><code>nocaseglob</code>: 通配符拓展不再区分大小写.</li><li><code>globsta</code>: <code>**</code> 匹配零个或多个子目录,默认是关闭的.</li></ul></li></ul><h2 id="引号和转义"><a class="markdownIt-Anchor" href="#引号和转义"></a> 引号和转义</h2><ul><li>bash 只有字符串一直类型的变量.对应特殊字符有一套转义的规则,整体和 c/kotlin 差不多.</li><li>转义<ul><li>输出特殊字符 <code>\</code> + 特殊字符 <code>$ * &amp;</code></li><li><code>\\</code> 输出自身</li><li><code>\a</code> 响铃 (??); <code>\b</code> 退格; <code>\n</code> 换行; <code>\r</code> 回车; <code>\t</code> 制表符 (??)</li></ul></li><li>单引号<ul><li>单引号内部所有字符均视为普通字符,不会有拓展的效果.</li><li>单引号内部使用单引号,<code>$`it\'s'</code> 需要在外层单引号前加 <code>$</code>,同时在 单引号前 + 转义.</li><li>比较合理的做法是在双引号中使用单引号.</li></ul></li><li>双引号<ul><li>大部分特殊字符,双引号会保留原意,除 <code>$ ` \</code> 除外,会自动拓展.</li><li>特别留意 <code>*</code> 在双引号中也只是普通字符,不会进行文件名拓展.</li><li>文件名包含空格,必须使用双引号.<code>test kot.txt</code>,而且双引号会原样保持多余空格.</li><li>双引号还能保存原始命令的输出格式.如果没有双引号,基本都堆到了单行.<code>echo &quot;$(cal)&quot;</code></li></ul></li><li>Here 文档<ul><li><p>一种输入多行字符串的方法.</p></li><li><p>格式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt; <span class="string">token</span></span><br><span class="line"><span class="string">text</span></span><br><span class="line"><span class="string">token</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;&lt; token</code>: 开始标记,<code>&lt;&lt;</code> 打头,之后是文件名,文件名任意,但最后一个必须是换行符.</li><li><code>token</code>: 结束标记,文件名,必须是定格.</li><li>中间是多行的字符串内容</li></ul></li><li><p>Here 内部变量替换,转义字符依旧有效,但拓展和单引号双引号失效.</p></li><li><p>如果不希望有变量替换,可以将开始标记的文件名加上单引号.<code>&lt;&lt; `example`</code></p></li><li><p>Here 文档的本质是重定向,将字符串重定向到了某个命令,相当于加了 <code>echo</code>.<code>echo string | command</code></p></li><li><p>因此 Here 文档只能适用于那些接收标准输入为参数的命令.</p></li></ul></li><li>Here 字符串<ul><li>算是 Here 文档的变体,使用 <code>&lt;&lt;&lt; string</code> 将字符串通过标准输入传递给命令.</li><li>原理大致相同,等同于添加了 <code>echo</code>.</li></ul></li></ul><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><ul><li><p>bash 下的变量分为两种,一是环境变量,另一个是自定义变量.</p><ul><li>环境变量是 bash 自带的变量,由系统定义.</li><li>自定义变量即用户自行定义,当关闭 shell 后就不再存在.</li><li><code>env</code>: 输出所有环境变量.</li><li><code>echo xx</code>: 输出单个变量.</li><li><code>set</code>: 输出所有变量及 bash 函数.</li></ul></li><li><p>创建变量</p><ul><li>变量名通常是大写字母表示.(约定俗成)</li><li>bash 区分大小写.</li><li>字母/数字/下划线.</li><li>开头必须是字母/下划线.</li><li>不允许空格/标点符号.</li><li>所有类型均为字符串.</li><li>变量值有空格等,需要单/双引号.</li></ul></li><li><p>读取变量</p><ul><li><code>$xxx</code> 或 <code>$&#123;xxx&#125;</code>: 读取变量</li><li><code>\$</code>: 要正常使用 <code>$</code>,需要转义.</li><li><code>$&#123;!xxx&#125;</code>: 如果变量值本身是另一个变量,可以加 ! 读取到最终的值.</li></ul></li><li><p>删除变量</p><ul><li><code>unset NAME</code>: 删除变量,但是并不怎么好用…变量都是字符串类型,删除后还是空字符串.</li><li><code>NAME=''</code> 或 <code>NAME=</code>: 都等同于 <code>unset</code>.</li></ul></li><li><p>输出变量 (更多是传递变量吧)</p><ul><li><code>export xxx</code>: 子 shell 可以读取到父 shell 对应的变量值.而且修改不影响父 shell.(类似继承)</li></ul></li><li><p>特殊变量</p><ul><li>由 shell 定义,用户只能使用不能赋值.</li><li><code>$?</code>: 上一个命令的退出码,为 0 ,则上一条命令执行成功.</li><li><code>$$</code>: 当前 shell 的 pid.</li><li><code>$_</code>: 上一个命令的最后参数.</li><li><code>$!</code>: 最近一个后台执行异步命令的进程 id .</li><li><code>$0</code>: 当前 shell 的名称.</li><li><code>$-</code>: 当前 shell 的启动参数.</li><li><code>$@</code> <code>$#</code>: 脚本的参数数量.</li></ul></li><li><p>变量的默认值</p><ul><li>Bash 可以通过默认值防止变量为空.</li><li><code>$&#123;varname:-word&#125;</code>: varname 空返回 word.</li><li><code>$&#123;varname:=word&#125;</code>: varname 空设置 varname=word 并返回.</li><li><code>$&#123;varname:+word&#125;</code>: varname 存在且不为空,返回 word,否则返回空值.这是个测试命令.</li><li><code>$&#123;varname:?message&#125;</code>: varname 为空,打印 varname: message 并中断脚本的执行.防止变量未定义.</li></ul></li><li><p>declare 命令</p><ul><li>declare 可以为变量设置一些限制.像只读,整数类型等.</li><li><code>declare OPTION VARIABLE=value</code>: 基本格式</li><li><code>-i</code>: 声明整形参数,可以直接运算了.但是即使声明成整形了,依然可以被改写成其他字符串.</li><li><code>-x</code>: 等同于 export ,可以将变量继承到子 shell.</li><li><code>-r</code>: 声明只读变量,unset 也不行.</li><li><code>-u</code>: 声明为大写字母,自动将变量值的小写转大写…(强迫症专用)</li><li><code>-l</code>: 声明为小写字母,同上 (强迫症专用)</li><li><code>-p</code>: 输出变量信息,不指定会输出全部.</li><li><code>-f</code>: 输出当前环境所有函数,包括定义.</li><li><code>-F</code>: 输出当前环境所有函数,不包括定义.</li></ul></li><li><p>readonly 命令</p><ul><li>单 readonly 等同于 <code>declare -r</code> 只读.</li><li>参数<ul><li><code>-f</code>: 声明变量为函数名</li><li><code>-p</code>: 打印出所有只读变量</li><li><code>-a</code>: 声明变量为数组</li></ul></li></ul></li><li><p>let 命令</p><ul><li><code>let foo=1+2</code>: 可以直接执行运算.</li><li><code>let &quot;foo = 1 + 2&quot;</code>: 运算包含空格,需要引号.</li><li><code>let &quot;v1 = 1&quot; &quot;v2 = v1++&quot;</code>: 多个表达式可以用空格隔离.</li></ul></li></ul><h2 id="字符串操作"><a class="markdownIt-Anchor" href="#字符串操作"></a> 字符串操作</h2><ul><li><p>字符串是 bash 唯一的变量类型,这一节是对字符串的操作.</p></li><li><p>字符串长度</p><ul><li><p>实例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;#varname&#125;</span> : 输出字符串长度,大括号必须,否则 `<span class="variable">$#</span>` 会被拓展成脚本的参数个数.</span><br></pre></td></tr></table></figure></li></ul></li><li><p>子串提取</p><ul><li><code>$&#123;varname:offset:length&#125;</code>: 返回 varname 的子串,从 offset 长度为 length.索引从 0 开始.</li><li><code>&#123;varname:offset:length&#125;</code>: 同上,但 <code>$</code> 可省略</li><li><code>$&#123;varname:offset&#125;</code>: 从 offset 开始一直到结尾.</li><li><code>$&#123;varname: offset:length&#125;</code>: 这里 offset 可以为负值,但是前面需要加一个空格隔开.而且 length 必须大于 0.</li></ul></li><li><p>搜索和替换 (原始变量并不会被改变)</p><ul><li><code>$&#123;variable#pattern&#125;</code>: 从头开始,非贪婪匹配,删除匹配部分并返回.</li><li><code>$&#123;variable##pattern&#125;</code>: 从头开始,贪婪匹配,删除匹配部分并返回.</li><li><code>$&#123;variable%pattern&#125;</code>: 从尾开始,非贪婪匹配,删除匹配部分并返回.</li><li><code>$&#123;variable%%pattern&#125;</code>: 从尾开始,贪婪匹配,删除匹配部分并返回.</li><li>匹配部分可以有个 <code>* ? []</code> 等,具体模式与上文相同.</li><li>没有匹配时,会直接原样返回.</li><li><code>$&#123;variable/pattern/string&#125;</code>: 贪婪匹配,但仅替换第一个匹配.</li><li><code>$&#123;variable//pattern/string&#125;</code>: 贪婪匹配,替换所有.</li><li><code>$&#123;variable/#pattern/string&#125;</code>: 模式必须在字符串开头</li><li><code>$&#123;variable/%pattern/string&#125;</code>: 模式必须在字符串的结尾.</li></ul></li><li><p>改变大小写</p><ul><li><code>$&#123;varname^^&#125;</code>: 转为大写</li><li><code>$&#123;varname,,&#125;</code>: 转为小写</li></ul></li></ul><h2 id="算术运算"><a class="markdownIt-Anchor" href="#算术运算"></a> 算术运算</h2><ul><li>虽然 bash 变量都是字符串,但是还是能运算的.</li><li>算术表达式<ul><li><code>((…))</code>: 自动运算双括号内算术,并且忽略算式空格.结果如果为 0 算是命令执行失败.<code>$?</code> 会查询到非 0.</li><li><code>$((…))</code>: 这样就算是算术表达式,可以返回算术的值.</li><li><code>+ - * %</code>: 没啥区别</li><li><code>/</code>: 整除,结果是整数.</li><li><code>**</code>: 指数</li><li><code>++ --</code>: 与 c 相同,有前后之分.前面有命令根据位置会有先运算还是先执行命令的差别.</li><li><code>$(( (2 + 3) * 4 ))</code>: 内部可以使用括号,优先级最高.</li><li><code>echo $(($((5**2)) * 3))</code>: <code>$((…))</code> 可以嵌套,但是只能计算整数,否则报错.</li><li>算术表达式内可以加 <code>$varname</code>,也可以不加 <code>varname</code>,如果对应的变量并不存在,对应会返回空值.</li><li>ps: 还有一种写法是 <code>$[…]</code>,已经过时了,不要再用了.</li></ul></li><li>进制<ul><li>bash 默认是十进制,当然也能使用其他进制.</li><li><code>0number</code>: 8 进制</li><li><code>0xnumber</code>: 16 进制</li><li><code>base#number</code>: base 进制的数.</li></ul></li><li>位运算 (跟 c 差不多)<ul><li><code>&lt;&lt;</code>: 左移</li><li><code>&gt;&gt;</code>: 右移</li><li><code>&amp;</code>: 与运算</li><li><code>|</code>: 或运算</li><li><code>~</code>: 取反</li><li><code>^</code>: 亦或</li><li>位运算一般配合 8/16 进制数.</li></ul></li><li>逻辑运算<ul><li><code>&lt;; &gt;; &lt;=; &gt;=; ==; !=; &amp;&amp;; ||; !</code>: 与 c 完全相同.</li><li><code>expr1?expr2:expr3</code>: 支持三目运算符让我有点意外.</li><li>逻辑表达式为真返回 1,假返回 0.(跟 c 一样)</li></ul></li><li>赋值运算<ul><li><code>$((…))</code>: 执行赋值运算.</li><li>支持的运算符 <code>=; +=; -=; *=; /=; %=; &lt;&lt;=; &gt;&gt;=; &amp;=; |=; ^=;</code></li><li>跟 c 也一样.</li></ul></li><li>求值运算<ul><li><code>echo $((foo = 1 + 2, 3 * 4))</code>: 在 <code>$((…))</code> 双括号内, <code>,</code> 是求值运算符.</li><li>上面的表达式会输出 12 ,然后对 foo 赋值.</li></ul></li><li>expr 命令<ul><li>有时双括号有点眼花 (◎﹏◎).</li><li>可以使用 <code>exper xxx</code> 代替</li><li>支持变量替换,但不支持非整数参数.</li></ul></li></ul><h2 id="行操作"><a class="markdownIt-Anchor" href="#行操作"></a> 行操作</h2><ul><li>bash 内置了 Readline 库,行操作基于此,默认是 Emacs 快捷键,没必要不需要改.</li><li>光标移动 (alt 可由 esc 代替)<ul><li><code>Ctrl + a</code>：移到行首</li><li><code>Ctrl + b</code>：向行首移动一个字符,与左箭头作用相同</li><li><code>Ctrl + e</code>：移到行尾</li><li><code>Ctrl + f</code>：向行尾移动一个字符,与右箭头作用相同</li><li><code>Alt + f</code>：移动到当前单词的词尾</li><li><code>Alt + b</code>：移动到当前单词的词首</li></ul></li><li>清屏<ul><li><code>ctrl + l</code>: 等同于 clear</li></ul></li><li>编辑操作<ul><li>编辑行的内容</li><li><code>ctrl + d</code>: 删除光标位置的字符.<strong>千万小心,当前行没有字符,直接退出终端</strong></li><li><code>ctrl + w</code>: 删除光标前的单词</li><li><code>ctrl + t</code>: 光标位置字符与前一位交换</li><li><code>alt + t</code>: 光标位置词与前一位词交换</li><li><code>alt + l</code>: 光标位置到词尾转为小写</li><li><code>alt + u</code>: 光标位置到词尾转为大写</li></ul></li><li>自动补全<ul><li><code>Tab</code>: 不说了,连恩两次,列出所有可能补全.</li><li><code>alt + tab</code>: 从 bash_history 里提取补全,但是吧和多任务切换冲突了…</li><li>其他用的就少了</li></ul></li><li>操作历史<ul><li><p>所有历史命令都保存在 <code>~/.bash_history</code> 文件中.</p></li><li><p>上下键切换,不多说了.</p></li><li><p><code>history</code>: 显示 history 文件</p></li><li><p><code>history -c</code>: 清理 history</p></li><li><p><code>ctrl + r</code>: 会显示显示操作历史,键入命令可显示历史文件中查询的命令.<strong>常用</strong>.</p></li><li><p>快捷键</p><ul><li><code>ctrl + o</code>: 执行当前条目,并显示下一条命令</li></ul></li><li><p>!快捷键</p><ul><li><code>!string</code>: 相当于搜索历史,找出最近的以 string 开头的命令并执行.但<strong>只会匹配命令,没有参数什么事</strong></li><li><code>!?string</code>: 执行最近一条包含字符串 string 的命令</li><li><code>^string1^string2</code>: 执行最近一条包含 string1 的命令，将其替换成 string2</li><li><code>!n</code>: 执行 history 第 n 行的命令</li><li><code>!-n</code>: 执行 history 末尾开始 -n 行命令</li></ul></li></ul></li><li>其他快捷键<ul><li><code>Ctrl + v</code>: 下一个输入的特殊字符变成字面量…</li><li><code>Alt + .</code> 或 <code>Alt + _</code>: <strong>非常重要</strong>,插入上一条命令的最后一个词.对于很长文件路径非常适用.</li></ul></li></ul><h2 id="目录堆栈"><a class="markdownIt-Anchor" href="#目录堆栈"></a> 目录堆栈</h2><ul><li>大意是有个堆栈可以把目录当作变量一样操作.进栈出栈.</li><li><code>cd -</code>: 返回前一次进入的目录</li><li><code>pushd dir</code>: 进入 dir 同上 dir 放入堆栈.</li><li><code>popd</code>: 取栈顶目录,出栈并进入该目录.</li><li><code>popd -n</code>: 仅删除栈顶目录,不改变当前 shell 路径.</li><li><code>pushd +3</code>: 从栈顶起,第三个目录移动到栈顶.</li><li><code>pushd -3</code>: 从栈底起,第三个目录移动到栈顶.</li><li><code>popd +3</code>: 从栈顶起,删除第三个目录.</li><li><code>popd -3</code>: 从栈底起,删除第三个目录.</li><li>dirs 命令<ul><li>显示目录堆栈</li><li><code>-c</code>: 清空目录堆栈</li><li><code>-l</code>: 用户主目录不显示波浪号前缀,而打印完整的目录 (???)</li><li><code>-p</code>: 打印目录堆栈.</li><li><code>-v</code>: 打印目录堆栈带编号.</li><li><code>+N</code>: 显示自栈顶起,第 N 个目录.</li><li><code>-N</code>: 显示自栈底起,第 N 个目录.</li></ul></li></ul><h2 id="脚本入门"><a class="markdownIt-Anchor" href="#脚本入门"></a> 脚本入门</h2><ul><li><p>脚本就不多说了,学习 bash 就是为了写个脚本,各类自动化真是羡慕.</p></li><li><p>Shebang 行</p><ul><li>就是脚本第一行,实际作用是指示脚本解释器.一般是 sh 或 bash</li><li><code>#!/bin/sh</code> 或 <code>#!/bin/bash</code> : 有没有空格都行.</li><li><code>#!/usr/bin/env bash</code>: 阮老师推荐这样写,以防万一 bash 解释器没有在 /bin 下面.</li><li>这一行不是必须的,只要不通过 <code>./script.sh</code> 这样调用.</li></ul></li><li><p>权限和路径</p><ul><li><p><code>chmod +x script.sh</code>: 所有用户,执行权限</p></li><li><p><code>chmod +rx script.sh</code> 或 <code>chmod 755 script.sh</code>: 所有用户.读 执行权限</p></li><li><p><code>chmod u+rx script.sh</code> 或 <code>chmod 700 script.sh</code>: 仅所有者,读 执行权限.</p></li><li><p>路径,新建 ~/bin 存放脚本,加入 PATH ,这样可以直接输入脚本名执行脚本了.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/bin</span><br></pre></td></tr></table></figure></li></ul></li><li><p>env 命令</p><ul><li><code>#!/usr/bin/env bash</code>: shell 查找 bash 的路径并加载,如果 bash 的解释器没有在 /bin 下,可以兼容.</li><li>参数<ul><li><code>-i</code>: 不带环境变量启动</li><li><code>-u xx</code>: 从环境变量中删除一个变量.</li></ul></li></ul></li><li><p>注释</p><ul><li>所有注释都是以 <code>#</code> 开头,可以在结尾,也可以另起一行.</li><li>建议在脚本开头,说明当前脚本的作用.</li></ul></li><li><p>脚本参数</p><ul><li><p>调用脚本时后面跟随的参数.bash 对这种情况进行了处理.</p></li><li><p><code>$0</code>: 脚本名,脚本自身名称,不同的调用方式名称不同.</p></li><li><p><code>$1</code> ~ <code>$9</code>: 脚本第一个到第九个参数.</p></li><li><p><code>$#</code>: 参数的总数</p></li><li><p><code>$@</code>: 全部参数,参数之间空格隔开.</p></li><li><p><code>$*</code>: 全部参数,参数使用 <code>$IFS</code> 的第一个字符隔开,默认是空格.</p></li><li><p><code>$&#123;10&#125;</code> ~ <code>$&#123;xx&#125;</code>: 10 个以后的参数可以加大括号引用.</p></li><li><p><code>command -o foo bar</code>: 参数依次是 <code>-o</code> <code>foo</code> <code>bar</code></p></li><li><p>多个参数在同一个双引号中,算是一个参数.</p></li><li><p>也可以使用 for 循环 <code>$@</code> 每一个参数.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>shift 命令</p><ul><li><p>可以改变脚本的参数,每次都会移除当前的第一个参数 <code>$1</code>,移除后剩余参数依次填充,原来的 <code>$2</code> 变成 <code>$1</code>…</p></li><li><p>结合 while 实现另一类的循环</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;剩下 <span class="variable">$#</span> 个参数&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;参数：<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p><code>sheift number</code>: 一次性移除多个参数</p></li></ul></li><li><p>getopts 命令</p><ul><li><p>可以解析复杂的脚本命令行参数,通常与 while 连用,取出带 <code>-</code> 的参数.</p></li><li><p><code>getopts optstring name</code>: 第一个参数是字符串,就是 <code>-</code> 前面的字符.例如需要解析 <code>-l</code> <code>-a</code> 两个配置,且 <code>-a</code> 是带参数值的.optstring 要写成 <code>la:</code>,顺序不重要,带参数值的需要带 <code>:</code>.第二个参数是变量,<code>-</code> 后面的值就存在 <code>name</code> 对应的变量中.</p></li><li><p>这是原教程的一个示例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&#x27;lha:&#x27;</span> OPTION; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$OPTION</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    l)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;linuxconfig&quot;</span></span><br><span class="line">      ;;</span><br><span class="line"></span><br><span class="line">    h)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;h stands for h&quot;</span></span><br><span class="line">      ;;</span><br><span class="line"></span><br><span class="line">    a)</span><br><span class="line">      avalue=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;The value provided is <span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">      ;;</span><br><span class="line">    ?)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;script usage: <span class="subst">$(basename $0)</span> [-l] [-h] [-a somevalue]&quot;</span> &gt;&amp;2</span><br><span class="line">      <span class="built_in">exit</span> 1</span><br><span class="line">      ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">shift</span> <span class="string">&quot;<span class="subst">$(($OPTIND - 1)</span>)&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置项参数终止符 <code>--</code></p><ul><li>指定变量只作为实体参数,而不是作为配置项参数.</li></ul></li><li><p>exit 命令</p><ul><li>终止脚本执行,返回一个值.</li><li><code>exit bumber</code>: 返回 0 即执行成功.</li></ul></li><li><p>命令执行结果</p><ul><li>脚本大多是命令的连续执行,<code>$?</code> 代表了前一个命令的返回值,返回值为 0 则,上一个命令执行成功.</li><li>一般配合 if.</li><li>或者上文中的 <code>&amp;&amp;</code> <code>||</code>.</li></ul></li><li><p>source 命令</p><ul><li>source 可以用来执行脚本,但是 source 只会在当前 shell 下执行,不需要 export.</li><li><code>. .bashrc</code>: source 简写成 <code>.</code>.</li></ul></li><li><p>别名 <code>alias</code> 命令</p><ul><li><code>alias NAME=DEFINITION</code>: 别名,不表.</li><li><code>unalias lt</code>: 解除别名.</li></ul></li></ul><h2 id="read-命令"><a class="markdownIt-Anchor" href="#read-命令"></a> Read 命令</h2><ul><li><p>读取转化用户输入的命令.</p></li><li><p><code>read [-options] [variable…]</code>: options 是参数,variable 是一系列的变量名,储存用户的输入,如果没有变量名,默认使用 <code>REPLY</code> 环境变量保存.</p></li><li><p><code>read FN LN</code>: read 可以接受多个用户输入,空格分割开,输入不够 read 的数量,缺失自动为空,超过数量,都挤到最后一个变量上.</p></li><li><p>read 亦可以读取文件,done 后面的命令 <code>&lt;</code> 将文件导入变量 <code>myline</code>,一次读取一行.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> myline</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$myline</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="variable">$filename</span></span><br></pre></td></tr></table></figure></li><li><p><code>-t second</code>: 设置超时,超时后用户没有输入即放弃等待.</p></li><li><p><code>-p &quot;text&quot;</code>: 显示提示语句,提示用户输入.</p></li><li><p><code>-a xx</code>: 将用户的输入赋值给数组,从 0 开始.</p></li><li><p><code>-n number xxx</code>: 只取 xxx 的前 nubmber 个字符.</p></li><li><p><code>-e xx</code>: 允许参数使用 bash 的自动补全功能.</p></li><li><p><code>-r</code>: raw 模式,不将反斜杠解释为转义字符.</p></li><li><p><code>-s</code>: 不显示用户输入,常用在输密码什么的.</p></li><li><p>IFS 变量</p><ul><li>默认 read 读取的不同值以空格隔离.</li><li>可以修改 IFS 变量,修改默认的分隔符.</li><li>IFS 默认有空格 TAB 换行.</li><li>常用自定义分隔符有 <code>;</code> <code>:</code> 等.</li><li>IFS 为空,则将整行作为一个变量.</li></ul></li></ul><h2 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h2><p><code>if</code> 是最常用的了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> commands</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  commands</span><br><span class="line">[<span class="keyword">elif</span> commands; <span class="keyword">then</span></span><br><span class="line">  commands...]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">  commands]</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>特殊一点的是分支是 <code>elif</code> 结束时是 <code>fi</code> 结尾.</li><li><code>then</code> 与条件判断写在一行要以 <code>;</code> 分隔.其他也类似,如果愿意可以都写在一行,然后以 <code>;</code> 分隔.</li><li>两个特殊指令 <code>true</code> <code>false</code>.</li><li>判断部分可以跟随任意多个命令,但是判断只以最后一个为准.</li></ul><p>判断部分常用 <code>test</code>,有 3 种</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">test</span> expression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line">[ expression ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法三</span></span><br><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure><ul><li>三种形式等价.执行成功返回 0 ,失败返回 1.</li><li>形式 2 3,<code>[</code> 与 <code>]</code> 之间必须要有空格.</li><li>形式 3 还支持正则.</li></ul><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e /tmp/foo.txt ; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Found foo.txt&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="keyword">if</span> [ -e /tmp/foo.txt ] ; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Found foo.txt&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法三</span></span><br><span class="line"><span class="keyword">if</span> [[ -e /tmp/foo.txt ]] ; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Found foo.txt&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>判断表达式,<code>test</code> 是测试命令是否执行成功,测试表达式则更多的是判断状态.(这一块内容太多照抄了…)</p><p>文件判断</p><ul><li>示例 <code>if [ -e &quot;$FILE&quot; ]; then</code></li><li><code>[ -a file ]</code>：如果 file 存在，则为 <code>true</code>。</li><li><code>[ -b file ]</code>：如果 file 存在并且是一个块（设备）文件，则为 <code>true</code>。</li><li><code>[ -c file ]</code>：如果 file 存在并且是一个字符（设备）文件，则为 <code>true</code>。</li><li><code>[ -d file ]</code>：如果 file 存在并且是一个目录，则为 <code>true</code>。</li><li><code>[ -e file ]</code>：如果 file 存在，则为 <code>true</code>。</li><li><code>[ -f file ]</code>：如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li><li><code>[ -g file ]</code>：如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li><li><code>[ -G file ]</code>：如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li><li><code>[ -h file ]</code>：如果 file 存在并且是符号链接，则为 <code>true</code>。</li><li><code>[ -k file ]</code>：如果 file 存在并且设置了它的 “sticky bit”，则为 <code>true</code>。</li><li><code>[ -L file ]</code>：如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li><li><code>[ -N file ]</code>：如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li><li><code>[ -O file ]</code>：如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li><li><code>[ -p file ]</code>：如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li><li><code>[ -r file ]</code>：如果 file 存在并且可读（当前用户有可读权限），则为 <code>true</code>。</li><li><code>[ -s file ]</code>：如果 file 存在且其长度大于零，则为 <code>true</code>。</li><li><code>[ -S file ]</code>：如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li><li><code>[ -t fd ]</code>：如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。 这可以用来判断是否重定向了标准输入／输出错误。</li><li><code>[ -u file ]</code>：如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li><li><code>[ -w file ]</code>：如果 file 存在并且可写（当前用户拥有可写权限），则为 <code>true</code>。</li><li><code>[ -x file ]</code>：如果 file 存在并且可执行（有效用户有执行／搜索权限），则为 <code>true</code>。</li><li><code>[ file1 -nt file2 ]</code>：如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li><li><code>[ file1 -ot file2 ]</code>：如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li><li><code>[ FILE1 -ef FILE2 ]</code>：如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li></ul><p>字符串判断</p><ul><li>示例 <code>if [ -z &quot;$ANSWER&quot; ]; then</code></li><li>test 命令内部的&gt;和&lt;，必须用引号引起来（或者是用反斜杠转义）。否则，它们会被 shell 解释为重定向操作符</li><li><code>[ string ]</code>：如果 <code>string</code> 不为空（长度大于 0），则判断为真。</li><li><code>[ -n string ]</code>：如果字符串 <code>string</code> 的长度大于零，则判断为真。</li><li><code>[ -z string ]</code>：如果字符串 <code>string</code> 的长度为零，则判断为真。</li><li><code>[ string1 = string2 ]</code>：如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li><li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li><li><code>[ string1 != string2 ]</code>：如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li><li><code>[ string1 '&gt;' string2 ]</code>：如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li><li><code>[ string1 '&lt;' string2 ]</code>：如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li></ul><p>整数判断</p><ul><li>示例: <code>if [ -z &quot;$INT&quot; ]; then</code></li><li><code>[ integer1 -eq integer2 ]</code>：如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -ne integer2 ]</code>：如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -le integer2 ]</code>：如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -lt integer2 ]</code>：如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -ge integer2 ]</code>：如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -gt integer2 ]</code>：如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li></ul><p>正则判断 (最头疼的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ string1 =~ regex ]]</span><br><span class="line"> [[ <span class="string">&quot;<span class="variable">$INT</span>&quot;</span> =~ ^-?[0-9]+$ ]] <span class="comment"># 示例</span></span><br></pre></td></tr></table></figure><p>test 判断的逻辑运算</p><ul><li><code>AND</code>: <code>$$</code> 或 <code>-a</code></li><li><code>OR</code>: <code>||</code> 或 <code>-o</code></li><li><code>NOT</code>: <code>!</code></li><li>test 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</li></ul><p>算术判断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="number">3</span> &gt; <span class="number">2</span>)); <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>算术判断非 0 值为 true, 0 值为 false</strong>.</p><p>算术判断还可以用于赋值操作,两者都对 foo 进行了赋值,但是第一个返回 5 第二个返回 0,所以第一个判断为 true,第二个判断为 false.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (( foo = <span class="number">5</span> ));<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;foo is <span class="variable">$foo</span>&quot;</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> (( foo = <span class="number">0</span> ));<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;It is true.&quot;</span>;<span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">&quot;It is false.&quot;</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>普通命令的逻辑运算<br>实际上就是 if 与 <code>&amp;&amp;</code> <code>||</code> 的混用.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[[ -d <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span> ]] &amp;&amp; <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span> &amp;&amp; <span class="built_in">rm</span> * <span class="comment"># 等同于查看文件夹是否存在,存在则进入并执行 rm *</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;No such directory: &#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$dir_name</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Cannot cd to &#x27;<span class="variable">$dir_name</span>&#x27;&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">rm</span> *; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;File deletion failed. Check results&quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>case 结构…类似 kotlin 的 when,能避免 if 的地狱.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">  pattern )</span><br><span class="line">    commands ;;</span><br><span class="line">  pattern )</span><br><span class="line">    commands ;;</span><br><span class="line">  ...</span><br><span class="line">  * )</span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><ul><li>expression 是一个表达式，pattern 是表达式的值或者一个模式,可以有多条，用来匹配多个值，每条以两个分号 <code>;</code> 结尾.</li><li>最后是 <code>*</code> 如果都没匹配上.</li></ul><p>匹配模式,可以使用各种通配符</p><ul><li><code>a)</code>: 匹配 a</li><li><code>a|b)</code>: 匹配 a b</li><li><code>[[:alpha:]])</code>: 单个字母</li><li><code>???)</code>: 3 个字符的单词</li><li><code>*.txt)</code>: xxx.txt</li><li><code>*)</code>: 任意输入</li></ul><p>bash 4.0 增加了多项匹配,即允许匹配多个条件,要以 <code>;;&amp;</code> 结束.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$REPLY</span> <span class="keyword">in</span></span><br><span class="line">  [[:upper:]])    <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; is upper case.&quot;</span> ;;&amp;</span><br><span class="line">  [[:lower:]])    <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; is lower case.&quot;</span> ;;&amp;</span><br><span class="line">  [[:alpha:]])    <span class="built_in">echo</span> <span class="string">&quot;&#x27;<span class="variable">$REPLY</span>&#x27; is alphabetic.&quot;</span> ;;&amp;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>只要条件符合,会匹配 3 个条件,而不是匹配一个就结束.</p><h2 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h2><p>总共有 3 种循环 <code>for</code> <code>while</code> <code>until</code></p><p><code>while</code> 和其他编程语言一样,条件为 true 就一直执行.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> condition; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> commands; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>上面 3 种完全等效</li><li>while 条件部分,可以有任意条指令,判断只取决于最后一条.</li><li>条件同样可以使用 test 命令.</li></ul><p><code>until</code> 有点不一样,与 <code>while</code> 相反,false 才执行,true 中断循环.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> condition; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>3 种方式与 while 相同,不加赘述.</li><li>条件也与 while 完全相同.</li><li>until 有点没必要…</li></ul><p><code>for .. in</code> 常用于遍历.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>do 写在同一行 <code>;</code>.整个循环写在一行,不再赘述.</li><li>列表可以是通配符 <code>for i in *.png; do</code>.</li><li>列表可以通过子命令产生 <code>for i in $(cat ~/.bash_profile); do</code></li><li><code>in list</code> 部分可以省略,但是非必要时,为了可读性,不要省略.</li></ul><p><code>for</code> 循环…跟 c 一样…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( expression1; expression2; expression3 )); <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>定义等与 c 相同,不加赘述.</li><li>循环条件是<strong>双括号</strong>.</li><li>双括号内使用变量,不需要 <code>$</code>.</li></ul><p><code>break</code> <code>continue</code>…定义与 c 相同.</p><p>select 结构<br>结构与 <code>for..in</code> 基本相同,用来生成一个菜单,用户可以选择.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line">[<span class="keyword">in</span> list]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>select 会生成 list 的带编号菜单,用户选择编号,对应内容存放在 <code>name</code> 的变量中.</li><li>与 <code>case</code> 连用,当个完整的选择菜单了.</li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><p>bash 的函数定义上更多的是重复使用代码段的封装,而不是传统意义上的函数.</p><ul><li>函数执行不会新建 shell 这是与脚本的区别.</li><li>重名下优先级 别名 &gt; 函数 &gt; 脚本</li><li>注意函数并不依附于脚本,可以直接定义在 shell 中.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  <span class="comment"># codes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">  <span class="comment"># codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>两者等价</li><li>最大的不适应是变量,没有所谓变量一说.跟脚本处理变量一样<ul><li><code>$0</code> 是函数所在的脚本名.前 9 个是 <code>$1</code>~<code>$9</code>,10 个往上就是 <code>$&#123;10&#125;</code>.</li><li><code>$#</code> 参数总数.<code>$@</code> 所有参数,空格隔开.</li><li><code>$*</code> 所有参数,以 IFS 的第一个字符隔开.</li></ul></li></ul><p><code>return</code> 命令,这个 return 可是和普通函数的 return 是两码事.因为 bash 函数不带参数变量,所以 return 的返回要使用 <code>$?</code> 拿到.本质上和上一个命令的返回没区别.</p><p>全局变量也是个坑,如果仅仅在函数中定义 <code>foo=1</code>,这个 <code>foo</code> 是整个脚本的…想获得局部变量的效果要 <code>local foo ; foo = 1</code>,这一点有点坑…</p><h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><p>与一般编程语言的定义有很大不同.</p><ul><li>索引从 0 开始,没啥不一样.</li><li>但是数量没有上限</li><li>也没有连续索引的要求.</li></ul><h3 id="创建数组"><a class="markdownIt-Anchor" href="#创建数组"></a> 创建数组</h3><p>逐个赋值给</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARRAY[INDEX]=value</span><br></pre></td></tr></table></figure><p>一次性赋值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARRAY=(value1 value2 ... valueN)</span><br><span class="line"><span class="comment"># 只赋值某些位置也可以,不要求索引连续.其他位置默认为 空字符串</span></span><br><span class="line">names=(hatter [5]=duchess alice)</span><br></pre></td></tr></table></figure><p>通配符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp3s=( *.mp3 )</span><br></pre></td></tr></table></figure><p>用户输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -a dice</span><br></pre></td></tr></table></figure><h3 id="读取数组"><a class="markdownIt-Anchor" href="#读取数组"></a> 读取数组</h3><p>单个元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大括号不可少</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[i]&#125;</span></span><br></pre></td></tr></table></figure><p>遍历数组,<code>@</code> 或 <code>*</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问全部元素</span></span><br><span class="line"><span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line"><span class="variable">$&#123;foo[*]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没太理解为啥</span></span><br><span class="line">$ activities=( swimming <span class="string">&quot;water skiing&quot;</span> canoeing <span class="string">&quot;white-water rafting&quot;</span> surfing )</span><br><span class="line">$ <span class="keyword">for</span> act <span class="keyword">in</span> <span class="variable">$&#123;activities[@]&#125;</span>; \</span><br><span class="line"><span class="keyword">do</span> \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Activity: <span class="variable">$act</span>&quot;</span>; \</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">Activity: swimming</span><br><span class="line">Activity: water</span><br><span class="line">Activity: skiing</span><br><span class="line">Activity: canoeing</span><br><span class="line">Activity: white-water</span><br><span class="line">Activity: rafting</span><br><span class="line">Activity: surfing</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">for</span> act <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;activities[@]&#125;</span>&quot;</span>; \</span><br><span class="line"><span class="keyword">do</span> \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Activity: <span class="variable">$act</span>&quot;</span>; \</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">Activity: swimming</span><br><span class="line">Activity: water skiing</span><br><span class="line">Activity: canoeing</span><br><span class="line">Activity: white-water rafting</span><br><span class="line">Activity: surfing</span><br><span class="line"></span><br><span class="line"><span class="comment"># * 号带上双引号全部变成单个字符返回.</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;activities[*]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">swimming water skiing canoeing white-water rafting surfing</span><br></pre></td></tr></table></figure><p>默认位置是 0.</p><p>数组长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line"><span class="variable">$&#123;#array[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是不能拿来读取数组具体成员</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#a[100]&#125;</span> <span class="comment"># 数组索引 100 对应元素的长度</span></span><br></pre></td></tr></table></figure><p>数组序号: <code>&#123;!array[@]&#125;</code> 或 <code>&#123;!array[*]&#125;</code> 返回数组非空的索引.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;!arr[@]&#125;</span>;<span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;arr[i]&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>提取数组成员,类似切片.<code>&#123;array[@]:position:length&#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;food[@]:1:3&#125;</span></span><br><span class="line"><span class="comment"># 从 4 开始到最后</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;food[@]:4&#125;</span></span><br></pre></td></tr></table></figure><p>追加, <code>+=</code> 追加到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo+=(d e f)</span><br></pre></td></tr></table></figure><p>删除成员</p><ul><li><code>unset</code> 彻底抹除</li><li>单纯将值置为空,只会在输出值的遍历中 &quot; 隐身 &quot;,在索引中依然存在.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ foo[1]=<span class="string">&#x27;&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;foo[@]&#125;</span></span><br><span class="line">a c d e f</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;#foo[@]&#125;</span></span><br><span class="line">6</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!foo[@]&#125;</span></span><br><span class="line">0 1 2 3 4 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接干掉整个数组.</span></span><br><span class="line">$ <span class="built_in">unset</span> foo</span><br></pre></td></tr></table></figure><p>关联数组</p><p>允许使用字符串作为索引而不是数字,有点像字典.</p><ul><li><code>declare -A</code> 声明数组</li><li>其他几乎相同</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A colors</span><br><span class="line">colors[<span class="string">&quot;red&quot;</span>]=<span class="string">&quot;#ff0000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[&quot;red&quot;]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="set-命令"><a class="markdownIt-Anchor" href="#set-命令"></a> Set 命令</h3><p>set 命令是用来修改子 Shell 环境的运行参数的,在调试等极为重要.</p><p><code>set -u</code> 或 <code>set -o nounset</code>: 当遇到变量不存在时,报错终止运行.(默认是忽略错误)</p><p><code>set -x</code> / <code>set +x</code>: 脚本执行时每执行一个命令,先输出到控制台,再执行.<code>-x</code> 是开启 <code>+x</code> 关闭,一般对易出错代码段开启.</p><p>错误处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有错误,command 会返回非 0 值</span></span><br><span class="line"><span class="built_in">command</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令失败也会继续执行</span></span><br><span class="line"><span class="built_in">command</span> || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有错误,但是停止前需要一些操作.</span></span><br><span class="line"><span class="built_in">command</span> || &#123; <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -ne 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;command failed&quot;</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要第一个命令执行成功,才执行第二个.</span></span><br><span class="line">command1 &amp;&amp; command2</span><br></pre></td></tr></table></figure><p><code>set -e</code> / <code>set +e</code>: 有错误即终止运行,<code>-e</code> 开启,<code>+e</code> 关闭.</p><p><code>set -o pipefail</code>: <code>-e</code> 不适用于管道的命令,<code>-o pipefail</code> 适用.</p><p><strong>连用</strong>重要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法一</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"><span class="comment"># 写法二</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行时处理</span></span><br><span class="line">bash -euxo pipefail script.sh</span><br></pre></td></tr></table></figure><h3 id="shopt-命令"><a class="markdownIt-Anchor" href="#shopt-命令"></a> Shopt 命令</h3><p>与 set 命令类似,但是 set 来自 POSIX,shopt 是 bash 特有的.</p><p><code>shopt</code>: 可以查看所有参数及其状态.</p><ul><li><code>-s</code>: 打开参数</li><li><code>-u</code>: 关闭参数</li><li><code>-q</code>: 查询参数是否打开,但是结果不直接返回,而在 <code>$?</code> 中.</li></ul><h3 id="脚本除错"><a class="markdownIt-Anchor" href="#脚本除错"></a> 脚本除错</h3><p><code>-x</code>: 执行脚本前加上 <code>-x</code> 会输出所有执行的命令.</p><p>一些环境 bianl</p><ul><li><code>LINENO</code>: 返回所在的行号</li><li><code>FUNCNAME</code>: 返回数组,是当前函数的调用堆栈.</li><li><code>BASH_SOURCE</code>: 返回数组,是当前脚本的调用堆栈.</li><li><code>BASH_LINENO</code>: 返回数组,内容是每一轮调用对应的行号.</li><li><code>$&#123;BASH_LINENO[$i]&#125;</code> 跟 <code>$&#123;FUNCNAME[$i]&#125;</code> 是一一对应关系，表示 <code>$&#123;FUNCNAME[$i]&#125;</code> 在调用它的脚本文件 <code>$&#123;BASH_SOURCE[$i+1]&#125;</code> 里面的行号.</li></ul><h3 id="mktemp-命令"><a class="markdownIt-Anchor" href="#mktemp-命令"></a> Mktemp 命令</h3><p>一般临时文件创建在 /tmp 下,用完就删.但是这样存在几个问题.</p><ul><li><code>/tmp</code> 下对所有用户可读可写.</li><li>意外退出,没法清理.</li></ul><p>mktemp: 创建时不会检查临时文件,但是支持唯一文件名和删除机制.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定脚本退出时清理</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;rm -f &quot;$TMPFILE&quot;&#x27;</span> EXIT</span><br><span class="line"></span><br><span class="line">TMPFILE=$(<span class="built_in">mktemp</span>) || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Our temp file is <span class="variable">$TMPFILE</span>&quot;</span></span><br></pre></td></tr></table></figure><p>mktemp 会随机创建一个文件,并返回文件路径,这个文件只有当前用户拥有权限.</p><p>其他参数</p><ul><li><code>-d</code>: 创建临时文件夹</li><li><code>-p</code>: 指定临时文件创建位置,默认是 <code>$TMPDIR</code> 下,<code>$TMPDIR</code> 不存在则使用 <code>/tmp</code></li><li><code>-t</code>: 可指定临时文件名的模板.末尾必须是 <code>XXX</code> 表示随机字符.默认是 <code>tmp.XXXXXXXXXX</code></li></ul><h3 id="trap-命令"><a class="markdownIt-Anchor" href="#trap-命令"></a> Trap 命令</h3><p><code>trap</code> 可以用来响应系统信号,再执行命令.</p><p><code>trap -l</code>: 可以查看所有支持的系统信号.</p><p>常见格式是 <code>trap [动作] [信号1] [信号2]</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;rm -f &quot;$TMPFILE&quot;&#x27;</span> EXIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应执行多条命令</span></span><br><span class="line"><span class="keyword">function</span> egress &#123;</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  command3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> egress EXIT</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Jasper</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jasper1024.com/jasper/iomhgyb7831da/" title="bash 速描">https://jasper1024.com/jasper/iomhgyb7831da/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-nav"><div class="post-nav-item"><a href="/jasper/58954f872diohvf/" rel="prev" title="操作系统"><i class="fa fa-angle-left"></i> 操作系统</a></div><div class="post-nav-item"><a href="/jasper/46878yihda23sds/" rel="next" title="WIN 的折腾">WIN 的折腾 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-disqus">disqus</a></li><li class="tab"><a href="#comment-utterances">utterances</a></li></ul><div class="tab-content"><div class="tab-pane disqus" id="comment-disqus"><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><div class="tab-pane utterances" id="comment-utterances"><div class="comments utterances-container"></div></div></div></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">JasperHale</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">20:54</span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phc3Blci0xMDI0" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"jasper1024","count":true,"i18n":{"disqus":"disqus"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/disqus.min.js" defer></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Jasper-1024/blog_discuss","issue_term":"pathname","theme":"github-dark"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/utterances.min.js" defer></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>