<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="M2t8cZr5nIzHmltyt7Utj3nWYxNyNkCzFyigXBHkGUs"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"jasper1024.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"vs2015","dark":"vs2015"},"prism":{"light":"prism-vsc-dark-plus","dark":"prism-vsc-dark-plus"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"disqus","order":-1},"utteranc":{"text":"utteranc","order":-2}}},"stickytabs":true,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/config.min.js" defer></script><meta name="description" content="跟刷极客时间&lt;快速上手Kotlin开发&gt;的流水账   资料来源:  极客时间 https:&#x2F;&#x2F;johnnyshieh.me&#x2F;posts&#x2F;java-generics&#x2F; https:&#x2F;&#x2F;www.kotlincn.net&#x2F;docs&#x2F;reference&#x2F;generics.html https:&#x2F;&#x2F;kaixue.io&#x2F;    更新 123456720.01.20 初始化20.01.23 又是"><meta property="og:type" content="article"><meta property="og:title" content="kotlin 基础速描"><meta property="og:url" content="https://jasper1024.com/jasper/f93ae632/index.html"><meta property="og:site_name" content="默"><meta property="og:description" content="跟刷极客时间&lt;快速上手Kotlin开发&gt;的流水账   资料来源:  极客时间 https:&#x2F;&#x2F;johnnyshieh.me&#x2F;posts&#x2F;java-generics&#x2F; https:&#x2F;&#x2F;www.kotlincn.net&#x2F;docs&#x2F;reference&#x2F;generics.html https:&#x2F;&#x2F;kaixue.io&#x2F;    更新 123456720.01.20 初始化20.01.23 又是"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-01-20T20:10:11.000Z"><meta property="article:modified_time" content="2020-02-14T19:00:00.000Z"><meta property="article:author" content="Jasper"><meta property="article:tag" content="kotlin"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jasper1024.com/jasper/f93ae632/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jasper1024.com/jasper/f93ae632/","path":"jasper/f93ae632/","title":"kotlin 基础速描"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>kotlin 基础速描 | 默</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-207687331-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-207687331-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/analytics/google-analytics.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/comments.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/utils.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/motion.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/sidebar.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/next-boot.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/pjax.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/search/local-search.min.js" defer></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/pdf.min.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.10.1/dist/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/mermaid.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/fancybox.min.js" defer></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ItayEcWO7OsLFKF2Y8SsAYG1-MdYXbMMI","app_key":"18UBQFmJXXcOQFebLovT36lh","server_url":null,"security":false}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/statistics/lean-analytics.min.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/quicklink@3.0.1/dist/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://jasper1024.com/jasper/f93ae632/"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/quicklink.min.js" defer></script><link rel="stylesheet" href="source/_data/callout_blocks.css"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="默" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">默</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">生存是唯一的长路</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">45</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">330</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">65</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-comments fa-fw"></i>留言</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%AF%AD"><span class="nav-number">1.</span> <span class="nav-text">导语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">第一章 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">第二章 类与对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">第三章 高级特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-kotlin-%E8%AF%AD%E6%B3%95%E8%83%8C%E5%90%8E"><span class="nav-number">5.</span> <span class="nav-text">第四章 kotlin 语法背后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-kotlin-%E6%89%A9%E5%B1%95%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">第五章 kotlin 扩展库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">6.1.</span> <span class="nav-text">协程</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Jasper" src="/images/avatar.jfif"><p class="site-author-name" itemprop="name">Jasper</p><div class="site-description" itemprop="description">微尘</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">330</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phc3Blci0xMDI0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jasper-1024"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><a href="/ljy087621@gmail.com" title="E-Mail → ljy087621@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly94LmNvbS9KYXNwZXJfMTAyNA==" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;Jasper_1024"><i class="fab fa-twitter fa-fw"></i>Twitter</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL2phc3BlcjEwMjQ=" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;jasper1024"><i class="fab fa-skype fa-fw"></i>Telegram</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fas fa-rss fa-fw"></i>RSS</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tLw==" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;">forecho</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tL2ZyaWVuZHNoaXAtbGlua3Mv" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;friendship-links&#x2F;">友链聚合</span></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jasper1024.com/jasper/f93ae632/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jfif"><meta itemprop="name" content="Jasper"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="默"><meta itemprop="description" content="微尘"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="kotlin 基础速描 | 默"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">kotlin 基础速描</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-20 20:10:11" itemprop="dateCreated datePublished" datetime="2020-01-20T20:10:11Z">2020-01-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-14 19:00:00" itemprop="dateModified" datetime="2020-02-14T19:00:00Z">2020-02-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/kotlin/" itemprop="url" rel="index"><span itemprop="name">kotlin</span></a> </span></span><span id="/jasper/f93ae632/" class="post-meta-item leancloud_visitors" data-flag-title="kotlin 基础速描" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/jasper/f93ae632/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="jasper/f93ae632/" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>25k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>23 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li><p>跟刷极客时间&lt;快速上手Kotlin开发&gt;的流水账</p></li><li><p>资料来源:</p><blockquote><p>极客时间<br><span class="exturl" data-url="aHR0cHM6Ly9qb2hubnlzaGllaC5tZS9wb3N0cy9qYXZhLWdlbmVyaWNzLw==">https://johnnyshieh.me/posts/java-generics/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua290bGluY24ubmV0L2RvY3MvcmVmZXJlbmNlL2dlbmVyaWNzLmh0bWw=">https://www.kotlincn.net/docs/reference/generics.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9rYWl4dWUuaW8v">https://kaixue.io/<i class="fa fa-external-link-alt"></i></span></p></blockquote></li><li><p>更新</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20.01</span>.<span class="number">20</span> 初始化</span><br><span class="line"><span class="number">20.01</span>.<span class="number">23</span> 又是个大坑😥</span><br><span class="line"><span class="number">20.01</span>.<span class="number">29</span> 集合操作符.</span><br><span class="line"><span class="number">20.01</span>.<span class="number">30</span> 作用域函数/运算符重载/中缀表达式</span><br><span class="line"><span class="number">20.02</span>.<span class="number">08</span> 泛型...把 java 泛型翻了一遍..</span><br><span class="line"><span class="number">20.02</span>.<span class="number">12</span> 协程,还暂时只是使用.🤕.</span><br><span class="line"><span class="number">20.02</span>.<span class="number">14</span> 重新补充基础内容</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h2 id="导语"><a class="markdownIt-Anchor" href="#导语"></a> 导语</h2><ul><li>总归要转到 kotlin ,趁这段封锁的时间熟悉一下.</li><li>配合 <span class="exturl" data-url="aHR0cHM6Ly9rb3RsaW5sYW5nLm9yZy9kb2NzL3JlZmVyZW5jZS8=">kotlin doc<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cDovL3huLS1xcnF2NjhjdzZqNXk4YS5wcw==">食用更佳.ps<i class="fa fa-external-link-alt"></i></span>: 官网的代码可以直接编辑执行.</li><li>(20.01.29)药效貌似不错啊.</li><li>(20.02.10)自始至终 kt 给我感觉更类似 python 而不是其他的 jvm 语言.</li><li>(20.02.12)协程快吐了,1.3以前的api变动很多,理解上也有难度.</li><li>(20.02.13)剩下的 io 库暂时用不到, KTX 是 Jetpack 的部分.暂时补充一下基础内容.整理等靠后吧.码上开学的入门不错,就是更新好慢啊,最后是19.10月份了.</li></ul><h2 id="第一章-基础"><a class="markdownIt-Anchor" href="#第一章-基础"></a> 第一章 基础</h2><ul><li><p>变/常量</p><ul><li>var 表示变量,val 表示常量.</li><li>kt 的变量没有默认值,需要显式声明.<ul><li>kotlin 编译器可以识别变量类型时,可省略变量类型.<code>var = &quot;das&quot;</code></li><li>当部分变量没法在声明时初始化时,需要 lateinit 修饰,告诉编译器不再对此变量检查初始化.</li></ul></li><li>kotlin 为空类型安全.例如 String 即不为空,而 String? 可以为空.两者是不同的变量类型.<ul><li>String 可以直接赋值给 String? ,反之不能,可以使用强制 name = name2!!.</li><li>当调用一个可空变量的方法时需要使用 <code>?.</code> 而不是 <code>.</code>,这样 kt 会对变量判断非空再调用.例 <code>test?.one()</code></li><li>但有时必须返回一个值,需要 <code>?:</code> 兜底.<code>val l = str?.length ?: -1</code> str 为空,返回 -1.</li><li>或者使用非空断言,<code>test!!.one()</code>,告诉编译器不再检查非空.</li></ul></li><li>默认是 pubulic .</li></ul></li><li><p>类型: 数字、字符、布尔值、数组与字符串</p><ul><li>数字:<ul><li>整数: Byte Short Int Long ,默认是 Int 类型.显式指定 Long:<code>500L</code></li><li>浮点数: Float 和 Double.kt 中两者没有隐式的类型转换.默认为 Double 类型.Float 需要显式指定 <code>500.12f</code></li><li>进制: 二进制 <code>0b010</code>,十进制 <code>102</code>,十六进制 <code>0x0F</code> .没有八进制.</li><li>特点:<ul><li>数字这里有个特性是可以加下划线更易读. <code>199999.9899</code> = <code>199_999.989_9</code>,无论整数小数,无论进制.</li><li>表示范围较小类型并不是较大类型的子类型,需要强制类型转换.</li></ul></li></ul></li><li>字符:<ul><li>字符不能直接当作数字.(写惯了 c 有点不适应).如确实需要调用 toInt 方法.</li><li>特殊字符可以用反斜杠转义.</li></ul></li><li>字符串<ul><li>String 类型,不可变类型.</li><li>两种表示: <code>&quot;xx&quot;</code> 转义字符串可以有转义字符, <code>&quot;&quot;&quot;xx&quot;&quot;&quot;</code> 原始字符串,中间一起都是字符串,不包括转译,可以有空格换行等等.</li><li>可以使用索引运算符访问: s[i],可以用 for 循环迭代.</li><li>可以使用 + 操作符连接字符串.只要第一个元素是字符串也可连接其他类型,调用其他类型的 toString 方法.</li><li>原始字符串.trimMargin() 可以去掉每一行的空格.</li></ul></li><li>布尔类型与 java 相同.</li><li>数组: 与 java 差别有点大.<ul><li>Kotlin 数组使用 <code>Array&lt;T&gt;</code> 类来表示.</li><li>声明数组<ul><li><code>arrayOf(1, 2, 3)</code> 或者 <code>arrayOfNulls(5)</code>全空.</li><li>Array 的构造函数. <code>val asc = Array(5) &#123; i -&gt; (i * i).toString() &#125;</code></li></ul></li><li>支持索引, forEach,in,in.</li><li>最重要的一点,kt 的数组是不可变类型,这意味着 kt 的数组不支持协变.即 <code>Array&lt;String&gt;</code> 并不是 <code>Array&lt;Any&gt;</code> 的子类.无法把 <code>Array&lt;String&gt;</code> 直接赋值给 <code>Array&lt;Any&gt;</code>.(但是可以通过类型投影做到,见泛型.<code>Array&lt;out Any&gt;</code>)</li><li>除了基本的 <code>Array&lt;T&gt;</code> 类,kt 还提供了无需装箱的 ByteArray,ShortArray,IntArray.但这些类与 Array 并没有继承关系.</li></ul></li></ul></li><li><p>集合</p><ul><li><p>kt 中集合依旧是: List Set Map 3 种.</p></li><li><p>List</p><ul><li>创建一个 List 比 java 简单 ,<code>val strs: List&lt;String&gt; = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code>.</li><li><strong>支持协变</strong>,这倒是与数组相反.即可以把 <code>List&lt;String&gt;</code> 类型赋值给 <code>List&lt;Any&gt;</code>.</li><li>其他与数组基本相同.</li><li>到底用数组还是 List 视情况而定.性能需求苛刻,元素类型是基本类型时用数组.</li></ul></li><li><p>Set</p><ul><li>创建 Set <code>val strSet = setOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code>.</li><li><strong>支持协变</strong></li></ul></li><li><p>Map</p><ul><li>创建 Map <code>val map = mapOf(&quot;key1&quot; to 1, &quot;key2&quot; to 2, &quot;key3&quot; to 3, &quot;key4&quot; to 3)</code>.</li><li>get 或者方括号键值读取.<code>val value1 = map.get(&quot;key1&quot;) val value2 = map[&quot;key2&quot;]</code>.</li><li>put 或者方括号键值修改(要求是可变集合).<code>map.put(&quot;key1&quot;, 2) map[&quot;key1&quot;] = 2</code>.</li></ul></li><li><p>可变/不可变集合</p><ul><li>上面对 Map 的修改,Map 必须要由 mutableMapOf() 创建,须要是可变集合.</li><li>mutable 前缀的函数创建的是可变的集合,没有 mutbale 前缀的创建的是不可变的集合.不可变集合可以通过 toMutable*() 系函数转换成可变的集合.</li><li>listOf() , mutableListOf(); setOf() , mutableSetOf(); mapOf() , mutableMapOf();</li></ul></li><li><p>集合类还有一个 Sequence 类似 Iterable ,但是是惰性的,只有调用取值时才运算.</p></li></ul></li><li><p>条件控制,比 java 更简化.</p><ul><li>if 基本用法没变,可以作为表达式赋值给变量 <code>val max = if (a &gt; b) a else b</code>.</li><li><strong>没有三元运算符</strong></li><li>switch:default 替换成了 when:else,配合 lambda 很简洁.<ul><li><p>还支持多个条件或.</p></li><li><p>in 判断集合,is 判断类型,甚至省略 when 后面的参数,每一个都是布尔表达式.</p></li><li><p>例子</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  <span class="number">1</span> -&gt; &#123; println(<span class="string">&quot;1&quot;</span>) &#125;</span><br><span class="line">  <span class="number">2</span> -&gt; &#123; println(<span class="string">&quot;2&quot;</span>) &#125;</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span> -&gt; print(<span class="string">&quot;x == 1 or x == 2&quot;</span>)</span><br><span class="line">  <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; print(<span class="string">&quot;x 在区间 1..10 中&quot;</span>)</span><br><span class="line">  <span class="keyword">is</span> String -&gt; print(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; &#123; println(<span class="string">&quot;else&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">  str1.contains(<span class="string">&quot;a&quot;</span>) -&gt; print(<span class="string">&quot;字符串 str1 包含 a&quot;</span>)</span><br><span class="line">  str2.length == <span class="number">3</span> -&gt; print(<span class="string">&quot;字符串 str2 的长度为 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>kotlin 函数</p><ul><li><p>参数(几乎与 python 相同)</p><ul><li>变量:标识类型.: fun test(str:String):String {} 表面入参 str 返回一个 String 类型</li><li>参数可以有默认值.</li><li><strong>每一个都是命名参数</strong>,例如在其他参数都有默认值时,可以通过参数命单独传入这一个参数的值.</li><li>参数很多时可以通过参数的位置传入值(位置参数).</li><li>当然传入值时,位置参数要在命名参数的前面.</li></ul></li><li><p>没有返回值 java 返回 void 而 kt 返回 Unit</p></li><li><p>默认是 public ,但 override 修饰除外.</p></li><li><p>函数体只有1行时,可以直接赋值.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test_1</span><span class="params">(str: <span class="type">String</span> =<span class="string">&quot;test1&quot;</span>)</span></span> = println(<span class="string">&quot;fun <span class="variable">$str</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>顶级函数: 与 java 的一切皆对象不同,kt 的函数可以直接写在文件而不依附于对象.</p><ul><li>这样声明的函数是全局的.</li><li>顶级函数属于包.两个不同文件的同名顶级函数,调用时 IDE 会自动加上包前缀.</li></ul></li><li><p>函数嵌套: kotlin函数可以进行嵌套(与python相同).效果与 java 匿名内部类相似. 但只推荐需要递归,或隐藏内部函数时使用.</p></li><li><p>拓展函数: 静态的向类和对象中添加函数/变量等.第三方SDK或无法控制类的对象时使用.<br>拓展函数编译后静态方法,其中一个参数是 被拓展的类的对象.当其之类调用时,子类会被强转为父类.</p><ul><li><p>例</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  类名.拓展方法名*/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">readText</span><span class="params">(charset: <span class="type">Charset</span> = Charsets.UTF_8)</span></span>: String = readBytes().toString(charset)</span><br></pre></td></tr></table></figure></li><li><p>java调用,因为是拓展的File类,编译后拓展的函数实际上编译到了 FilesKt 类,调用时需要传入 kt 类的对象,和默认的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.gitignore&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> FilesKt.readText(file, Charsets.UTF_8);</span><br><span class="line">System.out.print(text);</span><br></pre></td></tr></table></figure></li><li><p>拓展函数最后被编译成一个 public static 的方法静态的添加方法,不具备运行时的多态.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:<span class="type">Animal</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Animal.<span class="title">name</span><span class="params">()</span></span> = <span class="string">&quot;animal&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> dog.<span class="title">name</span><span class="params">()</span></span> = <span class="string">&quot;dog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Animal.<span class="title">pr</span><span class="params">(animal: <span class="type">Animal</span>)</span></span> = println(animal.name())</span><br><span class="line"><span class="comment">//调用最后结果是 animal</span></span><br><span class="line">dog().pr(dog())</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Lambda 表达式(比java8的有限支持好用太多了).默认被编译为一个匿名内部类.</p><ul><li>lambda 表达式总是括在大括号中,完整语法形式的参数声明放在花括号内,并有可选的类型标注,函数体跟在一个 -&gt; 符号之后.</li><li><code>val sum = &#123; x: Int, y: Int -&gt; x + y &#125;</code></li><li>lambda 表达式没有参数,可以省略 -&gt;</li><li>lambda 是函数最后一个参数,可以将大括号放在小括号后面.</li><li>lambda 是函数唯一的参数,可以省略小括号</li><li>lambda 参数数量上限是22个,因为只有 kotlin 标准库才可以使用 kotlin 的包名,超过22个需要只能自行添加 java 类实现.</li></ul></li><li><p>高阶函数: 参数是一个函数的函数.</p><ul><li><p>kt 的函数没有返回值时会有一个默认的返回值 Unit ,当函数作为参数时要显式的声明 Unit.</p></li><li><p>引用在类中的方法: 类名::方法名.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">onlyif</span><span class="params">(isdebug:<span class="type">Boolean</span>,block:()-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isdebug) block()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> runnable = Runnable &#123; println(<span class="string">&quot;runnable::run&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> function: () -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">function = runnable::run</span><br><span class="line"></span><br><span class="line">onlyif(<span class="literal">true</span>,function)</span><br></pre></td></tr></table></figure></li><li><p>lambda 表达式在编译时是匿名内部类,大量使用会造成创建大量临时对象.使用 inline 关键字可以在编译时就将匿名内部类拆解成语句调用.但过度使用 inline 会加大编译器的负担,同时使得代码块过长.因此一般仅在高阶函数配合 lambda 时使用.</p></li></ul></li></ul></li><li><p>kotlin与java</p><ul><li><p>kotlin 可以直接在文件中定义一个方法.编译后生成一个默认以文件名为类名的类.kt文件的方法为该类的一个内部静态方法,java 调用时通过 文件名.方法名 调用.</p></li><li><p>以 object 创建一个匿名内部类. kotlin中可以直接 类名.方法 调用. 对应java中: 类名.INSTANCE.方法. 这也是 kotlin 中声明单例的一种方法.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(msg:<span class="type">String</span> = <span class="string">&quot;default&quot;</span>)</span></span>&#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Test.hello(<span class="string">&quot;kotlin&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test_java</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">      Test.INSTANCE.hello(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Class在kotlin与java中格式并不相同.kotlin加载java的class需要声明<code>class.java</code> 而 kotlin本身的类并不是 Class 而是 KClass .</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">testJavaClass(JaveMain::<span class="keyword">class</span>.java)</span><br><span class="line">testJavaClass(KotlinMain::<span class="keyword">class</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testJavaClass</span><span class="params">(clazz: <span class="type">Class</span>&lt;<span class="type">JaveMain</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(clazz.simpleName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*kotlin 的 class 为 KClass*/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testJavaClass</span><span class="params">(clazz: <span class="type">KClass</span>&lt;<span class="type">KotlinMain</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(clazz.simpleName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>kotlin与java关键字上有部分冲突.此时需要加反引号转译. java 中 in 是变量 kotlin 中调用 <code>println(JaveMain.</code>in<code>)</code></p></li><li><p>kotlin中没有封装类,只有基本数据类型.所有 java 的封装类在 kotlin 中都会转换成基本数据类型.</p></li><li><p>kotlin 空指敏感,与java 互调时,不确定java的返回值是否为空时,需要使用kotlin可接收空值的数据类型.(String?)</p></li><li><p>kotlin 没有静态变量,静态方法.kotlin中可以通过 @JvmStatic 注解修饰方法,这样 java 中调用时不再需要 INSTANCE 关键字.</p></li></ul></li></ul><h2 id="第二章-类与对象"><a class="markdownIt-Anchor" href="#第二章-类与对象"></a> 第二章 类与对象</h2><ul><li><p>基本</p><ul><li>kt 中默认的类是 public final ,需要显示声明 open .</li><li>继承的父类和实现的接口都在 : 后面,但是没有先后顺序.</li></ul></li><li><p>构造函数</p><ul><li><p>主构造函数的参数可以跟在类名后面的括号中,函数体在类内部 <code>init</code> 代码块.</p></li><li><p>在主构造函数声明的变量在类中会生成一份拷贝,直接访问.</p></li><li><p>kt 支持次级构造函数,需要通过 <code>constructor</code> 声明,且每一个次级构造函数都需要基层一个主构造函数.可以是这个类本身 (this) 或者父类 (super) 的构造函数</p></li><li><p>例:</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">inter</span> &#123;&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">baseclass</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testclass</span>(str: String = <span class="string">&quot;test&quot;</span>) : inter, baseclass() &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(int: <span class="built_in">Int</span> = <span class="number">0</span>) : <span class="keyword">this</span>(<span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">        println(int)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>访问修饰符</p><ul><li>private: 私有,成员仅该类可以访问</li><li>protected: 保护,成员该类和其之类可以访问</li><li>public: 公开,成员随便访问.</li><li>internal: kt 特有,一个模块内可以访问到.(类似c头文件的static?)</li></ul></li><li><p>强制类型转换</p><ul><li><p>java 中可以通过 instanceof 判断,然后 <code>(tmp)test.function()</code></p></li><li><p>kt 中 is 关键词判断后可以直接调用无需强制类型转换的声明.同时可以不使用 is 判断,直接使用 as 强转.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (activity <span class="keyword">is</span> NewActivity) &#123;</span><br><span class="line">  <span class="comment">//无需强转</span></span><br><span class="line">  activity.action()</span><br><span class="line">&#125;</span><br><span class="line">(activity <span class="keyword">as</span> NewActivity).action() <span class="comment">//强转,可能报错.</span></span><br><span class="line">(activity <span class="keyword">as</span>? NewActivity)?.action()<span class="comment">//强转成功再调用,更安全.</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>kotlin 中的 object .</p><ul><li>Object 在 java 中是所有类的基类,但在 kt 中 object(小写) 是个关键字,两者毫无关系.</li><li>object 的意思就是声明类同时创建一个类的对象.替换 class.</li><li>上文提到了 object 在声明单例对象时非常常用.</li></ul></li><li><p>伴生对象</p><ul><li><p>通过 <code>companion object&#123;&#125;</code> 可以声明一个类的伴生对象.然后通过 类名.方法名 直接调用方法.类似 java 类的静态方法.</p></li><li><p>实际上在编译后伴生对象被编译成一个名为 Companion 的静态对象,静态对象中包含了方法.所有在 java 中调用 kt 伴生对象的方式就是: 类名.Companion.方法名</p></li><li><p>例</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的内部</span></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span> == str</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kt调用</span></span><br><span class="line">testclass.isEmpty(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment">//java调用</span></span><br><span class="line">testclass.Companion.isEmpty(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>单例模式,可以使用上文提到的 @JvmStatic 注解.或是使用推荐的伴生对象实现方式.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span> <span class="keyword">private</span> <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>:single&#123;</span><br><span class="line">            <span class="keyword">return</span> Hodler.instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span> Hodler&#123;</span><br><span class="line">        <span class="keyword">var</span> instance = single()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>动态代理</p><ul><li><p>动态代理含义: <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMTI5MTE3OQ==">Java三种代理模式：静态代理、动态代理和cglib代理<i class="fa fa-external-link-alt"></i></span></p></li><li><p>kt 动态代理自然比 java 语法要简单很多. 关键词 <code>by</code> .不再需要 InvocationHandler 和 Proxy .</p></li><li><p>值得注意的是 kt 的动态代理在编译时已经编译为了静态资源,而不是像 java 通过反射进行.kt 的动态代理要比 java 快.(至于 java 的反射,有一篇已经吃灰的草稿,后面整理整理)</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bark</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:<span class="type">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bark</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">zoo</span>(animal: Animal):Animal <span class="keyword">by</span> animal&#123;</span><br><span class="line"><span class="comment">//    override fun bark() &#123;</span></span><br><span class="line"><span class="comment">//        println(&quot;zoo&quot;)</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zoo(dog()).bark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据类</p><ul><li>java 中涉及用户的类通常是是 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3L0phdmFCZWFucw==">JavaBeans<i class="fa fa-external-link-alt"></i></span>,只有属性没有方法,总是避免不了大量的 setter/getter 有时还有 toString hashCode 等等.</li><li>kt 中在在 class 前添加 <code>data</code> 关键字,属性会自动生成<ul><li>componentN() 函数( kt 的解构,见下一章)</li><li>setter/getter</li><li>equals/hashCode</li><li>toString</li><li>copy (特例不能显式实现)</li></ul></li><li>如果数据类的父类中有 equals hashCode toString 显式的实现,则在数据类中编译器会直接采用父类的方法而不会重写.</li><li>主构造函数的参数必须是 val 或者 var.</li><li>数据类是 final 类型,无法被 open 修饰,因此其他类无法继承数据类.</li></ul></li><li><p>密闭类</p><ul><li><p>kt 中也有枚举类,用法与 java 完全一致,不再赘述.kt 的密闭类可以看作是枚举类的升级版</p></li><li><p>关键词 <code>sealed</code> 可以有子类,但是子类必须写在密闭类内部,或者同一个文件中.子类可以继承密闭类.</p></li><li><p>用处最多的是配合 when 使用.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">PlayerViewType</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> GERRN : PlayerViewType()</span><br><span class="line">    <span class="keyword">object</span> BLUE : PlayerViewType()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">VIP</span>(<span class="keyword">var</span> view: String, <span class="keyword">var</span> button: String) : PlayerViewType()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getPleyerView</span><span class="params">(type: <span class="type">PlayerViewType</span>)</span></span> = <span class="keyword">when</span> (type) &#123;</span><br><span class="line">    PlayerViewType.BLUE -&gt; Blue()</span><br><span class="line">    PlayerViewType.GERRN -&gt; Green()</span><br><span class="line">    <span class="keyword">is</span> PlayerViewType.VIP -&gt; Vip(type.view, type.button)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第三章-高级特性"><a class="markdownIt-Anchor" href="#第三章-高级特性"></a> 第三章 高级特性</h2><ul><li><p>解构</p><ul><li><p>是指 kt 中可以把一个对象解构成多个变量,一次性赋值.</p></li><li><p>简单示例</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>(<span class="keyword">var</span> name:String,<span class="keyword">var</span> id:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = name</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a = person(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> (_, id) = a</span><br><span class="line">  println(<span class="string">&quot;<span class="variable">$id</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解构可以一次性创造多个变量,可解构的类中要声明 <code>componentN()</code> 函数,且要用 operator 关键字标记.这个例子中 name 对应的就是 component1 ,id 对应的是 component2 .当然还可以有 34… .</p></li><li><p>data class 中已经自动生成了 componentN().所以上面的例子中 person 的声明可以简化成 <code>data class person(var name:String,var id:Int)</code> .</p></li><li><p>对于不想使用的变量可以使用下划线代替,不需要为其命名.下划线对应的 componentN 不会调用.</p></li><li><p>data class 配合解构可以优雅的实现从函数返回多个值.</p></li><li><p>解构另一个重要的引用就是 map 的遍历(让我想起了 python 中方便的遍历)</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map: Map&lt;String, <span class="built_in">Int</span>&gt; = mapOf&lt;String, <span class="built_in">Int</span>&gt;(<span class="string">&quot;a&quot;</span> to <span class="number">1</span>, <span class="string">&quot;b&quot;</span> to <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((k,v) <span class="keyword">in</span> map)&#123;</span><br><span class="line">    println(<span class="string">&quot;k:<span class="variable">$k</span>,v:<span class="variable">$v</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环</p><ul><li><p>与 java 不同 kt 没有我们熟悉的 <code>for(i=0;i&lt;10;i++)</code> 这样的循环语句.</p></li><li><p>kt 更加类似 python ,抽象的层次更高.要实现我们熟悉的循环,下面是几个典型的例子.</p></li><li><p><code>for (i in 1..10 step 1)</code> 与 <code>for (i in 1 until 10)</code></p><ul><li><code>..</code> 是 <code>until</code> 的重载. 两者完全等同,两者最后都是 IntRange 函数的调用.</li><li><code>1..10</code> 表示 1到10 的闭区间,包括10.</li><li><code>step</code> 步长选择,步长只能为正数.</li></ul></li><li><p><code>for (i in 10 downTo 1 step 2)</code></p><ul><li>表示从 10 到 1 闭区间.</li><li>步长必须为正值.</li></ul></li><li><p><code>repeat(10)&#123;repeat(10)&#123; print(&quot;$it&quot;) &#125;</code></p><ul><li><code>repeat()</code> 是高阶函数.</li><li>实际上在传入的闭包重复执行 10 次</li><li>执行的序号可以通过 it 访问.</li></ul></li><li><p>for 循环还有一个用途是对象的遍历.</p><ul><li><code>for(i in list)</code> 最简单的写法.</li><li>如果要带上索引,需要解构的写法使用 <code>list.withIndex</code> <code>for ((index,i) in list.withIndex())</code></li></ul></li></ul></li><li><p>集合操作符</p><ul><li><p>对集合进行链式操作.有用过 rxjava 的大概能理解链式操作的便利.kt 中集合操作符配合 lambda 表达式,比 rxjava 更简洁.</p></li><li><p>集合操作符有几个分类,这里也没有列举全,具体参考 <span class="exturl" data-url="aHR0cHM6Ly93d3cua290bGluY24ubmV0L2RvY3MvcmVmZXJlbmNlL2NvbGxlY3Rpb24tb3BlcmF0aW9ucy5odG1s">集合操作概述<i class="fa fa-external-link-alt"></i></span></p></li><li><p>集合转换,从现有集合中创建新的集合</p><ul><li>map{}: lambda 将作用于原集合的每一个元素.常用于原集合的类型转换.</li><li>mapIndexed{ idx, value -&gt; xx }: 如果 lambda 中同时需要索引.</li><li>mapNotNull{} / mapIndexedNotNull{} : 如果需要过滤掉空元素.</li><li>zip{a, b -&gt; xxx}: 双路合并.</li><li>unzip(): 拆解双路,可与解构连用.</li><li>flatten(): 拆解集合中的嵌套返回单一的集合.</li><li>flatMap(): 拆解并返回一个list?</li><li>joinToString(): 拼接集合内的字符,返回一个字符串.可以在 lambda 中通过 it 关键词对集合元素处理.<ul><li>自定义参数 (separator = &quot; | &quot;, prefix = &quot;start: &quot;, postfix = “: end”,limit = 10, truncated = “&lt;…&gt;”)<ul><li>separator 是每个集合元素的间隔,prefix 字符串开头,postfix 字符串结尾.</li><li>limit 限制输出的字符串长度,truncated 截断后附加的字符串</li></ul></li></ul></li><li>joinTo(str): 凭借集合字符到 str,自定义参数同上.</li></ul></li><li><p>集合过滤,按照 lambda 中表达式的 true/false 决定集合元素的取舍.</p><ul><li>filter{}: lambda 中为 true 元素留, false 舍.不改变原集合的类型.</li><li>filterIndexed{index,s -&gt; xx}: 如果需要用到索引.</li><li>filterNot{}: 与 filter 完全相反.</li><li>filterIsInstance(): 没太看懂.</li><li>filterNotNull(): 返回所有非空.</li><li>partition{}: 划分(翻译成分组更好一点吧).将原有集合分成 lambade 返回 true 和 false 的两部分.可以通过解构取得这两个子集合.</li><li>any{}: 如果有元素的 lambda 为 true,则返回 true.</li><li>none{}: 如果所有元素的 lambda 都为 false,返回 true.如果 lambda 为空,则原集合有元素返回 false,没有元素返回 true.</li><li>all{}: 如果所有元素的 lambda 都为 true,则返回 true.<strong>注意</strong> 如果原集合为空 all 始终返回 true.如果 lambda 为空,则原集合有元素返回 true,没有元素返回 false.</li></ul></li><li><p><code>+</code> / <code>-</code> 操作符.这两个比较特殊.直接对应的集合的 + / -,不再赘述.</p></li><li><p>分组操作符: 可以按照 lambda 的返回对原集合 <strong>元素</strong> 进行分组.(相当于嵌套?)</p><ul><li>groupBy{}: 最基础的分组操作符.按照 lambda 的返回值进行分组.还有拓展的条件<ul><li>groupBy(keySelector = { it.first() }, valueTransform = { it.toUpperCase() })</li><li>keySelector: 指定分组的键值.</li><li>valueTransform: 对元素进行处理.</li></ul></li><li>对每个分组进行操作<ul><li>eachCount(): 计算每个分组的数量</li><li>reduce() / fold() / aggregate() 暂时没搞懂…</li></ul></li></ul></li><li><p>取子集操作符.顾名思义不对元素过滤,按照 <strong>索引</strong> 取指定的子集.(索引从 0 开始)</p><ul><li>slice(1…2): 选取集合 [1 2] 对应位置的子集.这里取子集的规则与循环那里类似.<ul><li>(1…3): [1,3] 闭区间</li><li>(0…4 step 2): [0,4] 闭区间,步长为 2 .实际上是 0 2 4.</li><li>(setOf(3, 5, 0)): 直接指定索引.</li></ul></li><li>take(): 从第一个元素开始连续选取几个元素.</li><li>takeWhile{}: 从第一个元素开始,如果 lambda 为 true 保留,否则丢弃.直到第一个 lambda 为 false 终止.</li><li>takeLast(): 从最后一个元素开始,倒着选取几个元素.</li><li>takeLastWhile{}: 从最后一个元素开始,倒序 如果 lambda 为 true 保留,否则丢弃.直到第一个 lambda 为 false 终止.</li><li>drop(): 从第一个元素开始,丢弃几个元素,并返回剩下的集合.</li><li>dropWhile{}: 从第一个元素开始, lambda 返回 true 丢弃,直到第一个 lambda 返回 false 终止,返回剩余集合.</li><li>dropLast(): 从最后一个元素开始,倒着丢弃几个元素,并返回剩下的集合.</li><li>dropLastWhile{}: 从最后一个元素开始,倒序 lambda 返回为 true 丢弃,直到第一个 lambda 返回 false 终止,返回剩余集合.</li><li>chunked(3){}: 按照索引步长为 3,对集合进行划分.后面可以跟 lambda 表示对一个组内的元素执行的操作.</li><li>windowed(3): 按照滑动窗口取索引进行分组.默认情况下,窗口大小 3 ,从第一个元素开始,取窗口类的3个元素.然后向下滑动 1 ,再取下一个窗口.可以自定义参数.<ul><li>windowed(3, step = 2, partialWindows = true): 窗口大小为 3,每次的步长为 2.partialWindows 是是否输出 最后小于步长的元素分组.</li></ul></li></ul></li><li><p>取单个元素:根据索引取单个元素.索引从 0 开始.</p><ul><li>elementAt(3): 取第 4 个元素.(从 0 开始),超出索引报错.</li><li>elementAtOrNull(5): 超出索引返回 null.</li><li>elementAtOrElse(5){}: 超出索引返回 lambda 的返回值.</li><li>first(): 返回第一个元素,索引0.</li><li>first{}: 返回第一个 lambda 为 true 的元素.</li><li>find{} = firstOrNull{} : 同上,但没有符合元素时返回 null .</li><li>last(): 返回最后一个元素</li><li>last{}: 从最后一个元素开始,倒序,返回第一个 lambda 为 true 的元素.</li><li>findLast{} = lastOrNull{}: 同上,但没有符合元素时返回 null .</li><li>random(): 随便取一个元素😂.</li><li>contains(a): a 是否在集合中,存在则返回 true.不存在则返回 false. 还有更简单调用 xx in 集合.</li><li>containsAll(listOf(“a”, “b”)): 一次检查多个元素.</li><li>isEmpty() / isNotEmpty() : 不解释.</li></ul></li><li><p>集合排序: 依照规则对集合元素排序.</p><ul><li>sorted(): 默认调用比较的对象实现 compareTo 方法.用户自定义类需要继承 Comparable 接口,实现 compareTo 方法.</li><li>reversed(): 默认调用比较的对象实现 compareTo 方法,逆序排序.返回一个包含结果的新集合,不影响原集合.</li><li>asReversed(): 效果同上,但原集合是不可变对象时,可能跟快更轻巧.</li><li>sortedWith(): 自定义一个比较器,每次比较即调用自定义的 Comparator .比较器还可以简单的使用 compareBy 和 lambda 生成. <code>compareBy &#123; it.length &#125;</code></li><li>sortedBy{}: 对于不可比较的对象,或者希望自定义顺序排序.依照 lambda 的结果顺序排序(实际上与 sortedWith() 差别不大)</li><li>sortedByDescending{}: 对于不可比较的对象,或者希望自定义顺序排序.依照 lambda 的结果逆序排序</li><li>shuffled(): 随机排序.</li></ul></li><li><p>聚合操作符: 大概是处理全部的元素,输出结果.</p><ul><li>min() / max(): 最值</li><li>average(): 平均值</li><li>count(): 元素个数.</li><li>maxBy{} / minBy{}: 根据 lambda 的结果返回最大,最小值.</li><li>maxWith() / minWith(): 对于不可比较对象和想自定义排序的,加载一个比较器.可以用 compareBy 和 lambda 生成.</li><li>sum(): 总和</li><li>sumBy{}: lambda 结果求和,元素必须为 Int.</li><li>sumByDouble{}: lambda 结果求和,元素必须为 Double.</li><li>fold(2){sum, element -&gt; xx}: sum 和 element 的 lambad 结果不断代入下一层循环的第一个参数 sum.默认第一轮是 sum = 2.</li><li>reduce { sum, element -&gt; xx}: sum 和 element 的 lambad 结果不断代入下一层循环的第一个参数 sum,默认 sum 是集合索引为 0 的元素.</li><li>reduceRight() / foldRight(): 同上,但是顺序从最后一个元素开始逆序.</li><li>reduceIndexed{idx, sum, element -&gt; xx} / foldIndexed(2){idx, sum, element -&gt; xx}: 带索引.</li><li>reduceRightIndexed{idx, sum, element -&gt; xx} / foldRightIndexed(2){idx, sum, element -&gt; xx}: 同上,但是从最后一个元素开始逆序.</li></ul></li></ul></li><li><p>作用域函数</p><ul><li>不同于集合操作符只能作用于集合对象,作用域函数可以作用于任意对象.</li><li>作用域函数只是在对象的上下文执行 lambda 闭包,没有引入新的功能.只是通过作用域函数代码不必再新命名变量,更加讲解易读.(越简洁,出错可能性越少)</li><li>run{}: 返回 lambda 执行的结果.没有闭包参数,使用 this 代指调用对象.</li><li>let{}: 返回 lambda 执行的结果.有闭包参数.可显式声明 <code>str:String -&gt; xx</code>,也可以使用 <code>it</code> 代指.</li><li>apply{} 不返回 lambda 执行结果,返回调用对象,可链式调用.没有闭包参数,使用 this 代指调用对象.</li><li>also{}: 不返回 lambda 执行结果,返回调用对象,可链式调用.有闭包参数.可显式声明 <code>str:String -&gt; xx</code>,也可以使用 <code>it</code> 代指.</li><li>takeIf{}: 返回判断的结果,lambda 为 true 返回此对象,否则返回 null.</li><li>takeUnless{}: 返回判断的结果,lambda 为 fasle 返回此对象,否则返回 null.</li><li>with(s){}: 与上面的不同,with 是顶级函数而不是拓展函数.对 s 进行一系列操作.</li><li>repeat: 同循环.</li></ul></li><li><p>运算符重载</p><ul><li>我们可以对 kt 的运算符重载,方便代码的编写.且重载运算符不会引入函数调用的开销.</li><li>kt 中运算符总数有上限,一个运算符实际对应一个函数调用,对应关系在编译时已经完成.</li><li>以 <code>a + b</code> 为例,编译器遇到 <code>+</code> 首先查找 a 的类型 T,在 T 中查找函数名为 plus() 参数为 T 类型的函数.且要求 plus() 被 <code>operator</code> 修饰.将运算符变成对应函数的调用.</li><li>一元运算符<ul><li>+a | a.unaryPlus()</li><li>-a | a.unaryMinus()</li><li>!a | a.not()</li><li>a++ | a.inc() +</li><li>a-- | a.dec() +</li></ul></li><li>二元运算符<ul><li>a + b | a.plus(b)</li><li>a - b | a.minus(b)</li><li>a * b | a.times(b)</li><li>a / b | a.div(b)</li><li>a % b | a.rem(b)</li><li>a…b | a.rangeTo(b)</li><li>a in b | b.contains(a)</li><li>a !in b | !b.contains(a)</li></ul></li><li>索引<ul><li>a[i] | a.get(i)</li><li>a[i, j] | a.get(i, j)</li><li>a[i_1, ……, i_n] | a.get(i_1, ……, i_n)</li><li>a[i] = b | a.set(i, b)</li><li>a[i, j] = b | a.set(i, j, b)</li><li>a[i_1, ……, i_n] = b | a.set(i_1, ……, i_n, b)</li></ul></li><li>调用<ul><li>a() | a.invoke()</li><li>a(i) | a.invoke(i)</li><li>a(i, j) | a.invoke(i, j)</li><li>a(i_1, ……, i_n) | a.invoke(i_1, ……, i_n)</li></ul></li><li>广义赋值<ul><li>a += b | a.plusAssign(b)</li><li>a -= b | a.minusAssign(b)</li><li>a *= b | a.timesAssign(b)</li><li>a /= b | a.divAssign(b)</li></ul></li><li>其他<ul><li>a == b | a?.equals(b) ?: (b === null)</li><li>a != b | !(a?.equals(b) ?: (b === null))</li><li>a &gt; b | a.compareTo(b) &gt; 0</li><li>a &lt; b | a.compareTo(b) &lt; 0</li><li>a &gt;= b | a.compareTo(b) &gt;= 0</li><li>a &lt;= b | a.compareTo(b) &lt;= 0</li></ul></li></ul></li><li><p>中缀表达式</p><ul><li>运算符的数量的不足,可以通过定义中缀表达式缓解.</li><li>例: <code>infix fun Int.io(string: String)&#123;&#125;</code><ul><li>中缀的函数必须由 infix 修饰.</li><li><code>.</code> 前面是函数接收者的类.只有此类型的对象才可以调用中缀表达式.(后面参数没有类型限制)</li><li>必须只有一个参数,且参数不得接受可变数量的参数不能有默认值.</li><li>可以使用 this 引用函数接收者的方法.</li></ul></li><li>调用 <code>4 io &quot;123&quot;</code> 当然也可以直接通过函数调用 <code>4.io(&quot;123&quot;)</code>.</li><li>要注意的是中缀表达式的优先级高于布尔操作符.低于算术操作符.</li></ul></li><li><p>反引号</p><ul><li>解决关键字冲突</li><li>强制不合法字符变为合法字符.</li><li>例如函数名声明为 <code>fun `123`</code>,调用时也是 <code>`123`()</code> 但是这个函数 <strong>在 java 中无法调用</strong> .无论是 <code>`123`()</code> 还是 <code>123()</code> 都无法调用.</li><li>还是慎用.除非你确定不想让 java 调用这个方法.</li></ul></li><li><p>对象的比较</p><ul><li>这个在初次接触 kt 时,被 <code>==</code> 和 <code>===</code> 坑了一把…</li><li>java 中引用的比较是 <code>a == b</code>,值的比较是 <code>a.equals(b)</code>,而在 kt 中值的比较是 <code>a == b</code>,引用的比较是 <code>a === b</code>. <code>==</code> 在 kt 和 java 中作用正好相反.</li></ul></li><li><p>类型别名</p><ul><li>给当前的类型起个别名,可以是方法,类,泛型等等.</li><li><code>typealias xx = xx</code> ,不会引入新类型,在编译时已经处理,不会影响运行速度.</li><li>kt 中非常多的集合类方法都是通过 typealias 来的.</li></ul></li><li><p>DSL(暂时跳过)</p></li><li><p>泛型: 使用泛型的初衷,大概希望把与数据结构无关的逻辑抽象出来,泛型是一个数据类型的标记. (明明写的是 kt 的泛型,java 写了一堆…😤…)</p><ul><li><p>java 泛型基本使用</p><ul><li><code>&lt;T&gt;</code> 基本形式,单独使用 T 相当于 Object.</li><li><code>&lt;T extends Number &amp; Interface1&gt;</code> 限制 T 只能为 Number 或者 Number 的子类,并且必须实现 Interface1.</li><li><code>&lt;?&gt;</code> 通配符,直接使用代表 object .</li><li><code>&lt;? extends SuperType&gt;</code> 上界通配符,限定传入的对象必须是 SuperType 或其子类.SuperType 可以是类或者接口.</li><li><code>&lt;? super SubType&gt;</code> 下界通配符,限定传入必须是 SubType 或其父类.SuperType 可以是类或者接口.</li><li>PECS 原则: Producer Extends Consumer Super,简而言之,只读 extends 只写 super</li><li>可以有泛型类,构造函数也可以是泛型,接口可以是泛型,静态成员不能有泛型,但可以声明静态泛型方法.</li></ul></li><li><p>java 类型擦除: java 对泛型的支持并不包括运行时支持,所有泛型参数在编译后都会被擦除.</p><ul><li><code>&lt;T&gt;</code> 当作 object,这样导致了一些 java 泛型的限制.<ul><li>基本类型不能转换成 object,所以泛型不能是基本类型.</li><li>无论是 <code>Pair&lt;String&gt;</code> 还是 <code>Pair&lt;Integer&gt;</code> 运行时 <code>getClass()</code> 得到的始终是同一个 <code>Pair.class</code>.因为在编译时两者都转换成了 <code>Pair&lt;Object&gt;</code>.</li><li>不能实例化 T 类型,要实例化 T 可以使用 <code>Class&lt;T&gt;</code> 通过反射来,使用时候传入具体的 xx.class.</li></ul></li><li><code>&lt;T extends Number&gt;</code> T 会替换成 Number 类型.具体使用时比如我们传入了 Integer 类型,编译器还会加上强制类型转换 <code>(Integer) xxx</code>.</li></ul></li><li><p>java 泛型限制</p><ul><li>不能是基本类型</li><li>不能实例化 T ,但可以通过反射 <code>Class&lt;T&gt;</code> 简介实现.</li><li>可以声明泛型数组,但不能直接创建泛型数组,必须强制转型.</li><li>静态成员不能有泛型.</li><li>不能继承或间接继承 Throwable 类.</li><li>重载方法时,不能重载编译后参数类型为相同原始的方法</li></ul></li><li><p>kt 泛型: kt 编译后也是 jvm 字节码,这意味着 kt 的泛型也不是类似 c# 的运行时的真泛型.但是 kt 相对 java 对泛型的支持还是激进了很多.</p></li><li><p>kt 泛型基本使用,与 java 没啥太大区别</p><ul><li><code>class Box&lt;T&gt; &#123;&#125;</code></li><li><code>fun &lt;K, V&gt; compare(p1: Pair&lt;K, V&gt;, p2: Pair&lt;K, V&gt;)&#123;&#125;</code></li><li><code>compare(Pair(1, &quot;1&quot;), Pair(2, &quot;2&quot;))</code> 类型可以推断,可以省略 <code>&lt;String,Inter&gt;</code></li></ul></li><li><p>泛型约束</p><ul><li><p><code>&lt;T&gt;</code> 默认代表 <code>Any?</code> 类型,可空.如果确认泛型不为空,应该使用 <code>&lt;T: Any&gt;.</code></p></li><li><p>与 java 不同,kt 的 <code>&lt;&gt;</code> 只能声明一个上界.多个上界需要 where.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">  <span class="keyword">where</span> T : Comparable&lt;T&gt;,</span><br><span class="line">        T : CharSequence &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>型变: 对参数类型进行子类型转换.</p><ul><li>例如 <code>List&lt;Integer&gt;</code> 与 <code>List&lt;Number&gt;</code> 两者在代码中依旧是不同的类,没有继承的关系.但是在 java 中通过通配符可以在两者之间建立继承关系.<ul><li>协变: <code>List&lt;? extends Number&gt;</code> 可以传入 <code>List&lt;Integer&gt;</code>.这样 <code>List&lt;Integer&gt;</code> 是 <code>List&lt;? extends Number&gt;</code> 的子类. Integer 是 Number 的子类.顺序的转换.</li><li>逆变: <code>List&lt;? super Integer&gt;</code> 可以传入 <code>List&lt;Number&gt;</code>.这样 <code>List&lt;Number&gt;</code> 是 <code>List&lt;? super Integer&gt;</code> 的子类,但是 Number 却是 Integer 的父类.这样的转换称为逆变.</li></ul></li><li>型变有两种<ul><li>使用时型变(类型投影): 泛型用在参数 属性 局部变量或返回值.在 java 就是 extend/super.在 kt 中对应 in/out .两者使用原则一致,不加赘述.</li><li>声明时型变: 泛型类型和泛型函数.java 不允许这样使用.kt 可以.</li></ul></li><li>例<ul><li>out: 修饰后传入对象为 T 或 T 的子类(协变).类似 extend 传入对象只读.T 通常用在成员函数的输出类型,而不用在输入. <code>interface Test&lt;out T&gt; &#123;fun nextT(): T&#125;</code></li><li>in: 修饰后传入对象为 T 或 T 的父类(逆变).类似 super 传入对象 只写.T 通常用在成员函数的输入类型,而不用在输出.<br><code>interface Test&lt;in T&gt; &#123;fun compareTo(other: T)&#125;</code></li></ul></li></ul></li><li><p>星投影: 使用泛型时候如果参数类型未知,使用时用 <code>*</code> 代替参数类型.java 中可以使用原始类型(Raw Type) 但是总归存在隐患.星投影比 java 的原始类型更加安全.</p><ul><li><p>使用 java 的原始类型,编译器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">unkownList</span> <span class="operator">=</span> list; <span class="comment">//原始类型</span></span><br><span class="line">unkownList.add(<span class="number">1</span>);  <span class="comment">//错误,但编译器提示不能检查此段代码</span></span><br></pre></td></tr></table></figure></li><li><p>星投影可以根据原泛型的声明,编译时检查代码,提示错误.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: ArrayList&lt;String&gt; = ArrayList(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> unkownList: ArrayList&lt;*&gt; = list <span class="comment">//星投影</span></span><br><span class="line">unkownList.add(<span class="number">1</span>) <span class="comment">//编译器提示错误.</span></span><br></pre></td></tr></table></figure></li><li><p><code>Foo &lt;out T : TUpper&gt;</code>: T 具有上界 TUpper 的协变类型参数.<code>Foo &lt;*&gt;</code> 等价于 <code>Foo &lt;out TUpper&gt;</code>. 当 T 未知时,可以安全地从 <code>Foo &lt;*&gt;</code> 读取 TUpper 的值.</p></li><li><p><code>Foo &lt;in T&gt;</code>: T 是逆变类型参数,<code>Foo &lt;*&gt;</code> 等价于 <code>Foo &lt;in Nothing&gt;</code>. T 未知时,无法安全写入 <code>Foo &lt;*&gt;</code>.</p></li><li><p><code>Foo &lt;T : TUpper&gt;</code>: T 具有上界 TUpper 的不型变类型参数.<code>Foo&lt;*&gt;</code> 读取时等价于 <code>Foo&lt;out TUpper&gt;</code>, 写入时等价于 <code>Foo&lt;in Nothing&gt;</code>.</p></li><li><p>对有多个泛型参数的方法或类,每个参数的星投影独立生效,互不影响.</p></li></ul></li><li><p>&quot;真&quot;泛型: 因为类型擦除, java 中无法在运行时获取泛型 T 的class.但是 kt 中可以内联函数 + reified 修饰泛型,变通的实现.要加引号.</p><ul><li><p>例</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">Check</span><span class="params">()</span></span>:&#123;println(T:)&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; Check&lt;String&gt;() &#125;</span><br><span class="line"><span class="comment">//输出 class java.lang.String</span></span><br></pre></td></tr></table></figure></li><li><p>(此处可能是错的)编译器会将该方法内联到调用的地方,跟直接没有泛型方法这一层是一样的.这样实际上编译时候就 T 的具体类型已经知道了.</p></li><li><p>要注意的是 reified 的内联函数不能被 Java 调用.</p></li></ul></li></ul></li></ul><h2 id="第四章-kotlin-语法背后"><a class="markdownIt-Anchor" href="#第四章-kotlin-语法背后"></a> 第四章 kotlin 语法背后</h2><ul><li><p>val 与 var 区别</p><ul><li>var 有 set 和 get .val 只有 get .</li><li>val 修饰的变量是无法赋值,但是可以通过重写 get 方法使得返回值发生变化.</li></ul></li><li><p>真*常量</p><ul><li>val 前面使用 const 修饰.在编译时变量的值已经确定无法修改,这是常规意义上的常量.</li><li>const 只能修饰在 object 类型的属性,或者是 top-leve 类型.</li><li>具体是匿名内部类或者伴生对象.top-leve 就是变量直接定义在文件而不是类中.</li></ul></li><li><p>空安全: kt 这一点深得我心,工作接触 c 最触头的就是空指针.</p><ul><li>避免空指针无非只有两者途径.kt 中两者兼有.<ul><li>运行时处理,每次使用引用对象时进行判空.</li><li>编译时处理,不能为空的类型为空直接编译报错.</li></ul></li></ul></li><li><p>内联函数 与 lambda</p><ul><li><p>在高阶函数中提到了一个关键词 <code>inline</code> 可以将 lambda 直接转化为对应语句.相当于把 lambda 匿名内部类这一层去掉了.</p></li><li><p>这里就有一个问题,如果在高阶函数的 lambda 中有 return 会怎样?</p></li><li><p><code>inline</code> 把 lambda 这一层去掉了,那么 return 相当于直接写在了调用这个高阶函数的上层函数中.上层函数直接中断返回了.</p></li><li><p>实际上一般的 lambda 中不允许出现 return 语句,只能返回自身 <code>test1 &#123;return@test1&#125;</code>.只有 inline 修饰的内联函数的 lambda 才允许使用 return .</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test1 &#123;</span><br><span class="line">        println(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">        <span class="comment">//不允许错误</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">(<span class="keyword">crossinline</span> t1: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    t1.invoke()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于需要中断 lambda 自身,但是并不希望中断上级函数的,可以通过 crossinline 修饰 lambda.这样 lambda 的调用依旧会被内联,但是 lambda 本身不再执行内联,lambda 内部返回与没有 inline 修饰时相同.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">(<span class="keyword">crossinline</span> t1: () -&gt; <span class="type">Unit</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>当高阶函数的返回值是一个 lambda 时,必须使用 noinline 修饰,拒绝内联,否则会出错.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">(<span class="keyword">noinline</span> t1: () -&gt; <span class="type">Unit</span>)</span></span>: () -&gt; <span class="built_in">Unit</span> &#123; <span class="keyword">return</span> t1 &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第五章-kotlin-扩展库"><a class="markdownIt-Anchor" href="#第五章-kotlin-扩展库"></a> 第五章 kotlin 扩展库</h2><h3 id="协程"><a class="markdownIt-Anchor" href="#协程"></a> 协程</h3><ul><li><p>协程还没有统一的定义.kt 的协程也有一堆神仙在打架,暂时专注在用法上.底层有机会翻完源码再撕.kt 的协程在 1.3 版本正式加入,1.3 以前的一些 api 已经不再适用.</p></li><li><p>暂时的看法是: kt-jvm 的协程当作轻量级线程.</p><ul><li>kt-jvm 始终是依托 jvm 虚拟机,应该是无法突破 jvm 的限制(可能,大概,也许).kt-jvm 协程的本质可能还是j ava 线程的友好封装?(存疑).</li><li>如何解决并发任务? 想起了被 java 回调地狱支配的恐惧,后来 rxjava 链式操作解放了我们. kt 协程更进一步,按照官方文档说是可以通过看似同步的代码实现非阻塞式的异步任务,挺绕的,但是好用.</li></ul></li><li><p>添加协程支持</p><ul><li><p>在 project 的 build.gradle 添加一个环境变量 <code>ext.kotlin_coroutines = '1.3.3'</code>(目前最新版本是 1.3.3)</p></li><li><p>在 module 的 build.gradle 添加核心库和平台库(这里是 android)</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:<span class="variable">$kotlin_coroutines</span>&quot;</span></span><br><span class="line">implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:<span class="variable">$kotlin_coroutines</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动协程</p><ul><li>runBlocking(){}: 线程切换到协程,但会阻塞当前所在的线程,一般仅在单元测试时使用.</li><li>GlobalScope.xx: 不会阻塞线程,但 GlobalScope 启动的协程与应用的生命周期一致,同样不推荐<ul><li>launch(){}: 最常用的启动协程的方式,返回一个 Job 类型的对象.</li><li>async/await(){}: 启动协程并返回执行的结果,返回一个 Deferre 对象.</li></ul></li><li>自定义 CoroutineContext: 推荐.之后的方法有 launch/async/await.此处就不展开了,等待刷完 jetpack 再补充.</li></ul></li><li><p>协程的启动方式.在启动参数的第二个 start: CoroutineStart.</p><ul><li>DEFAULT: 默认的启动方式,当前线程什么时候有空,什么时候启动.</li><li>LAZY: 没有手动调用启动时不会启动.例如 Job 类型对象就是调用 start 或 join 方法.</li><li>ATOMIC: 原子类型? 只要启动就停不下来.(啥时候用?)</li><li>UNDISPATCHED: 未定义.用于自定义启动参数.</li><li>block: suspend CoroutineScope.() -&gt; Unit : 要执行的闭包,真正的协程内容.</li></ul></li><li><p>协程取消(基本是 Job 类型的对象)</p><ul><li><p>最简单的是 <code>.cancel()</code> 取消后协程不再返回.<code>.join()</code>: 等待协程结束. 或者使用 <code>.cancelAndJoin()</code> 等价于 <code>.cancel()</code> 和 <code>.join()</code> 连用.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123;</span><br><span class="line">    repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">        println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">        delay(<span class="number">500L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">1200L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">job.cancel() <span class="comment">// 取消该作业</span></span><br><span class="line">job.join() <span class="comment">// 等待作业执行结束</span></span><br><span class="line">println(<span class="string">&quot;main: over&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>但是对于执行计算任务的协程,<code>cancel()</code> 以后还正常输出到结束. 对于计算任务的协程取消需要在协程内检查 isActive.(通知协程自尽)</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line"><span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">    <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123; <span class="comment">// 一个执行计算的循环，只是为了占用 CPU 每秒打印消息两次</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">            println(<span class="string">&quot;循环: $&quot;</span>)</span><br><span class="line">            nextPrintTime += <span class="number">500L</span> &#125;&#125;&#125;</span><br><span class="line">delay(<span class="number">1300L</span>) <span class="comment">// 等待一段时间</span></span><br><span class="line">job.cancelAndJoin() <span class="comment">// 取消一个作业并且等待它结束</span></span><br><span class="line">println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>取消协程时会抛出 <code>CancellationException</code> 异常,因此可与 try-finally 连用,在结束协程时释放某些资源.在 finally 代码块中,如果必须调用阻塞式的代码,可以使用 <code>withContext(NonCancellable) &#123;……&#125;</code> 包装.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        withContext(NonCancellable) &#123;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">1300L</span>) <span class="comment">// 延迟一段时间</span></span><br><span class="line">println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">job.cancelAndJoin() <span class="comment">// 取消该作业并等待它结束</span></span><br><span class="line">println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>还有一种情况是协程运行超时,例如网络请求有有一个最长超时时间.可以利用 withTimeout() 实现协程超时自杀.自杀后会抛出 TimeoutCancellationException 异常.通过 try-finally 进行一些关闭资源的工作.如果不需要这个处理,可以采用 withTimeoutOrNull() 避免抛出异常.两者功能相同.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300L</span>) &#123;</span><br><span class="line">    repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">        println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">        delay(<span class="number">500L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;Done&quot;</span> <span class="comment">// 在它运行得到结果之前取消它</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Result is <span class="variable">$result</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>async 实现并发</p><ul><li><p>假设有这样两个函数</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">One</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里做了一些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">Two</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里也做了一些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计算两者的和 <code>val tmp = One()+Two()</code>.这样代码是串行执行,总共要 2s.有了协程后,我们能不能把两个函数扔到两个协程里面,同时开始执行?这样可以节省一半的时间.</p></li><li><p>肯定是可以的,通过协程的 async 包装,await 获取结果就能实现并行.最后输出运行时间是 1035 ms.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">    <span class="keyword">val</span> one = async &#123; One() &#125;</span><br><span class="line">    <span class="keyword">val</span> two = async &#123; Two() &#125;</span><br><span class="line">    println(<span class="string">&quot;The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>但是这样非常不方便异常处理.假设 val one = async { One() } 这一行因为 One() 内部的 bug 而抛出异常.正常情况下程序应当停止创建和启动 one 这个协程,并抛出异常的信息给开发者,之后就跳过这个代码块执行其他内容.但是就这里的代码而言,程序还是会继续向下执行并创建和启动 one 这个协程,虽然最终结果都是抛出异常终止了代码块的执行.</p></li><li><p>正确的风格: 使用 coroutineScope 将协程执行部分包装成一个异步函数,当代码块遇到异常时会直接终止,抛出异常.主函数调用依然是并行执行.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">concurrentSum</span><span class="params">()</span></span>: <span class="built_in">Int</span> = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> one = async &#123; One() &#125;</span><br><span class="line">    <span class="keyword">val</span> two = async &#123; Two() &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>协程上下文与调度器</p><ul><li><p>上下文是 Job 类型对象启动参数的第一个,用在协程直接切换传递参数,就是协程的调度器.决定协程运行在那个线程.</p></li><li><p>调度器</p><ul><li><p>Dispatchers.Default: 默认调度,使用 jvm 的共享线程池,适合 cpu 密集型.</p></li><li><p>Dispatchers.Main: 运行在主线程,Android 更新 UI 等.</p></li><li><p><span class="exturl" data-url="aHR0cDovL0Rpc3BhdGNoZXJzLklP">Dispatchers.IO<i class="fa fa-external-link-alt"></i></span>: 适合 IO 密集型.</p></li><li><p>newSingleThreadContext(“xxx”): 开启一个新线程来执行协程,这样代价很高,一般会复用线程以节省资源.当协程和线程不再需要时必须关闭.</p></li><li><p>Dispatchers.Unconfined: 这个特殊一点,是非受限调度器.它仅仅运行到协程代码块中第一次挂起的地方.之后协程在那个线程恢复完全由被调用的挂起函数来决定,即不限制恢复的线程.程序第二次会输出运行在 delay() 的 DefaultExecutor 的线程上.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Unconfined) &#123; <span class="comment">// 非受限的——将和主线程一起工作</span></span><br><span class="line">    println(<span class="string">&quot;Unconfined      : I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    println(<span class="string">&quot;Unconfined      : After delay in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>子协程</p><ul><li>当一个协程被其它协程在 CoroutineScope 中启动的时,新协程将通过 CoroutineScope.coroutineContext 来继承上下文,并且这个新协程的 Job 将会成为父协程的子协程.当父协程被取消时,其所有子协程也会被递归的取消.</li><li>当使用 GlobalScope 启动是个特例,这里新协程没有父协程.因此它与这个启动的作用域无关且独立运作.</li></ul></li><li><p>协程作用域</p><ul><li><p>上文提到使用 GlobalScope 启动的协程生命周期和整个应用的生命周期一致.而在具体的 Android 应用中协程直观上应该是和使用它的组件生命周期一致.因此直接使用 GlobalScope 并不是一个很好的协程启动方式.而且必须考虑在应用退出函数中取消掉所有协程,而以 GlobalScope 启动的协程必须一个一个取消,协程数量一旦上去了,非常麻烦.</p></li><li><p>最好是自行创建一个 CoroutineScope 来管理协程的生命周期.</p><ul><li><p>实现 CoroutineScope() 接口: 使用委托模式同时指定调度器</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() ,  CoroutineScope <span class="keyword">by</span> CoroutineScope(Dispatchers.Default)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">      cancel() <span class="comment">// activity 退出时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MainScope() 方法:</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>管道 channel</p><ul><li><p>kt 的 channel 专门用于协程之间通信.最简单的声明一个 channel 类型变量,一个协程 send 一个协程 receive .</p></li><li><p>channel 还可以使用 for 循环遍历.但所有元素均 send 完毕,调用 close 关闭.</p></li><li><p>channel 是一个典型的生产者/消费者模式,通常使用 produce 来构建 channel 的生产者协程,返回一个 ReceiveChannel&lt;&gt; 类型.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Test</span><span class="params">()</span></span> = GlobalScope.produce &#123;</span><br><span class="line">    <span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) send(x * x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> test = Test()</span><br><span class="line">    <span class="keyword">for</span> (y <span class="keyword">in</span> test) println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配合协程 channel 可以产生类似流一样效果.生产,过滤,消费.</p></li><li><p>channel 可以是一对多,多对多,多对一.效果一致,先进先出的队列.</p></li><li><p>channel 可以指定缓存池 <code>Channel&lt;&gt;(5)</code>,在 produce 中通过 capacity 参数指定 <code>GlobalScope.produce(capacity = 5) &#123;&#125;</code>.当缓存池满时,send 协程会暂时挂起,直到缓存池有空余.缓存池为空,receive 协程会挂起,直到缓存池有元素.</p></li></ul></li></ul></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Jasper</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jasper1024.com/jasper/f93ae632/" title="kotlin 基础速描">https://jasper1024.com/jasper/f93ae632/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/kotlin/" rel="tag"># kotlin</a></div><div class="post-nav"><div class="post-nav-item"><a href="/jasper/f142c955/" rel="prev" title="iptables 速描"><i class="fa fa-angle-left"></i> iptables 速描</a></div><div class="post-nav-item"><a href="/jasper/f93ae635/" rel="next" title="miwifi_mini 5G中继">miwifi_mini 5G中继 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-disqus">disqus</a></li><li class="tab"><a href="#comment-utterances">utterances</a></li></ul><div class="tab-content"><div class="tab-pane disqus" id="comment-disqus"><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><div class="tab-pane utterances" id="comment-utterances"><div class="comments utterances-container"></div></div></div></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">JasperHale</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">20:54</span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phc3Blci0xMDI0" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"jasper1024","count":true,"i18n":{"disqus":"disqus"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/disqus.min.js" defer></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Jasper-1024/blog_discuss","issue_term":"pathname","theme":"github-dark"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/utterances.min.js" defer></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>