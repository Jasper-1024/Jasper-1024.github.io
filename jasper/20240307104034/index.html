<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="M2t8cZr5nIzHmltyt7Utj3nWYxNyNkCzFyigXBHkGUs"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"jasper1024.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.25.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"vs2015","dark":"vs2015"},"prism":{"light":"prism-vsc-dark-plus","dark":"prism-vsc-dark-plus"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"disqus","order":-1},"utteranc":{"text":"utteranc","order":-2}}},"stickytabs":true,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/config.min.js" defer></script><meta name="description" content="资料来源:  https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;why-async-rust&#x2F;    更新 12024.03.07 初始"><meta property="og:type" content="article"><meta property="og:title" content="为什么选择 async Rust"><meta property="og:url" content="https://jasper1024.com/jasper/20240307104034/index.html"><meta property="og:site_name" content="默"><meta property="og:description" content="资料来源:  https:&#x2F;&#x2F;without.boats&#x2F;blog&#x2F;why-async-rust&#x2F;    更新 12024.03.07 初始"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-03-07T12:00:00.000Z"><meta property="article:modified_time" content="2024-03-07T22:46:32.000Z"><meta property="article:author" content="Jasper"><meta property="article:tag" content="async"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jasper1024.com/jasper/20240307104034/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jasper1024.com/jasper/20240307104034/","path":"jasper/20240307104034/","title":"为什么选择 async Rust"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>为什么选择 async Rust | 默</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-207687331-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-207687331-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/analytics/google-analytics.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/comments.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/utils.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/motion.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/sidebar.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/next-boot.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/pjax.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.5.0/dist/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/search/local-search.min.js" defer></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/pdf.min.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.10.1/dist/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/tags/mermaid.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/fancybox.min.js" defer></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ItayEcWO7OsLFKF2Y8SsAYG1-MdYXbMMI","app_key":"18UBQFmJXXcOQFebLovT36lh","server_url":null,"security":false}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/statistics/lean-analytics.min.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/quicklink@3.0.1/dist/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://jasper1024.com/jasper/20240307104034/"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/quicklink.min.js" defer></script><link rel="stylesheet" href="source/_data/callout_blocks.css"><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="默" type="application/rss+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">默</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">生存是唯一的长路</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">45</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">330</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">65</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-comments fa-fw"></i>留言</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%AF%AD"><span class="nav-number">1.</span> <span class="nav-text">导语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%9C%AF%E8%AF%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF"><span class="nav-number">2.1.</span> <span class="nav-text">关于术语的一些背景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-rust-%E7%9A%84%E5%8F%91%E5%B1%95"><span class="nav-number">3.</span> <span class="nav-text">Async Rust 的发展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BF%E8%89%B2%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">绿色线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#future"><span class="nav-number">3.3.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asyncawait"><span class="nav-number">3.4.</span> <span class="nav-text">Async&#x2F;await</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E7%BB%87%E4%B8%8A%E7%9A%84%E8%80%83%E8%99%91"><span class="nav-number">4.</span> <span class="nav-text">组织上的考虑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD"><span class="nav-number">5.</span> <span class="nav-text">未完待续</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Jasper" src="/images/avatar.jfif"><p class="site-author-name" itemprop="name">Jasper</p><div class="site-description" itemprop="description">微尘</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">330</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">45</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phc3Blci0xMDI0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jasper-1024"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><a href="/ljy087621@gmail.com" title="E-Mail → ljy087621@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly94LmNvbS9KYXNwZXJfMTAyNA==" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;Jasper_1024"><i class="fab fa-twitter fa-fw"></i>Twitter</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL2phc3BlcjEwMjQ=" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;jasper1024"><i class="fab fa-skype fa-fw"></i>Telegram</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fas fa-rss fa-fw"></i>RSS</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tLw==" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;">forecho</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmZvcmVjaG8uY29tL2ZyaWVuZHNoaXAtbGlua3Mv" title="https:&#x2F;&#x2F;blog.forecho.com&#x2F;friendship-links&#x2F;">友链聚合</span></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jasper1024.com/jasper/20240307104034/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jfif"><meta itemprop="name" content="Jasper"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="默"><meta itemprop="description" content="微尘"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="为什么选择 async Rust | 默"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">为什么选择 async Rust</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-03-07 12:00:00 / 修改时间：22:46:32" itemprop="dateCreated datePublished" datetime="2024-03-07T12:00:00Z">2024-03-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a> </span></span><span id="/jasper/20240307104034/" class="post-meta-item leancloud_visitors" data-flag-title="为什么选择 async Rust" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/jasper/20240307104034/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="jasper/20240307104034/" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><ul><li><p>资料来源:</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93aXRob3V0LmJvYXRzL2Jsb2cvd2h5LWFzeW5jLXJ1c3Qv">https://without.boats/blog/why-async-rust/<i class="fa fa-external-link-alt"></i></span></p></blockquote></li><li><p>更新</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024.03</span>.<span class="number">07</span> 初始</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h2 id="导语"><a class="markdownIt-Anchor" href="#导语"></a> 导语</h2><p>gpt 译文, 翻译质量已足够可读, 仅校正少量;</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>Rust 中的 async/await 语法最初发布时,受到了极大的欢呼和兴奋.引用当时 Hacker News 上的 <span class="exturl" data-url="aHR0cHM6Ly93aXRob3V0LmJvYXRzL2Jsb2cvd2h5LWFzeW5jLXJ1c3Qv">评论<i class="fa fa-external-link-alt"></i></span>:</p><blockquote><p>这将打开闸门.我确信很多人都在等待这一时刻来采用 Rust.我就是其中之一.</p><p>这里面包含了所有的优点: 开源、高质量的工程、开放的设计、为一个复杂的软件做出巨大贡献的众多贡献者.真正鼓舞人心!</p></blockquote><p>最近,对此的反响则喜忧参半.再次引用 Hacker News 上关于近期一篇相关博文的 <span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTM3NDM2NDEz">评论<i class="fa fa-external-link-alt"></i></span>:</p><blockquote><p>我真的无法理解,有人怎么能看着 Rust 的异步这一团糟,还认为这是一个已经臭名昭著的复杂语言的好设计.</p><p>我试图去理解它,我真的尝试了,但天啊,那真是一团糟.而且它污染了所有与之接触的东西.我真的很喜欢 Rust,这些天我的大部分编码都在用它,但每当我遇到大量使用异步的 Rust 代码时,我的下巴就会紧绷,视线模糊.</p></blockquote><p>当然,这两条评论都不能完全代表大众: 即使在四年前,一些人也提出了担忧.而在这条关于下巴紧绷、视线模糊的评论所在的讨论串中,也有许多人以同样的热情为 async Rust 辩护.但我认为,随着时间的推移,否定者变得更加众多,语气也更加尖锐,这一点应该不会有太大争议.在某种程度上,这只是炒作周期的自然发展,但我也认为,随着我们与最初的设计过程渐行渐远,一些背景已经丢失了.</p><p>在 2017 年至 2019 年间,我与他人合作,在前人工作的基础上,推动了 async/await 语法的设计.原谅我会对有人说 &quot; 不知道有谁能看着那个 ’ 乱七八糟 ’ 的东西还 ’ 认为这是一个好设计 '&quot; 感到不快,请允许我在这篇组织不太完善、冗长的文章中解释 async Rust 是如何诞生的,它的目的是什么,以及为什么在我看来,对于 Rust 而言别无选择.我希望在此过程中,我能够稍微更广泛、更深入地阐明 Rust 的设计,而不仅仅是重复过去的论证.</p><h3 id="关于术语的一些背景"><a class="markdownIt-Anchor" href="#关于术语的一些背景"></a> 关于术语的一些背景</h3><p>在这场辩论中,争议的核心是 Rust 决定使用 &quot; 无栈协程 &quot;(stackless coroutine) 方法来实现用户空间并发 (user-space concurrency).讨论中抛出了很多术语,不熟悉这些术语很正常.</p><p>我们需要弄清楚的第一个概念是这个特性的目的:&quot; 用户空间并发 &quot;.主要的操作系统提供了一组相当相似的接口来实现并发: 你可以生成线程,并在这些线程上使用系统调用执行 IO,这会阻塞该线程直到完成.这些接口的问题在于,它们涉及某些开销,当你想达到某些性能目标时,这些开销可能会成为限制因素.这有两个方面:</p><ol><li>内核和用户空间之间的上下文切换在 CPU 周期方面很昂贵.</li><li>OS 线程有一个大的预分配堆栈,这增加了每线程的内存开销.</li></ol><p>这些限制在某种程度上是可以接受的,但对于大规模并发程序来说,它们并不适用.解决方案是使用非阻塞 IO 接口,并在单个 OS 线程上调度许多并发操作.程序员可以 &quot; 手工 &quot; 完成这一点,但现代语言经常提供一些工具来简化这一过程.从抽象上讲,语言有一些方法将工作划分为任务,并将这些任务调度到线程上.Rust 的系统就是 async/await.</p><p>在这个设计空间中,第一个选择是协作式 (cooperative) 调度和抢占式 (preemptive) 调度? 任务是否必须 &quot; 协作式地 &quot; 将控制权交还给调度子系统,还是可以在运行时的某个点被 &quot; 抢占式地 &quot; 停止,而任务本身并不知情?</p><p>在这些讨论中经常被提及的一个术语是协程 (coroutine),它的使用方式有些矛盾.协程是一个可以暂停然后恢复的函数.最大的歧义在于,有些人使用 &quot; 协程 &quot; 这个术语来指代一个函数,它有显式的语法来暂停和恢复自己 (这对应于协作式调度的任务),而有些人用它来指代任何可以暂停的函数,即使暂停是由语言运行时隐式执行的 (这也包括抢占式调度的任务).我更倾向于第一个定义,因为它引入了某种有意义的区分.</p><p>另一方面,Goroutine 是一个 Go 语言特性,它支持并发的、抢占式调度的任务.它们有一个与线程相同的 API,但它是作为语言的一部分实现的,而不是作为操作系统原语,在其他语言中,它们通常被称为虚拟线程 (virtual thread) 或绿色线程 (green thread).所以按照我的定义,Goroutine 不是协程,但其他人使用更广泛的定义,说 Goroutine 是一种协程.我将把这种方法称为绿色线程,因为这是 Rust 中使用的术语.</p><p>第二个选择轴是有栈协程 (stackful coroutine) 和无栈协程 (stackless coroutine) 之间的选择.有栈协程以与 OS 线程相同的方式拥有一个程序栈: 当作为协程的一部分调用函数时,它们的帧被压入堆栈; 当协程让出时,堆栈的状态被保存,以便可以从同一位置恢复.另一方面,无栈协程以不同的方式存储它需要恢复的状态,例如在 延续 (continuation) 或状态机中.当它让出时,它正在使用的堆栈被接管它的操作使用,当它恢复时,它重新获得对堆栈的控制,该延续或状态机用于从它停止的地方恢复协程.</p><p>在 async/await 中 (在 Rust 和其他语言中) 经常提到的一个问题是 &quot; 函数染色问题 &quot;(function coloring problem) - 有人抱怨,为了获得异步函数的结果,你需要使用不同的操作 (例如 <code>await</code>),而不是正常调用它.绿色线程和有栈协程机制都可以避免这种情况,因为正是那种特殊语法被用来表明某些特殊的事情正在发生,以管理协程的无栈状态 (具体取决于语言).</p><p>Rust 的 async/await 语法是无栈协程机制的一个例子: 异步函数被编译成返回 Future 的函数,该 Future 用于在协程让出控制时存储其状态.这场辩论的基本问题是,Rust 采用这种方法是否正确,或者它是否应该采用更类似 Go 的 &quot; 有栈 &quot; 或 &quot; 绿色线程 &quot; 方法,最好没有明确的语法来 &quot; 染色 &quot; 函数.</p><h2 id="async-rust-的发展"><a class="markdownIt-Anchor" href="#async-rust-的发展"></a> Async Rust 的发展</h2><h3 id="绿色线程"><a class="markdownIt-Anchor" href="#绿色线程"></a> 绿色线程</h3><p>第三条 Hacker News <span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTM3NzkxNjM1">评论<i class="fa fa-external-link-alt"></i></span> 很好地代表了我经常在这场辩论中看到的那种言论:</p><blockquote><p>人们想要的替代并发模型是通过有栈协程和通道实现的结构化并发, 底层交由工作窃取执行器调度.</p><p>在有人实现了这个原型并将其与 async/await 和 future 进行比较之前,我认为没有任何有成效的讨论可以进行.</p></blockquote><p>暂且不提对结构化并发、通道和工作窃取执行器的引用 (完全是关注的焦点),令人不解的是,像这样的评论所说,Rust 最初确实有一种有栈协程机制,以绿色线程的形式存在.它在 2014 年底,也就是 1.0 版发布前不久被移除了.了解其中的原因将有助于我们深入了解 Rust 为何推出 async/await 语法.</p><p>对于任何绿色线程系统 - Rust 的、Go 的或任何其他语言的 - 一个大问题是如何处理这些线程的程序栈.请记住,用户空间并发机制的目标之一是减少 OS 线程使用的大型预分配栈带来的内存开销.因此,绿色线程库倾向于尝试采用一种机制来生成具有更小堆栈的线程,并且只在需要时才增加堆栈大小.</p><p>一种实现这一点的方法是所谓的 &quot; 分段栈 &quot;(segmented stack),其中栈是一个小栈段的链表; 当栈增长超过其段的界限时,一个新的段被添加到列表中,当它收缩时,该段被删除.这种技术的问题是,它在将栈帧压入栈的成本方面引入了很高的可变性.如果帧适合当前段,这基本上是无成本的.如果不适合,就需要分配一个新段.这种情况下一个特化版本是,当一个热循环中的函数调用需要分配一个新段时.这会在每次循环迭代中添加一次分配和释放,对性能产生重大影响.而且它对用户来说完全不透明,因为用户不知道在调用函数时堆栈会有多深.Rust 和 Go 都从分段栈开始,然后由于这些原因放弃了这种方法.</p><p>另一种方法被称为 &quot; 栈复制 &quot;(stack copying).在这种情况下,栈更像是一个 Vec 而不是一个链表: 当栈达到其限制时,它被重新分配得更大,这样就不会触及限制.这允许堆栈从小开始,并根据需要增长,而没有分段堆栈的缺点.这样做的问题是,重新分配堆栈意味着复制它,这意味着堆栈现在将位于内存中的新位置.任何指向堆栈的指针现在都无效,需要有某种机制来更新它们.</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNsb3VkZmxhcmUuY29tL2hvdy1zdGFja3MtYXJlLWhhbmRsZWQtaW4tZ28v">Go 使用栈复制<i class="fa fa-external-link-alt"></i></span>,并受益于在 Go 中,指向栈的指针只能存在于同一个栈中,所以它只需要扫描那个栈来重写指针. 然而这点却无法在 Rust 中实现, 首先 Rust 不保留的运行时类型信息, 其次 Rust 也允许指向栈的指针不存储在该栈内 (它们可能在堆的某个地方,或者在另一个线程的栈中). 跟踪这些指针的问题最终与垃圾收集的问题相同,只是跟踪指针后并不释放内存,而是移动内存. 因为 Rust 没有垃圾收集器, 所以最终 Rust 不能采用栈复制.相反,Rust 通过使其绿色线程变大来解决分段堆栈的问题,就像 OS 线程一样.但这消除了绿色线程的一个关键优势.</p><p>即使在像 Go 这样可以有可调整大小堆栈的情况下,在试图与用其他语言编写的库集成时,绿色线程也会带来某些不可避免的成本.带有 OS 堆栈的 C ABI 是每种语言的共享最小值.将代码从在绿色线程上执行切换到在 OS 线程堆栈上运行,对于 FFI 来说可能非常昂贵.Go 只是接受这种 FFI 成本;C# 最近因为这个原因 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvdG5ldC9ydW50aW1lbGFiL2lzc3Vlcy8yMzk4">中止了一个绿色线程实验<i class="fa fa-external-link-alt"></i></span>.</p><p>这对 Rust 来说尤其成问题,因为 Rust 旨在支持将 Rust 库嵌入到用另一种语言编写的二进制文件中,并在没有时钟周期或内存来操作虚拟线程运行时的嵌入式系统上运行的用例.为了尝试解决这个问题,绿色线程运行时被设计为可选的,Rust 可以改为编译为在本机线程上运行,使用阻塞 IO.这被设计为由最终二进制文件在编译时做出的决定.因此,有一段时间,有两种 Rust 变体,一种使用阻塞 IO 和本机线程,另一种使用非阻塞 IO 和绿色线程,所有代码都旨在与这两种变体兼容.这并没有很好地发挥作用,绿色线程最终因为 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9yZmNzL3B1bGwvMjMw">RFC 230<i class="fa fa-external-link-alt"></i></span> 而被移除,其中列举了原因:</p><ol><li>在绿色线程和本机线程之上的抽象并非 &quot; 零成本 &quot;,导致在执行 IO 时出现不可避免的虚拟调用和分配,这对本机代码来说尤其不可接受.</li><li>它迫使本机线程和绿色线程支持相同的 API,即使这没有意义.</li><li>它并非完全可互操作,因为仍然可能通过 FFI 调用本机 IO,即使在绿色线程上也是如此.</li></ol><p>移除了绿色线程,但高性能用户空间并发的问题仍然存在.Future trait 和后来的 async/await 语法就是为了解决这个问题而开发的.但要理解这条路径,我们需要再退一步,看看 Rust 对另一个问题的解决方案.</p><h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3><p>我认为通往 async Rust 之路的真正起点,要追溯到 2013 年一位名叫 Daniel Micay 的前贡献者在邮件列表上的一篇 <span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQwNzE2MTcyOTI4L2h0dHBzOi8vbWFpbC5tb3ppbGxhLm9yZy9waXBlcm1haWwvcnVzdC1kZXYvMjAxMy1KdW5lLzAwNDU5OS5odG1s">帖子<i class="fa fa-external-link-alt"></i></span>.这篇帖子与 async/await 或 future 或非阻塞 IO 无关: 它是关于迭代器的.Micay 提议将 Rust 转向使用所谓的 &quot; 外部 &quot; 迭代器,正是这一转变 - 以及它与 Rust 的所有权和借用模型相结合的效果 - 让 Rust 不可避免地走上了通往 async/await 的道路.显然,当时没有人知道这一点.</p><p>Rust 一直禁止通过与另一个变量别名的绑定来改变状态 - 这条 &quot; mutable XOR aliased &quot; 的规则在早期的 Rust 中与今天一样重要.但最初它是用不同的机制来强制执行的,而不是用生命周期分析.当时,引用只是 &quot; 参数修饰符 &quot;,在概念上类似于 Swift 中的 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnN3aWZ0Lm9yZy9zd2lmdC1ib29rL2RvY3VtZW50YXRpb24vdGhlLXN3aWZ0LXByb2dyYW1taW5nLWxhbmd1YWdlL2Z1bmN0aW9ucy8jSW4tT3V0LVBhcmFtZXRlcnM=">“inout” 修饰符<i class="fa fa-external-link-alt"></i></span>.2012 年,Niko Matsakis 提出并实现了 Rust 生命周期分析的第一个版本,将引用提升为真正的类型,并允许将它们嵌入到结构体中.</p><p>尽管人们正确地认识到,转向生命周期分析对 Rust 的巨大影响使其成为今天的样子,但它与外部迭代器的共生互动,以及该 API 对 Rust 定位到其当前领域的基础性作用,还没有得到足够的重视.在采用 &quot; 外部 &quot; 迭代器之前,Rust 使用一种基于回调的方法来定义迭代器,在现代 Rust 中,它看起来像这样:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ControlFlow</span> &#123;</span><br><span class="line">    Break,</span><br><span class="line">    Continue,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">iterate</span>(<span class="keyword">self</span>, f: <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> ControlFlow) <span class="punctuation">-&gt;</span> ControlFlow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方式定义的迭代器在集合的每个元素上调用它们的回调,除非它返回 <code>ControlFlow::Break</code>,在这种情况下,它们应该停止迭代.<code>for</code> 循环的主体被编译成一个闭包,传递给被循环的迭代器.这种迭代器比外部迭代器更容易编写,但这种方法有两个关键问题:</p><ol><li>语言无法保证当循环说要 <code>break</code> 时迭代实际上会停止,所以你不能依赖它来确保内存安全.这意味着从循环中返回引用是不可能的,因为循环实际上可能会继续.</li><li>它们不能用于实现交错多个迭代器的通用组合器,如 <code>zip</code>,因为 API 不支持交替地迭代一个迭代器,然后迭代另一个.</li></ol><p>相反,Daniel Micay 提议将 Rust 转向使用 &quot; 外部 &quot; 迭代器,它完全解决了这些问题,并具有 Rust 用户今天习惯的接口:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部迭代器与 Rust 的所有权和借用系统完美结合,因为它们本质上编译成一个结构体,将迭代状态保存在自身内部,因此可以像任何其他结构体一样包含对被迭代数据结构的引用.而且由于单态化,通过组装多个组合器构建的复杂迭代器也被编译成单个结构体,使其对优化器透明.唯一的问题是,它们很难手工编写,因为你需要定义将用于迭代的状态机.预示着未来的发展,Daniel Micay 当时写道:</p><blockquote><p>将来,Rust 可以使用 <code>yield</code> 语句实现像 C# 一样的生成器,编译成快速的状态机,而无需上下文切换、虚函数甚至闭包.这将消除手工编写外部迭代器进行递归遍历的难度.</p></blockquote><p>生成器的进展并不迅速,尽管最近发布了一个令人兴奋的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9ydXN0L3B1bGwvMTE2NDQ3">RFC<i class="fa fa-external-link-alt"></i></span>,这表明我们可能很快就会看到这个特性.</p><p>即使没有生成器,外部迭代器也被证明是一个巨大的成功,这种技术的总体价值得到了认可.例如,Aria Beingessner 在访问映射条目的 “Entry API” 中使用了类似的方法.值得注意的是,在该 API 的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9yZmNzL3B1bGwvMjE2">RFC<i class="fa fa-external-link-alt"></i></span> 中,她将其称为 &quot; 类似迭代器 &quot;.她的意思是,该 API 通过一系列组合器构建状态机,将自身呈现给编译器,从而具有高度可读性和可优化性.这种技术很有前景.</p><h3 id="future"><a class="markdownIt-Anchor" href="#future"></a> Future</h3><p>当 Aaron Turon 和 Alex Crichton 需要替换绿色线程时,他们首先复制了许多其他语言中使用的 API,这个 API 后来被称为 future 或 promise.这样的 API 基于所谓的 &quot; 延续传递风格 &quot;(continuation passing style).以这种方式定义的 future 将回调作为附加参数,称为延续,并在 future 完成时将延续作为最后一个操作调用.这就是大多数语言中这种抽象的定义方式,大多数语言的 async/await 语法都被编译成这种延续传递风格.</p><p>在 Rust 中,那种 API 看起来像这样:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">schedule</span>(<span class="keyword">self</span>, continuation: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(<span class="keyword">Self</span>::Output));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aaron Turon 和 Alex Crichton 尝试了这种方法,但正如 Aaron Turon 在一篇启发性的博客文章中所写,他们很快遇到了一个问题,即使用延续传递风格通常需要分配回调.Turon 举了一个 <code>join</code> 的例子:<code>join</code> 接受两个 future,并同时运行它们.<code>join</code> 的延续需要由两个子 future 共同拥有,因为无论哪个 future 最后完成,都需要执行它.这最终需要引用计数和分配来实现,这被认为对 Rust 来说是不可接受的.</p><p>相反,他们研究了 C 程序员倾向于如何实现异步编程: 在 C 中,程序员通过构建状态机来处理非阻塞 IO.他们想要的是一个 Future 的定义,可以编译成 C 程序员手工编写的那种状态机.经过一些实验,他们得出了他们称之为 &quot; 基于就绪性 &quot;(readiness-based) 的方法:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于存储延续,future 由某个外部执行器轮询.当 future 处于 pending 状态时,它存储一种唤醒该执行器的方式,当它准备好再次被轮询时,它将执行该操作.通过这种方式反转控制,他们不再需要在 future 完成时存储回调,这允许他们将 future 表示为单个状态机.他们在这个接口之上构建了一个组合器库,所有这些组合器都将被编译成单个状态机.</p><p>从基于回调的方法转向外部驱动程序,将一组组合器编译成单个状态机,甚至这两个 API 的确切规范: 如果你读过前一节,所有这些听起来应该非常熟悉.从延续到轮询的转变与 2013 年迭代器的转变完全相同!再一次,正是 Rust 处理带有生命周期的结构体的能力,从而处理借用外部状态的无栈协程的能力,使其能够在不违反内存安全的情况下,以最佳方式将 future 表示为状态机.无论应用于迭代器还是 future,这种从较小的组件构建单对象状态机的模式都是 Rust 工作方式的关键部分.它几乎自然地从语言中产生.</p><p>我要暂停一下,强调迭代器和 future 之间的一个区别: 像 <code>Zip</code> 这样交错两个迭代器的组合器,使用基于回调的方法根本不可能,除非你的语言有某种你正在构建的协程的原生支持.另一方面,如果你想交错两个 future,像 <code>Join</code>,基于延续的方法可以支持这一点: 它只是带来一些运行时成本.这解释了为什么外部迭代器在其他语言中很常见,但 Rust 在将这种转换应用于 future 方面是独特的.</p><p>在最初的迭代中,future 库的设计原则是,用户将以与构建迭代器大致相同的方式构建 future: 低级库作者将使用 Future trait,而编写应用程序的用户将使用 future 库提供的一组组合器,从更简单的组件构建更复杂的 future.不幸的是,当用户试图遵循这种方法时,他们立即面临令人沮丧的编译器错误.问题是,当 future 被生成时,需要从周围的上下文中 &quot; 逃逸 &quot;,因此不能借用该上下文中的状态: 任务必须拥有其所有状态.</p><p>这对 future 组合器来说是一个问题,因为通常需要在构成 future 的一系列操作中的多个组合器中访问该状态.例如,用户通常会在一个对象上调用一个 &quot; 异步 &quot; 方法,然后再调用另一个方法,这将写成这样:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.<span class="title function_ invoke__">bar</span>().<span class="title function_ invoke__">and_then</span>(|result| foo.<span class="title function_ invoke__">baz</span>(result))</span><br></pre></td></tr></table></figure><p>问题是 <code>foo</code> 既在 <code>bar</code> 方法中被借用,又在传递给 <code>and_then</code> 的闭包中被借用.本质上,用户想要做的是一个 await 点前后存储状态 (await 点由 future 组合器的链接形成). 这通常会导致令人困惑的借用检查器错误.最容易的解决方案是将该状态存储在 <code>Arc</code> 和 <code>Mutex</code> 中,首先这并非零成本,更重要的是,随着系统复杂性的增加,这非常笨拙和尴尬.例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(foo));</span><br><span class="line">foo.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">bar</span>()</span><br><span class="line">   .<span class="title function_ invoke__">and_then</span>(<span class="keyword">move</span> |result| foo.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">baz</span>(result))</span><br></pre></td></tr></table></figure><p>尽管 future 在最初的实验中表现出了很好的基准测试结果,但这个限制的结果是,用户无法使用它们来构建复杂的系统.这就是我开始的地方.</p><h3 id="asyncawait"><a class="markdownIt-Anchor" href="#asyncawait"></a> Async/await</h3><p>2017 年末,很明显由于用户体验不佳,future 生态系统未能启动.future 项目的最终目标一直是实现所谓的 &quot; 无栈协程转换 &quot;,其中使用 <code>async</code> 和 <code>await</code> 语法运算符的函数可以转换为计算 future 的函数,避免用户必须手动编写 future.Alex Crichton 开发了一个基于宏的 async/await 实现作为 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsZXhjcmljaHRvbi9mdXR1cmVzLWF3YWl0">库<i class="fa fa-external-link-alt"></i></span>,但这几乎没有引起任何关注. 改变需要发生了.</p><p>Alex Crichton 的宏的最大问题之一是,如果用户试图持有一个跨 await 点的对 future 状态的引用,它会产生一个错误.这实际上与用户在 future 组合器中遇到的借用问题是同一个问题,再次出现在新的语法中.future 不可能在 Pending 同时 持有对自身状态的引用,因为这需要把 future 编译成一个自引用结构体,而 Rust 不支持这一点.</p><p>将此与绿色线程的问题进行比较很有趣.我们解释 future 编译为状态机的一种方式是说状态机是一个 &quot; 完美大小的栈 &quot; - 与绿色线程的栈不同,绿色线程的栈必须增长以适应任何线程栈可能具有的未知大小的状态,编译后的 future(无论是手动实现、使用组合器或使用异步函数) 的栈大小已经确定, 所以我们没有在运行时增长这个栈的问题.</p><p>绿色线程中需要保存的栈现在成为了 future 的状态机, future 状态机 被表示为一个结构体.Rust 层面 移动结构体始终是安全的.这意味着即使我们不需要在执行 future 时移动它,根据 Rust 的规则,我们也需要能够在运行时移动 future. 因此,类比绿色线程中遇到的栈指针问题, 新系统中又出现了指针问题重新出现.不过这一次,我们有一个优势,那就是我们不需要能够移动 future, 我们只需要表达 future 是不可移动的.</p><p>最初尝试实现这一点的方法是尝试定义一个新的 trait,称为 <code>Move</code>,用于从可以移动它们的 API 中排除协程.这在向后兼容性方面遇到了一些问题,我之前已经 <span class="exturl" data-url="aHR0cHM6Ly93aXRob3V0LmJvYXRzL2Jsb2cvY2hhbmdpbmctdGhlLXJ1bGVzLW9mLXJ1c3Q=">记录<i class="fa fa-external-link-alt"></i></span> 过了. async/await 有三个主要需求:</p><ol><li>Rust 需要引入 async/await 语法,以便用户可以使用类似协程的函数构建复杂的 future.</li><li>Async/await 语法需要支持将这些函数编译为自引用结构体,以便用户可以在协程中使用引用.</li><li>这个特性需要尽快发布.</li></ol><p>这三点的结合让我寻找替代 <code>Move</code> trait 的解决方案,一个可以在不对语言进行任何重大破坏性更改的情况下实现的解决方案.</p><p>我最初实现比我们最终得到的要差得多.我提议我们干脆让 <code>poll</code> 方法不安全,并包含一个不变量,即一旦开始轮询 future,就不能再移动它.这很简单,可以立即实现,而且非常强制: 它会使每个手写的 future 都不安全,并强加一个难以验证的要求,而编译器不提供任何帮助. 它可能最终会在某个还未发现的问题上碰到钉子,而且肯定会引起极大的争议.</p><p>所以 Eddy Burtescu 提出了一些意见,引导我走向一个更好的 API,这真是太好了,它可以让我们以更细粒度的方式强制执行所需的不变量.这最终成为 <code>Pin</code> 类型.<code>Pin</code> 类型本身已经引起了相当多的恼怒,但我认为它无疑是对我们当时正在考虑的其他选择的改进,因为它是有针对性的、可执行的,而且也可以按时发布.</p><p>回顾过去,固定 (pinning) 方法有两类问题:</p><ol><li>向后兼容性: 一些已经存在的接口 (特别是 <code>Iterator</code> 和 <code>Drop</code>) 由于各种原因应该支持不可移动类型,这限制了进一步开发语言的选择.</li><li>对最终用户的暴露: 我们的意图是编写普通异步 Rust 的用户永远不必处理 <code>Pin</code>.大多数情况下这是正确的,但也有一些值得注意的例外.其中几乎所有的问题都可以通过一些语法改进来解决.唯一真正糟糕 (也让我个人感到尴尬) 的是,你需要 pin 一个 future trait 对象才能 await 它.这是一个不必要的错误,现在修复它将是一个破坏性的改变.</li></ol><p>关于 async/await 唯一要做的其他决定是语法上的,我不会在这篇已经过长的文章中再次讨论.</p><h2 id="组织上的考虑"><a class="markdownIt-Anchor" href="#组织上的考虑"></a> 组织上的考虑</h2><p>我探索所有这些历史的原因是为了证明,一系列关于 Rust 的事实不可避免地将我们引向一个特定的设计空间.</p><ul><li>第一个是 Rust 缺乏运行时,这使得绿色线程成为一个不可行的解决方案,因为 Rust 需要支持嵌入 (无论是嵌入到其他应用程序还是在嵌入式系统上运行),并且因为 Rust 无法执行绿色线程所需的内存管理.</li><li>第二个是 Rust 具有将协程编译为高度可优化的状态机的天然能力,同时仍然保持内存安全,我们不仅为 future 而且为迭代器利用了这一点.</li></ul><p>但这段历史还有另一面: 为什么我们追求用户空间并发的运行时系统?为什么要有 future 和 async/await?这个论点通常有两种形式:</p><ul><li>一方面,你有习惯于 &quot; 手动 &quot; 管理用户空间并发的人,使用像 epoll 这样的接口; 这些人有时会嘲笑 async/await 语法是 &quot; 网络垃圾 &quot;.</li><li>另一方面,有些人只是说 &quot; 你不需要它 &quot;,并建议使用更简单的 OS 并发,如线程和阻塞 IO.</li></ul><p>在没有用户空间并发工具的语言 (如 C) 中实现高性能网络服务的人倾向于使用手写状态机来实现它们.这正是 Future 抽象被设计用来编译的东西,但不必手写状态机: 协程转换的全部意义在于: 顺序方式编写异步代码,状态转换交由编译器生成.这样做的好处是不容忽视的.最近的一个 curl <span class="exturl" data-url="aHR0cHM6Ly9kYW5pZWwuaGF4eC5zZS9ibG9nLzIwMjMvMTAvMTEvaG93LWktbWFkZS1hLWhlYXAtb3ZlcmZsb3ctaW4tY3VybC8=">CVE<i class="fa fa-external-link-alt"></i></span> 最终是由于未能识别状态转换期间需要保存的状态而引起的.在手动实现状态机时,这种逻辑错误很容易犯.</p><p>在 Rust 中发布 async/await 语法的目标是发布一个特性,避免这些错误,同时仍然具有相同的性能特征.考虑到我们提供的控制级别以及缺乏内存管理运行时,这些通常用 C 或 C++ 编写的系统被认为完全在我们的目标受众之内.</p><p>2018 年初,Rust 项目致力于发布一个新的 &quot; 版本 &quot;,以解决 1.0 出现的一些语法问题.还决定利用这个版本作为一个机会,宣传 Rust 已经准备好黄金时段的叙事;Mozilla 团队主要是编译器黑客和类型理论家,但我们对营销有一些基本的想法,并认识到这个版本是吸引人们对产品关注的机会.我向 Aaron Turon 提议,我们应该关注四个基本用户故事,这似乎是 Rust 的增长机会.它们是:</p><ol><li>嵌入式系统</li><li>WebAssembly</li><li>命令行接口</li><li>网络服务</li></ol><p>这个评论是创建 &quot; <span class="exturl" data-url="aHR0cHM6Ly9pbnRlcm5hbHMucnVzdC1sYW5nLm9yZy90L2Fubm91bmNpbmctdGhlLTIwMTgtZG9tYWluLXdvcmtpbmctZ3JvdXBzLzY3Mzc=">领域工作组<i class="fa fa-external-link-alt"></i></span> &quot; 的起点,这些工作组旨在成为关注特定使用 &quot; 领域 &quot; 的跨职能团队 (与控制某些技术或组织领域的现有 &quot; 团队 &quot; 相比).Rust 项目中工作组的概念从那时起发生了变化,基本上失去了这种意义,但我跑题了.</p><p>async/await 的工作由 &quot; 网络服务 &quot; 工作组 (最终被称为异步工作组,今天仍以这个名字存在) 率先开展.然而,我们也非常清楚,鉴于它缺乏运行时依赖性,异步 Rust 也可以在其他领域 (特别是嵌入式系统) 发挥巨大作用.我们在设计该功能时,考虑了这两个用例.</p><p>很明显,尽管通常没有说出来,Rust 需要的是行业采用,这样即使 Mozilla 不再愿意资助一种实验性的新语言,它也能继续获得支持.而且很明显,短期内最有可能被行业采用的途径是网络服务,尤其是那些性能要求当时迫使它们用 C/C++ 编写的服务.这个用例完美地适合 Rust 的定位 - 这些系统需要高度的控制来实现其性能要求,但避免可利用的内存错误至关重要,因为它们暴露在网络上.</p><p>网络服务的另一个优势是,这个软件行业领域有灵活性和胃口来快速采用像 Rust 这样的新技术.其他领域 - 现在仍然如此! - 被视为不会那么快地采用新技术 (嵌入式),依赖于一个自身尚未得到广泛采用的新平台 (WebAssembly),或者不是一个特别有利可图的工业应用,可以为语言提供资金 (CLI).我努力推动 async/await,勤奋而热忱地假设 Rust 的生存取决于这个特性.</p><p>在这方面,async/await 取得了巨大的成功.许多 Rust 基金会最著名的赞助商,尤其是那些支付开发者的赞助商,都依赖 async/await 在 Rust 中编写高性能网络服务,这是他们资助的主要使用案例之一.将 async/await 用于嵌入式系统或内核编程也是一个越来越受关注的领域,前景光明.Async/await 如此成功,以至于对它最常见的抱怨是生态系统过于以它为中心,而不是 &quot; 普通 &quot; 的 Rust.</p><p>我不知道该对那些宁愿只使用线程和阻塞 IO 的用户说什么.当然,我认为对于许多系统来说,这是一种合理的方法.Rust 语言中没有任何东西阻止他们这样做.他们的反对意见似乎是 <span class="exturl" data-url="aHR0cDovL2NyYXRlcy5pbw==">crates.io<i class="fa fa-external-link-alt"></i></span> 上的生态系统,特别是用于编写网络服务的生态系统,以使用 async/await 为中心.偶尔,我会看到一个库以 &quot; 货物崇拜 &quot; 的方式使用 async/await,但大多数情况下,似乎可以安全地假设该库的作者实际上想要执行非阻塞 IO 并获得用户空间并发的性能优势.</p><p>我们谁也无法控制其他人决定做什么,事实就是大多数在 <span class="exturl" data-url="aHR0cDovL2NyYXRlcy5pbw==">crates.io<i class="fa fa-external-link-alt"></i></span> 上发布与网络相关的库的人都想要使用异步 Rust,无论是出于商业原因还是仅仅出于兴趣.我希望能够更轻松地在非异步上下文中使用这些库 (例如,通过将类似 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnJzL3BvbGxzdGVyLzAuMy4wL3BvbGxzdGVyLw==">pollster<i class="fa fa-external-link-alt"></i></span> 的 API 引入标准库),但很难知道该对那些抱怨的人说什么,他们抱怨在网上免费提供代码的人与他们的用例不完全相同.</p><h2 id="未完待续"><a class="markdownIt-Anchor" href="#未完待续"></a> 未完待续</h2><p>尽管我认为 Rust 别无选择,但我不认为 async/await 是任何语言的正确选择.特别是,我认为有可能出现一种语言,它提供与 Rust 相同的可靠性保证,但对值的运行时表示的控制较少,它使用有栈协程而不是无栈协程.我甚至认为 - 如果这种语言以这样一种方式支持这种协程,即它们可以同时用于迭代和并发 - 该语言可以完全不使用生命周期,同时仍然消除由别名可变性引起的错误.如果你读了他的 <span class="exturl" data-url="aHR0cHM6Ly9ncmF5ZG9uMi5kcmVhbXdpZHRoLm9yZy8zMDcyOTEuaHRtbA==">笔记<i class="fa fa-external-link-alt"></i></span>,你可以看到这就是 Graydon Hoare 最初的目标,在 Rust 改变方向成为一种可以与 C 和 C++ 竞争的系统语言之前.</p><p>我认为有一些 Rust 用户,如果这种语言存在,他们会很高兴使用它,我理解他们为什么不喜欢必须处理低级细节固有的复杂性.过去这些用户常常抱怨众多的字符串类型,现在他们更有可能抱怨异步.我希望有一种语言能为这个用例提供与 Rust 相同种类的保证,但问题不在于 Rust.</p><p>尽管我相信 async/await 是 Rust 的正确方法,但我也认为对当今异步生态系统的状态感到不满是合理的.我们在 2019 年发布了一个 MVP,tokio 在 2020 年发布了 1.0 版,此后的发展比任何参与者希望的都要停滞.在后续文章中,我想讨论当今异步生态系统的状态,以及我认为该项目可以做些什么来改善用户体验.但这已经是我发表过的最长的博文了,所以现在我就到此为止.</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Jasper</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jasper1024.com/jasper/20240307104034/" title="为什么选择 async Rust">https://jasper1024.com/jasper/20240307104034/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/async/" rel="tag"># async</a></div><div class="post-nav"><div class="post-nav-item"><a href="/jasper/20240307104734/" rel="prev" title="异步 Rust 的四年计划"><i class="fa fa-angle-left"></i> 异步 Rust 的四年计划</a></div><div class="post-nav-item"><a href="/jasper/20240318094653/" rel="next" title="2024-03 月随想">2024-03 月随想 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-disqus">disqus</a></li><li class="tab"><a href="#comment-utterances">utterances</a></li></ul><div class="tab-content"><div class="tab-pane disqus" id="comment-disqus"><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><div class="tab-pane utterances" id="comment-utterances"><div class="comments utterances-container"></div></div></div></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">JasperHale</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.4m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">20:54</span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phc3Blci0xMDI0" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"jasper1024","count":true,"i18n":{"disqus":"disqus"}}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/disqus.min.js" defer></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Jasper-1024/blog_discuss","issue_term":"pathname","theme":"github-dark"}</script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-next@8.25.0/source/js/third-party/comments/utterances.min.js" defer></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>